{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to wyvern's documentation. wyvern is a flexible and easy to use Discord API wrapper for python \ud83d\ude80. Installation $python -m pip install git+https://github.com/sarthhh/wyvern Important Links Support server: https://discord.gg/FyEE54u9GF Github: https://github.com/sarthhh/wyervn PYPI: https://pypi.org/project/wyvern Looking for examples? Check our Guide out! Or continue with reading the API Reference . Warning The library is still under development, things can be un-documented and might not work as expected. If you face a situation, feel free to open an issue here","title":"Getting Started"},{"location":"#welcome-to-wyverns-documentation","text":"wyvern is a flexible and easy to use Discord API wrapper for python \ud83d\ude80.","title":"Welcome to wyvern's documentation."},{"location":"#installation","text":"$python -m pip install git+https://github.com/sarthhh/wyvern","title":"Installation"},{"location":"#important-links","text":"Support server: https://discord.gg/FyEE54u9GF Github: https://github.com/sarthhh/wyervn PYPI: https://pypi.org/project/wyvern Looking for examples? Check our Guide out! Or continue with reading the API Reference . Warning The library is still under development, things can be un-documented and might not work as expected. If you face a situation, feel free to open an issue here","title":"Important Links"},{"location":"api_reference/clients/","text":"CommandsClient Bases: GatewayClient , commands . CommandHandler Implementation of the wyvern.GatewayClient class with a command handler. Source code in wyvern/clients.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 class CommandsClient ( GatewayClient , commands . CommandHandler ): \"\"\"Implementation of the [wyvern.GatewayClient][] class with a command handler.\"\"\" slash_commands : dict [ str , \"commands.slash_commands.SlashCommand\" ] = {} \"\"\"List of slash commands attached to the client in code.\"\"\" slash_groups : dict [ str , \"commands.slash_commands.SlashGroup\" ] = {} \"\"\"List of slash command groups attached to the client in code.\"\"\" @events . as_listener ( events . Event . INTERACTION_CREATE ) async def _handle_inters ( self , inter : interactions . Interaction ) -> None : if isinstance ( inter , interactions . ApplicationCommandInteraction ): await self . process_application_commands ( inter ) def add_slash_command ( self , command : commands . slash_commands . SlashCommand ) -> None : if ( name := command . name ) in self . slash_commands . keys (): raise exceptions . CommandAlreadyExists ( f \"A slash command named { name } already exists.\" ) _LOGGER . debug ( f \"Adding slash command { name } to bot.\" ) self . slash_commands [ name ] = command def add_slash_group ( self , group : commands . slash_commands . SlashGroup ) -> None : if ( name := group . name ) in self . slash_groups . keys (): raise exceptions . CommandAlreadyExists ( f \"A slash command named { name } already exists.\" ) _LOGGER . debug ( f \"Adding slash group { name } to bot.\" ) self . slash_groups [ name ] = group @typing . overload def add_item ( self , listener_or_command : events . EventListener ) -> events . EventListener : ... @typing . overload def add_item ( self , listener_or_command : commands . slash_commands . SlashCommand ) -> commands . slash_commands . SlashCommand : ... def add_item ( self , listener_or_command : events . EventListener | commands . slash_commands . SlashCommand | typing . Any ) -> events . EventListener | commands . slash_commands . SlashCommand : def inner () -> None : nonlocal listener_or_command if isinstance ( listener_or_command , events . EventListener ): self . event_handler . add_listener ( listener_or_command ) elif isinstance ( listener_or_command , commands . slash_commands . SlashCommand ): self . add_slash_command ( listener_or_command ) inner () return listener_or_command def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner slash_commands : dict [ str , commands . slash_commands . SlashCommand ] = {} class-attribute List of slash commands attached to the client in code. slash_groups : dict [ str , commands . slash_commands . SlashGroup ] = {} class-attribute List of slash command groups attached to the client in code. set_prefix ( prefix_or_function ) Set a prefix to parse message commands. Allowed prefix data strings : str iterables : list / set / tuple callables : builtins.function or a asyncio.coroutine . Source code in wyvern/clients.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self with_slash_command ( * , name , description ) Creates a slash command. Parameters: Name Type Description Default name str Name of the command. required description str Description of the command. required Returns: Type Description typing . Callable [..., commands . slash_commands . SlashCommand ] A wyvern.commands.slash_commands.SlashCommand when called. Source code in wyvern/clients.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner GatewayClient Bases: events . _InClassEventContainer The main bot class which acts as an interface between the Discord API and your bot. Parameters: Name Type Description Default intents typing . SupportsInt | wyvern . intents . Intents The intents to use while logging in to the gateway. _intents.Intents.UNPRIVILEGED allowed_mentions wyvern . models . messages . AllowedMentions The default mentions to allow in a message bot is sending. models.messages.AllowedMentions() event_handler type [ events . EventHandler ] A EventHandler subclass ( not instance ), if any. events.EventHandler rest_client RESTClient | None A custom RESTClient subclass to use, if any. None api_version int Discord API version to use. 10 client_session aiohttp . ClientSession | None ClientSession subclass to use, if any. None Source code in wyvern/clients.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 class GatewayClient ( events . _InClassEventContainer ): \"\"\"The main bot class which acts as an interface between the Discord API and your bot. Parameters ---------- token : str The bot token to use. intents : typing.SupportsInt | wyvern.intents.Intents The intents to use while logging in to the gateway. allowed_mentions : wyvern.models.messages.AllowedMentions The default mentions to allow in a message bot is sending. event_handler type[EventHandler] A EventHandler subclass ( not instance ), if any. rest_client : RESTClient | None A custom RESTClient subclass to use, if any. api_version : int Discord API version to use. client_session : aiohttp.ClientSession | None ClientSession subclass to use, if any. \"\"\" __identity__ : str = \"bot_class\" hooks : dict [ str , utils . Hook ] = {} \"\"\"Mapping of loaded hook names to their objects.\"\"\" plugins : dict [ str , _plugins . Plugin ] = {} \"\"\"Mapping of loaded plugin names to their objects.\"\"\" def __init__ ( self , token : str , * , intents : typing . SupportsInt | _intents . Intents = _intents . Intents . UNPRIVILEGED , event_handler : type [ events . EventHandler ] = events . EventHandler , allowed_mentions : models . AllowedMentions = models . messages . AllowedMentions (), rest_client : rest . RESTClient | None = None , api_version : int = 10 , client_session : aiohttp . ClientSession | None = None , ) -> None : self . _client_id : int = 0 self . event_handler = event_handler ( self ) self . rest = rest_client or rest . RESTClient ( client = self , token = token , api_version = api_version , client_session = client_session ) self . intents = intents if isinstance ( intents , _intents . Intents ) else _intents . Intents ( int ( intents )) self . gateway = gateway . Gateway ( self ) self . allowed_mentions = allowed_mentions self . _users = state_handlers . UsersState ( self ) self . _members = state_handlers . MembersState ( self ) self . _logger = _LOGGER @property def users ( self ) -> state_handlers . UsersState : \"\"\"The state handler for users stored in the bot's cache, Can also be used to perform fetch operations and parsing users from string. Returns ------- wyvern.state_handlers.UsersState The handler. \"\"\" return self . _users @property def members ( self ) -> state_handlers . MembersState : \"\"\"The member state for members in bot's cache. Similar to `users` cache. Returns ------- wyvern.state_handlers.MembersState The member handler. \"\"\" return self . _members @property def latency ( self ) -> float : \"\"\"The heartbeat latency of the gateway connection. Returns ------- float The latency. \"\"\" return self . gateway . latency async def wait_for ( self , event : events . Event , * , timeout : int = 180 , check : typing . Callable [ ... , bool ] = lambda * _ : True ) -> typing . Any : ... def with_listener ( self , event : events . Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], events . EventListener ]: \"\"\"Creates and adds a new listenet to the client's event handler. Parameters ---------- event: str | wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. ??? example ```py import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def message_create(message: wyvern.Message) -> None: if message.content == \".ping\": await message.respond(\"pong\") client.run() ``` \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> events . EventListener : lsnr = events . as_listener ( event , max_trigger = max_trigger )( callback ) self . event_handler . add_listener ( lsnr ) return lsnr return inner async def start ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"Connects the bot with gateway and starts listening to events. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" self . event_handler . setup_listeners () self . event_handler . dispatch ( events . Event . STARTING , self ) self . gateway . _start_activity = activity self . gateway . _start_status = status await self . gateway . _get_socket_ready () _LOGGER . info ( \"Logging in with bot token.\" ) try : res = await self . rest . fetch_client_user () _LOGGER . info ( \"Logged in to the gateway with bot token.\" ) _LOGGER . info ( \"(Session info) User ID: %s , Username: %s \" , res . id , res . username ) self . _client_id = res . id self . event_handler . dispatch ( events . Event . STARTED , self ) await self . gateway . listen_gateway () except exceptions . Unauthorized as e : await self . rest . _session . close () e . message += \", Improper token was passed.\" raise e def run ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"A non-async method which call [wyvern.clients.GatewayClient.start][]. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" loop = asyncio . get_event_loop () loop . run_until_complete ( self . start ( activity = activity , status = status )) def load_hooks ( self , path : str ) -> dict [ str , utils . Hook ]: \"\"\"Loads hooks from the provided path ??? note The path should be a python import path. Parameters ---------- path : str Path to load hooks from. Returns ------- dict[str, wyvern.utils.Hook] The hooks that were loaded. \"\"\" module = importlib . import_module ( path ) hooks = { hook . name : hook for hook in module . __dict__ . values () if isinstance ( hook , utils . Hook )} if any ( overrided := [ hook for hook in hooks . keys () if hook in self . hooks . keys ()]): self . _logger . warning ( \"Overring loaded hooks: %s \" , \", \" . join ( overrided )) self . hooks . update ( hooks ) return hooks def get_hooks ( self , * , awaitable : bool = True , non_awaitable : bool = True ) -> list [ utils . Hook ]: \"\"\"Get's loaded hooks. Parameters ---------- awaitable : bool If awaitable hooks should be added to return value. non_awaitable : bool If non-awaitable hooks should be added to return value. Returns ------- list[wyvern.utils.Hook] List of the hooks. \"\"\" hooks : list [ utils . Hook ] = [] if awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if inspect . isawaitable ( hook . callback )]) if non_awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if not inspect . isawaitable ( hook . callback )]) return hooks def add_plugin ( self , plugin : _plugins . Plugin ) -> None : \"\"\"Adds a plugin to the bot. Parameters ---------- plugin : wyvern.plugins.Plugin The plugin to be added. \"\"\" if plugin . name in self . plugins . keys (): raise exceptions . PluginException ( \"Plugin %s is already loaded.\" % ( plugin . name )) self . plugins [ plugin . name ] = plugin plugin . setup_plugin ( self ) hooks : dict [ str , utils . Hook ] = {} class-attribute Mapping of loaded hook names to their objects. plugins : dict [ str , _plugins . Plugin ] = {} class-attribute Mapping of loaded plugin names to their objects. add_plugin ( plugin ) Adds a plugin to the bot. Parameters: Name Type Description Default plugin wyvern . plugins . Plugin The plugin to be added. required Source code in wyvern/clients.py 283 284 285 286 287 288 289 290 291 292 293 294 def add_plugin ( self , plugin : _plugins . Plugin ) -> None : \"\"\"Adds a plugin to the bot. Parameters ---------- plugin : wyvern.plugins.Plugin The plugin to be added. \"\"\" if plugin . name in self . plugins . keys (): raise exceptions . PluginException ( \"Plugin %s is already loaded.\" % ( plugin . name )) self . plugins [ plugin . name ] = plugin plugin . setup_plugin ( self ) get_hooks ( * , awaitable = True , non_awaitable = True ) Get's loaded hooks. Parameters: Name Type Description Default awaitable bool If awaitable hooks should be added to return value. True non_awaitable bool If non-awaitable hooks should be added to return value. True Returns: Type Description list [ wyvern . utils . Hook ] List of the hooks. Source code in wyvern/clients.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def get_hooks ( self , * , awaitable : bool = True , non_awaitable : bool = True ) -> list [ utils . Hook ]: \"\"\"Get's loaded hooks. Parameters ---------- awaitable : bool If awaitable hooks should be added to return value. non_awaitable : bool If non-awaitable hooks should be added to return value. Returns ------- list[wyvern.utils.Hook] List of the hooks. \"\"\" hooks : list [ utils . Hook ] = [] if awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if inspect . isawaitable ( hook . callback )]) if non_awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if not inspect . isawaitable ( hook . callback )]) return hooks latency () property The heartbeat latency of the gateway connection. Returns ------- float The latency. Source code in wyvern/clients.py 137 138 139 140 141 142 143 144 145 146 @property def latency ( self ) -> float : \"\"\"The heartbeat latency of the gateway connection. Returns ------- float The latency. \"\"\" return self . gateway . latency load_hooks ( path ) Loads hooks from the provided path Note The path should be a python import path. Parameters: Name Type Description Default path str Path to load hooks from. required Returns: Type Description dict [ str , wyvern . utils . Hook ] The hooks that were loaded. Source code in wyvern/clients.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def load_hooks ( self , path : str ) -> dict [ str , utils . Hook ]: \"\"\"Loads hooks from the provided path ??? note The path should be a python import path. Parameters ---------- path : str Path to load hooks from. Returns ------- dict[str, wyvern.utils.Hook] The hooks that were loaded. \"\"\" module = importlib . import_module ( path ) hooks = { hook . name : hook for hook in module . __dict__ . values () if isinstance ( hook , utils . Hook )} if any ( overrided := [ hook for hook in hooks . keys () if hook in self . hooks . keys ()]): self . _logger . warning ( \"Overring loaded hooks: %s \" , \", \" . join ( overrided )) self . hooks . update ( hooks ) return hooks members () property The member state for members in bot's cache. Similar to users cache. Returns: Type Description wyvern . state_handlers . MembersState The member handler. Source code in wyvern/clients.py 126 127 128 129 130 131 132 133 134 135 @property def members ( self ) -> state_handlers . MembersState : \"\"\"The member state for members in bot's cache. Similar to `users` cache. Returns ------- wyvern.state_handlers.MembersState The member handler. \"\"\" return self . _members run ( * , activity = None , status = None ) A non-async method which call wyvern.clients.GatewayClient.start . Parameters: Name Type Description Default status wyvern . presences . Status | None The status bot boots up with. None Source code in wyvern/clients.py 225 226 227 228 229 230 231 232 233 234 235 236 def run ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"A non-async method which call [wyvern.clients.GatewayClient.start][]. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" loop = asyncio . get_event_loop () loop . run_until_complete ( self . start ( activity = activity , status = status )) start ( * , activity = None , status = None ) async Connects the bot with gateway and starts listening to events. Parameters: Name Type Description Default status wyvern . presences . Status | None The status bot boots up with. None Source code in wyvern/clients.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 async def start ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"Connects the bot with gateway and starts listening to events. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" self . event_handler . setup_listeners () self . event_handler . dispatch ( events . Event . STARTING , self ) self . gateway . _start_activity = activity self . gateway . _start_status = status await self . gateway . _get_socket_ready () _LOGGER . info ( \"Logging in with bot token.\" ) try : res = await self . rest . fetch_client_user () _LOGGER . info ( \"Logged in to the gateway with bot token.\" ) _LOGGER . info ( \"(Session info) User ID: %s , Username: %s \" , res . id , res . username ) self . _client_id = res . id self . event_handler . dispatch ( events . Event . STARTED , self ) await self . gateway . listen_gateway () except exceptions . Unauthorized as e : await self . rest . _session . close () e . message += \", Improper token was passed.\" raise e users () property The state handler for users stored in the bot's cache, Can also be used to perform fetch operations and parsing users from string. Returns: Type Description wyvern.state_handlers.UsersState The handler. Source code in wyvern/clients.py 114 115 116 117 118 119 120 121 122 123 124 @property def users ( self ) -> state_handlers . UsersState : \"\"\"The state handler for users stored in the bot's cache, Can also be used to perform fetch operations and parsing users from string. Returns ------- wyvern.state_handlers.UsersState The handler. \"\"\" return self . _users with_listener ( event , * , max_trigger = float ( 'inf' )) Creates and adds a new listenet to the client's event handler. Parameters: Name Type Description Default max_trigger int | float Maximum number of times this listener has to be triggered. float('inf') Returns: Type Description wyvern.events.EventListener A EventListener object. Example import wyvern client = wyvern . GatewayClient ( \"TOKEN\" ) @client . with_listener ( wyvern . Event . MESSAGE_CREATE ) async def message_create ( message : wyvern . Message ) -> None : if message . content == \".ping\" : await message . respond ( \"pong\" ) client . run () Source code in wyvern/clients.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def with_listener ( self , event : events . Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], events . EventListener ]: \"\"\"Creates and adds a new listenet to the client's event handler. Parameters ---------- event: str | wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. ??? example ```py import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def message_create(message: wyvern.Message) -> None: if message.content == \".ping\": await message.respond(\"pong\") client.run() ``` \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> events . EventListener : lsnr = events . as_listener ( event , max_trigger = max_trigger )( callback ) self . event_handler . add_listener ( lsnr ) return lsnr return inner","title":"clients"},{"location":"api_reference/clients/#wyvern.clients.CommandsClient","text":"Bases: GatewayClient , commands . CommandHandler Implementation of the wyvern.GatewayClient class with a command handler. Source code in wyvern/clients.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 class CommandsClient ( GatewayClient , commands . CommandHandler ): \"\"\"Implementation of the [wyvern.GatewayClient][] class with a command handler.\"\"\" slash_commands : dict [ str , \"commands.slash_commands.SlashCommand\" ] = {} \"\"\"List of slash commands attached to the client in code.\"\"\" slash_groups : dict [ str , \"commands.slash_commands.SlashGroup\" ] = {} \"\"\"List of slash command groups attached to the client in code.\"\"\" @events . as_listener ( events . Event . INTERACTION_CREATE ) async def _handle_inters ( self , inter : interactions . Interaction ) -> None : if isinstance ( inter , interactions . ApplicationCommandInteraction ): await self . process_application_commands ( inter ) def add_slash_command ( self , command : commands . slash_commands . SlashCommand ) -> None : if ( name := command . name ) in self . slash_commands . keys (): raise exceptions . CommandAlreadyExists ( f \"A slash command named { name } already exists.\" ) _LOGGER . debug ( f \"Adding slash command { name } to bot.\" ) self . slash_commands [ name ] = command def add_slash_group ( self , group : commands . slash_commands . SlashGroup ) -> None : if ( name := group . name ) in self . slash_groups . keys (): raise exceptions . CommandAlreadyExists ( f \"A slash command named { name } already exists.\" ) _LOGGER . debug ( f \"Adding slash group { name } to bot.\" ) self . slash_groups [ name ] = group @typing . overload def add_item ( self , listener_or_command : events . EventListener ) -> events . EventListener : ... @typing . overload def add_item ( self , listener_or_command : commands . slash_commands . SlashCommand ) -> commands . slash_commands . SlashCommand : ... def add_item ( self , listener_or_command : events . EventListener | commands . slash_commands . SlashCommand | typing . Any ) -> events . EventListener | commands . slash_commands . SlashCommand : def inner () -> None : nonlocal listener_or_command if isinstance ( listener_or_command , events . EventListener ): self . event_handler . add_listener ( listener_or_command ) elif isinstance ( listener_or_command , commands . slash_commands . SlashCommand ): self . add_slash_command ( listener_or_command ) inner () return listener_or_command def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner","title":"CommandsClient"},{"location":"api_reference/clients/#wyvern.clients.CommandsClient.slash_commands","text":"List of slash commands attached to the client in code.","title":"slash_commands"},{"location":"api_reference/clients/#wyvern.clients.CommandsClient.slash_groups","text":"List of slash command groups attached to the client in code.","title":"slash_groups"},{"location":"api_reference/clients/#wyvern.clients.CommandsClient.set_prefix","text":"Set a prefix to parse message commands. Allowed prefix data strings : str iterables : list / set / tuple callables : builtins.function or a asyncio.coroutine . Source code in wyvern/clients.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self","title":"set_prefix()"},{"location":"api_reference/clients/#wyvern.clients.CommandsClient.with_slash_command","text":"Creates a slash command. Parameters: Name Type Description Default name str Name of the command. required description str Description of the command. required Returns: Type Description typing . Callable [..., commands . slash_commands . SlashCommand ] A wyvern.commands.slash_commands.SlashCommand when called. Source code in wyvern/clients.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner","title":"with_slash_command()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient","text":"Bases: events . _InClassEventContainer The main bot class which acts as an interface between the Discord API and your bot. Parameters: Name Type Description Default intents typing . SupportsInt | wyvern . intents . Intents The intents to use while logging in to the gateway. _intents.Intents.UNPRIVILEGED allowed_mentions wyvern . models . messages . AllowedMentions The default mentions to allow in a message bot is sending. models.messages.AllowedMentions() event_handler type [ events . EventHandler ] A EventHandler subclass ( not instance ), if any. events.EventHandler rest_client RESTClient | None A custom RESTClient subclass to use, if any. None api_version int Discord API version to use. 10 client_session aiohttp . ClientSession | None ClientSession subclass to use, if any. None Source code in wyvern/clients.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 class GatewayClient ( events . _InClassEventContainer ): \"\"\"The main bot class which acts as an interface between the Discord API and your bot. Parameters ---------- token : str The bot token to use. intents : typing.SupportsInt | wyvern.intents.Intents The intents to use while logging in to the gateway. allowed_mentions : wyvern.models.messages.AllowedMentions The default mentions to allow in a message bot is sending. event_handler type[EventHandler] A EventHandler subclass ( not instance ), if any. rest_client : RESTClient | None A custom RESTClient subclass to use, if any. api_version : int Discord API version to use. client_session : aiohttp.ClientSession | None ClientSession subclass to use, if any. \"\"\" __identity__ : str = \"bot_class\" hooks : dict [ str , utils . Hook ] = {} \"\"\"Mapping of loaded hook names to their objects.\"\"\" plugins : dict [ str , _plugins . Plugin ] = {} \"\"\"Mapping of loaded plugin names to their objects.\"\"\" def __init__ ( self , token : str , * , intents : typing . SupportsInt | _intents . Intents = _intents . Intents . UNPRIVILEGED , event_handler : type [ events . EventHandler ] = events . EventHandler , allowed_mentions : models . AllowedMentions = models . messages . AllowedMentions (), rest_client : rest . RESTClient | None = None , api_version : int = 10 , client_session : aiohttp . ClientSession | None = None , ) -> None : self . _client_id : int = 0 self . event_handler = event_handler ( self ) self . rest = rest_client or rest . RESTClient ( client = self , token = token , api_version = api_version , client_session = client_session ) self . intents = intents if isinstance ( intents , _intents . Intents ) else _intents . Intents ( int ( intents )) self . gateway = gateway . Gateway ( self ) self . allowed_mentions = allowed_mentions self . _users = state_handlers . UsersState ( self ) self . _members = state_handlers . MembersState ( self ) self . _logger = _LOGGER @property def users ( self ) -> state_handlers . UsersState : \"\"\"The state handler for users stored in the bot's cache, Can also be used to perform fetch operations and parsing users from string. Returns ------- wyvern.state_handlers.UsersState The handler. \"\"\" return self . _users @property def members ( self ) -> state_handlers . MembersState : \"\"\"The member state for members in bot's cache. Similar to `users` cache. Returns ------- wyvern.state_handlers.MembersState The member handler. \"\"\" return self . _members @property def latency ( self ) -> float : \"\"\"The heartbeat latency of the gateway connection. Returns ------- float The latency. \"\"\" return self . gateway . latency async def wait_for ( self , event : events . Event , * , timeout : int = 180 , check : typing . Callable [ ... , bool ] = lambda * _ : True ) -> typing . Any : ... def with_listener ( self , event : events . Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], events . EventListener ]: \"\"\"Creates and adds a new listenet to the client's event handler. Parameters ---------- event: str | wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. ??? example ```py import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def message_create(message: wyvern.Message) -> None: if message.content == \".ping\": await message.respond(\"pong\") client.run() ``` \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> events . EventListener : lsnr = events . as_listener ( event , max_trigger = max_trigger )( callback ) self . event_handler . add_listener ( lsnr ) return lsnr return inner async def start ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"Connects the bot with gateway and starts listening to events. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" self . event_handler . setup_listeners () self . event_handler . dispatch ( events . Event . STARTING , self ) self . gateway . _start_activity = activity self . gateway . _start_status = status await self . gateway . _get_socket_ready () _LOGGER . info ( \"Logging in with bot token.\" ) try : res = await self . rest . fetch_client_user () _LOGGER . info ( \"Logged in to the gateway with bot token.\" ) _LOGGER . info ( \"(Session info) User ID: %s , Username: %s \" , res . id , res . username ) self . _client_id = res . id self . event_handler . dispatch ( events . Event . STARTED , self ) await self . gateway . listen_gateway () except exceptions . Unauthorized as e : await self . rest . _session . close () e . message += \", Improper token was passed.\" raise e def run ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"A non-async method which call [wyvern.clients.GatewayClient.start][]. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" loop = asyncio . get_event_loop () loop . run_until_complete ( self . start ( activity = activity , status = status )) def load_hooks ( self , path : str ) -> dict [ str , utils . Hook ]: \"\"\"Loads hooks from the provided path ??? note The path should be a python import path. Parameters ---------- path : str Path to load hooks from. Returns ------- dict[str, wyvern.utils.Hook] The hooks that were loaded. \"\"\" module = importlib . import_module ( path ) hooks = { hook . name : hook for hook in module . __dict__ . values () if isinstance ( hook , utils . Hook )} if any ( overrided := [ hook for hook in hooks . keys () if hook in self . hooks . keys ()]): self . _logger . warning ( \"Overring loaded hooks: %s \" , \", \" . join ( overrided )) self . hooks . update ( hooks ) return hooks def get_hooks ( self , * , awaitable : bool = True , non_awaitable : bool = True ) -> list [ utils . Hook ]: \"\"\"Get's loaded hooks. Parameters ---------- awaitable : bool If awaitable hooks should be added to return value. non_awaitable : bool If non-awaitable hooks should be added to return value. Returns ------- list[wyvern.utils.Hook] List of the hooks. \"\"\" hooks : list [ utils . Hook ] = [] if awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if inspect . isawaitable ( hook . callback )]) if non_awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if not inspect . isawaitable ( hook . callback )]) return hooks def add_plugin ( self , plugin : _plugins . Plugin ) -> None : \"\"\"Adds a plugin to the bot. Parameters ---------- plugin : wyvern.plugins.Plugin The plugin to be added. \"\"\" if plugin . name in self . plugins . keys (): raise exceptions . PluginException ( \"Plugin %s is already loaded.\" % ( plugin . name )) self . plugins [ plugin . name ] = plugin plugin . setup_plugin ( self )","title":"GatewayClient"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.hooks","text":"Mapping of loaded hook names to their objects.","title":"hooks"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.plugins","text":"Mapping of loaded plugin names to their objects.","title":"plugins"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.add_plugin","text":"Adds a plugin to the bot. Parameters: Name Type Description Default plugin wyvern . plugins . Plugin The plugin to be added. required Source code in wyvern/clients.py 283 284 285 286 287 288 289 290 291 292 293 294 def add_plugin ( self , plugin : _plugins . Plugin ) -> None : \"\"\"Adds a plugin to the bot. Parameters ---------- plugin : wyvern.plugins.Plugin The plugin to be added. \"\"\" if plugin . name in self . plugins . keys (): raise exceptions . PluginException ( \"Plugin %s is already loaded.\" % ( plugin . name )) self . plugins [ plugin . name ] = plugin plugin . setup_plugin ( self )","title":"add_plugin()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.get_hooks","text":"Get's loaded hooks. Parameters: Name Type Description Default awaitable bool If awaitable hooks should be added to return value. True non_awaitable bool If non-awaitable hooks should be added to return value. True Returns: Type Description list [ wyvern . utils . Hook ] List of the hooks. Source code in wyvern/clients.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 def get_hooks ( self , * , awaitable : bool = True , non_awaitable : bool = True ) -> list [ utils . Hook ]: \"\"\"Get's loaded hooks. Parameters ---------- awaitable : bool If awaitable hooks should be added to return value. non_awaitable : bool If non-awaitable hooks should be added to return value. Returns ------- list[wyvern.utils.Hook] List of the hooks. \"\"\" hooks : list [ utils . Hook ] = [] if awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if inspect . isawaitable ( hook . callback )]) if non_awaitable is True : hooks . extend ([ hook for hook in self . hooks . values () if not inspect . isawaitable ( hook . callback )]) return hooks","title":"get_hooks()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.latency","text":"The heartbeat latency of the gateway connection. Returns ------- float The latency. Source code in wyvern/clients.py 137 138 139 140 141 142 143 144 145 146 @property def latency ( self ) -> float : \"\"\"The heartbeat latency of the gateway connection. Returns ------- float The latency. \"\"\" return self . gateway . latency","title":"latency()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.load_hooks","text":"Loads hooks from the provided path Note The path should be a python import path. Parameters: Name Type Description Default path str Path to load hooks from. required Returns: Type Description dict [ str , wyvern . utils . Hook ] The hooks that were loaded. Source code in wyvern/clients.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def load_hooks ( self , path : str ) -> dict [ str , utils . Hook ]: \"\"\"Loads hooks from the provided path ??? note The path should be a python import path. Parameters ---------- path : str Path to load hooks from. Returns ------- dict[str, wyvern.utils.Hook] The hooks that were loaded. \"\"\" module = importlib . import_module ( path ) hooks = { hook . name : hook for hook in module . __dict__ . values () if isinstance ( hook , utils . Hook )} if any ( overrided := [ hook for hook in hooks . keys () if hook in self . hooks . keys ()]): self . _logger . warning ( \"Overring loaded hooks: %s \" , \", \" . join ( overrided )) self . hooks . update ( hooks ) return hooks","title":"load_hooks()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.members","text":"The member state for members in bot's cache. Similar to users cache. Returns: Type Description wyvern . state_handlers . MembersState The member handler. Source code in wyvern/clients.py 126 127 128 129 130 131 132 133 134 135 @property def members ( self ) -> state_handlers . MembersState : \"\"\"The member state for members in bot's cache. Similar to `users` cache. Returns ------- wyvern.state_handlers.MembersState The member handler. \"\"\" return self . _members","title":"members()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.run","text":"A non-async method which call wyvern.clients.GatewayClient.start . Parameters: Name Type Description Default status wyvern . presences . Status | None The status bot boots up with. None Source code in wyvern/clients.py 225 226 227 228 229 230 231 232 233 234 235 236 def run ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"A non-async method which call [wyvern.clients.GatewayClient.start][]. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" loop = asyncio . get_event_loop () loop . run_until_complete ( self . start ( activity = activity , status = status ))","title":"run()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.start","text":"Connects the bot with gateway and starts listening to events. Parameters: Name Type Description Default status wyvern . presences . Status | None The status bot boots up with. None Source code in wyvern/clients.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 async def start ( self , * , activity : presences . Activity | None = None , status : presences . Status | None = None ) -> None : \"\"\"Connects the bot with gateway and starts listening to events. Parameters ---------- activity : wyvern.presences.Activity | None The activity bot boots up with. status : wyvern.presences.Status | None The status bot boots up with. \"\"\" self . event_handler . setup_listeners () self . event_handler . dispatch ( events . Event . STARTING , self ) self . gateway . _start_activity = activity self . gateway . _start_status = status await self . gateway . _get_socket_ready () _LOGGER . info ( \"Logging in with bot token.\" ) try : res = await self . rest . fetch_client_user () _LOGGER . info ( \"Logged in to the gateway with bot token.\" ) _LOGGER . info ( \"(Session info) User ID: %s , Username: %s \" , res . id , res . username ) self . _client_id = res . id self . event_handler . dispatch ( events . Event . STARTED , self ) await self . gateway . listen_gateway () except exceptions . Unauthorized as e : await self . rest . _session . close () e . message += \", Improper token was passed.\" raise e","title":"start()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.users","text":"The state handler for users stored in the bot's cache, Can also be used to perform fetch operations and parsing users from string. Returns: Type Description wyvern.state_handlers.UsersState The handler. Source code in wyvern/clients.py 114 115 116 117 118 119 120 121 122 123 124 @property def users ( self ) -> state_handlers . UsersState : \"\"\"The state handler for users stored in the bot's cache, Can also be used to perform fetch operations and parsing users from string. Returns ------- wyvern.state_handlers.UsersState The handler. \"\"\" return self . _users","title":"users()"},{"location":"api_reference/clients/#wyvern.clients.GatewayClient.with_listener","text":"Creates and adds a new listenet to the client's event handler. Parameters: Name Type Description Default max_trigger int | float Maximum number of times this listener has to be triggered. float('inf') Returns: Type Description wyvern.events.EventListener A EventListener object. Example import wyvern client = wyvern . GatewayClient ( \"TOKEN\" ) @client . with_listener ( wyvern . Event . MESSAGE_CREATE ) async def message_create ( message : wyvern . Message ) -> None : if message . content == \".ping\" : await message . respond ( \"pong\" ) client . run () Source code in wyvern/clients.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 def with_listener ( self , event : events . Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], events . EventListener ]: \"\"\"Creates and adds a new listenet to the client's event handler. Parameters ---------- event: str | wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. ??? example ```py import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def message_create(message: wyvern.Message) -> None: if message.content == \".ping\": await message.respond(\"pong\") client.run() ``` \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> events . EventListener : lsnr = events . as_listener ( event , max_trigger = max_trigger )( callback ) self . event_handler . add_listener ( lsnr ) return lsnr return inner","title":"with_listener()"},{"location":"api_reference/colors/","text":"Color Class representing a color in the RGB color space. Alias name Colour exists for convenience. Attributes: Name Type Description value int The value of the color. This is a 24-bit integer, where the first 8 bits are the red value, the next 8 bits are the green value, and the last 8 bits are the blue value. Source code in wyvern/colors.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 @typing . final class Color : \"\"\" Class representing a color in the RGB color space. Alias name Colour exists for convenience. Attributes ---------- value : int The value of the color. This is a 24-bit integer, where the first 8 bits are the red value, the next 8 bits are the green value, and the last 8 bits are the blue value. \"\"\" __slots__ : tuple [ str , ... ] = ( \"value\" ,) RGB_REGEX : re . Pattern [ str ] = re . compile ( r \"rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)\" ) HSL_REGEX : re . Pattern [ str ] = re . compile ( r \"hsl\\((\\d{1,3}), (\\d{1,3})%, (\\d{1,3})%\\)\" ) HSV_REGEX : re . Pattern [ str ] = re . compile ( r \"hsv\\((\\d{1,3}), (\\d{1,3})%, (\\d{1,3})%\\)\" ) HEX_REGEX : re . Pattern [ str ] = re . compile ( r \"#([0-9a-fA-F] {3} |[0-9a-fA-F] {6} )\" ) def __init__ ( self , value : int ) -> None : self . value = value def __repr__ ( self ) -> str : return f \"Color( { self . value } )\" def __eq__ ( self , other : object ) -> bool : return isinstance ( other , Color ) and self . value == other . value def __hash__ ( self ) -> int : return hash ( self . value ) def __ne__ ( self , other : object ) -> bool : return self is not other @classmethod def from_hex ( cls , hex_value : str ) -> Color : \"\"\" Creates a Color object from a hex value. Parameters ---------- hex_value: str The hex value to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hex('#ff0000') Color(16776960) >>> Color.from_hex('#00ff00') Color(255) >>> Color.from_hex('#0000ff') Color(0) \"\"\" if match := cls . HEX_REGEX . match ( hex_value ): hex_value = match . group ( 1 ) if len ( hex_value ) == 3 : hex_value = \"\" . join ( c * 2 for c in hex_value ) return cls ( int ( hex_value , 16 )) raise ValueError ( f \"Invalid hex value: { hex_value } \" ) @classmethod def from_rgb ( cls , r : int , g : int , b : int ) -> Color : \"\"\" Creates a Color object from RGB values. Parameters ---------- r: int The red value. g: int The green value. b: int The blue value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_rgb(255, 0, 0) Color(16711680) >>> Color.from_rgb(0, 255, 0) Color(65280) >>> Color.from_rgb(0, 0, 255) Color(255) \"\"\" return cls (( r << 16 ) + ( g << 8 ) + b ) @classmethod def from_hsv ( cls , h : float , s : float , v : float ) -> Color : \"\"\" Creates a Color object from HSV values. Parameters ---------- h: float The hue value. s: float The saturation value. v: float The value in HSV color space. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsv(0, 1, 1) Color(16711680) >>> Color.from_hsv(120, 1, 1) Color(16711680) >>> Color.from_hsv(240, 1, 1) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hsv_to_rgb ( h , s , v )]) @classmethod def from_hsl ( cls , h : float , s : float , l : float ) -> Color : # noqa: E741 \"\"\" Creates a Color object from HSL values. Parameters ---------- h: float The hue value. s: float The saturation value. l: float The lightness value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsl(0, 1, 0.5) Color(16711680) >>> Color.from_hsl(120, 1, 0.5) Color(16711680) >>> Color.from_hsl(240, 1, 0.5) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hls_to_rgb ( h , l , s )]) @classmethod def from_random ( cls ) -> Color : \"\"\" Creates a Color object from a random color. Randomly generates a color in the RGB color space. Returns ------- wyvern.Color A Color object. \"\"\" return cls . from_rgb ( * [ random . randint ( 0 , 255 ) for _ in range ( 3 )]) @classmethod def from_string ( cls , string : str ) -> Color : \"\"\" Creates a Color object from a string. Parameters ---------- string: str The string to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_string('rgb(255, 0, 0)') Color(16711680) >>> Color.from_string('hsl(0, 100%, 50%)') Color(-80727249750) >>> Color.from_string('hsv(0, 100%, 100%)') Color(1022371500) >>> Color.from_string('#ff0000') Color(16776960) \"\"\" if string . startswith ( \"#\" ): return cls . from_hex ( string ) elif match := cls . RGB_REGEX . match ( string ): return cls . from_rgb ( * [ int ( c ) for c in match . groups ()]) elif match := cls . HSL_REGEX . match ( string ): return cls . from_hsl ( * [ float ( c ) for c in match . groups ()]) elif match := cls . HSV_REGEX . match ( string ): return cls . from_hsv ( * [ float ( c ) for c in match . groups ()]) raise ValueError ( f \"Invalid color string: { string } \" ) @classmethod def default ( cls ) -> Color : \"\"\" Creates a Color object from the default color. This is `0x000000`. (Black) Examples -------- >>> Color.default() Color(0) \"\"\" return cls ( 0x000000 ) @property def hex ( self ) -> str : \"\"\"The hex value of the color.\"\"\" return f \"# { self . value : 06x } \" @property def rgb ( self ) -> tuple [ int , int , int ]: \"\"\"The RGB values of the color.\"\"\" return ( self . value >> 16 ) & 0xFF , ( self . value >> 8 ) & 0xFF , self . value & 0xFF @property def hsv ( self ) -> tuple [ float , float , float ]: \"\"\"The HSV values of the color.\"\"\" return colorsys . rgb_to_hsv ( * ( c / 255 for c in self . rgb )) @property def hsl ( self ) -> tuple [ float , float , float ]: \"\"\"The HSL values of the color.\"\"\" return colorsys . rgb_to_hls ( * ( c / 255 for c in self . rgb )) @property def r ( self ) -> int : \"\"\"The red value of the color.\"\"\" return self . rgb [ 0 ] @property def g ( self ) -> int : \"\"\"The green value of the color.\"\"\" return self . rgb [ 1 ] @property def b ( self ) -> int : \"\"\"The blue value of the color.\"\"\" return self . rgb [ 2 ] @classmethod def red ( cls ) -> Color : \"\"\"Creates a Color object from the red color. This is `0xff0000`. (Red)\"\"\" return cls ( 0xFF0000 ) @classmethod def green ( cls ) -> Color : \"\"\"Creates a Color object from the green color. This is `0x00ff00`. (Green)\"\"\" return cls ( 0x00FF00 ) @classmethod def blue ( cls ) -> Color : \"\"\"Creates a Color object from the blue color. This is `0x0000ff`. (Blue)\"\"\" return cls ( 0x0000FF ) @classmethod def yellow ( cls ) -> Color : \"\"\"Creates a Color object from the yellow color. This is `0xffff00`. (Yellow)\"\"\" return cls ( 0xFFFF00 ) @classmethod def cyan ( cls ) -> Color : \"\"\"Creates a Color object from the cyan color. This is `0x00ffff`. (Cyan)\"\"\" return cls ( 0x00FFFF ) @classmethod def magenta ( cls ) -> Color : \"\"\"Creates a Color object from the magenta color. This is `0xff00ff`. (Magenta)\"\"\" return cls ( 0xFF00FF ) @classmethod def black ( cls ) -> Color : \"\"\"Creates a Color object from the black color. This is `0x000000`. (Black)\"\"\" return cls ( 0x000000 ) @classmethod def white ( cls ) -> Color : \"\"\"Creates a Color object from the white color. This is `0xffffff`. (White)\"\"\" return cls ( 0xFFFFFF ) @classmethod def gray ( cls ) -> Color : \"\"\"Creates a Color object from the gray color. This is `0x808080`. (Gray)\"\"\" return cls ( 0x808080 ) @classmethod def grey ( cls ) -> Color : \"\"\"Creates a Color object from the grey color. This is `0x808080`. (Grey)\"\"\" return cls ( 0x808080 ) @classmethod def orange ( cls ) -> Color : \"\"\"Creates a Color object from the orange color. This is `0xffa500`. (Orange)\"\"\" return cls ( 0xFFA500 ) @classmethod def purple ( cls ) -> Color : \"\"\"Creates a Color object from the purple color. This is `#800080`. (Purple)\"\"\" return cls ( 0x800080 ) @classmethod def brown ( cls ) -> Color : \"\"\"Creates a Color object from the brown color. This is `#a52a2a`. (Brown)\"\"\" return cls ( 0xA52A2A ) @classmethod def silver ( cls ) -> Color : \"\"\"Creates a Color object from the silver color. This is `#c0c0c0`. (Silver)\"\"\" return cls ( 0xC0C0C0 ) @classmethod def aqua ( cls ) -> Color : \"\"\"Creates a Color object from the aqua color. This is `#00ffff`. (Aqua)\"\"\" return cls ( 0x00FFFF ) aqua () classmethod Creates a Color object from the aqua color. This is #00ffff . (Aqua) Source code in wyvern/colors.py 368 369 370 371 @classmethod def aqua ( cls ) -> Color : \"\"\"Creates a Color object from the aqua color. This is `#00ffff`. (Aqua)\"\"\" return cls ( 0x00FFFF ) b () property The blue value of the color. Source code in wyvern/colors.py 293 294 295 296 @property def b ( self ) -> int : \"\"\"The blue value of the color.\"\"\" return self . rgb [ 2 ] black () classmethod Creates a Color object from the black color. This is 0x000000 . (Black) Source code in wyvern/colors.py 328 329 330 331 @classmethod def black ( cls ) -> Color : \"\"\"Creates a Color object from the black color. This is `0x000000`. (Black)\"\"\" return cls ( 0x000000 ) blue () classmethod Creates a Color object from the blue color. This is 0x0000ff . (Blue) Source code in wyvern/colors.py 308 309 310 311 @classmethod def blue ( cls ) -> Color : \"\"\"Creates a Color object from the blue color. This is `0x0000ff`. (Blue)\"\"\" return cls ( 0x0000FF ) brown () classmethod Creates a Color object from the brown color. This is #a52a2a . (Brown) Source code in wyvern/colors.py 358 359 360 361 @classmethod def brown ( cls ) -> Color : \"\"\"Creates a Color object from the brown color. This is `#a52a2a`. (Brown)\"\"\" return cls ( 0xA52A2A ) cyan () classmethod Creates a Color object from the cyan color. This is 0x00ffff . (Cyan) Source code in wyvern/colors.py 318 319 320 321 @classmethod def cyan ( cls ) -> Color : \"\"\"Creates a Color object from the cyan color. This is `0x00ffff`. (Cyan)\"\"\" return cls ( 0x00FFFF ) default () classmethod Creates a Color object from the default color. This is 0x000000 . (Black) Examples: >>> Color.default() Color(0) Source code in wyvern/colors.py 249 250 251 252 253 254 255 256 257 258 259 260 261 @classmethod def default ( cls ) -> Color : \"\"\" Creates a Color object from the default color. This is `0x000000`. (Black) Examples -------- >>> Color.default() Color(0) \"\"\" return cls ( 0x000000 ) from_hex ( hex_value ) classmethod Creates a Color object from a hex value. Parameters: Name Type Description Default hex_value str The hex value to use. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_hex('#ff0000') Color(16776960) >>> Color.from_hex('#00ff00') Color(255) >>> Color.from_hex('#0000ff') Color(0) Source code in wyvern/colors.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @classmethod def from_hex ( cls , hex_value : str ) -> Color : \"\"\" Creates a Color object from a hex value. Parameters ---------- hex_value: str The hex value to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hex('#ff0000') Color(16776960) >>> Color.from_hex('#00ff00') Color(255) >>> Color.from_hex('#0000ff') Color(0) \"\"\" if match := cls . HEX_REGEX . match ( hex_value ): hex_value = match . group ( 1 ) if len ( hex_value ) == 3 : hex_value = \"\" . join ( c * 2 for c in hex_value ) return cls ( int ( hex_value , 16 )) raise ValueError ( f \"Invalid hex value: { hex_value } \" ) from_hsl ( h , s , l ) classmethod Creates a Color object from HSL values. Parameters: Name Type Description Default h float The hue value. required s float The saturation value. required l float The lightness value. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_hsl(0, 1, 0.5) Color(16711680) >>> Color.from_hsl(120, 1, 0.5) Color(16711680) >>> Color.from_hsl(240, 1, 0.5) Color(16711680) Source code in wyvern/colors.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 @classmethod def from_hsl ( cls , h : float , s : float , l : float ) -> Color : # noqa: E741 \"\"\" Creates a Color object from HSL values. Parameters ---------- h: float The hue value. s: float The saturation value. l: float The lightness value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsl(0, 1, 0.5) Color(16711680) >>> Color.from_hsl(120, 1, 0.5) Color(16711680) >>> Color.from_hsl(240, 1, 0.5) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hls_to_rgb ( h , l , s )]) from_hsv ( h , s , v ) classmethod Creates a Color object from HSV values. Parameters: Name Type Description Default h float The hue value. required s float The saturation value. required v float The value in HSV color space. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_hsv(0, 1, 1) Color(16711680) >>> Color.from_hsv(120, 1, 1) Color(16711680) >>> Color.from_hsv(240, 1, 1) Color(16711680) Source code in wyvern/colors.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 @classmethod def from_hsv ( cls , h : float , s : float , v : float ) -> Color : \"\"\" Creates a Color object from HSV values. Parameters ---------- h: float The hue value. s: float The saturation value. v: float The value in HSV color space. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsv(0, 1, 1) Color(16711680) >>> Color.from_hsv(120, 1, 1) Color(16711680) >>> Color.from_hsv(240, 1, 1) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hsv_to_rgb ( h , s , v )]) from_random () classmethod Creates a Color object from a random color. Randomly generates a color in the RGB color space. Returns: Type Description wyvern . Color A Color object. Source code in wyvern/colors.py 196 197 198 199 200 201 202 203 204 205 206 207 @classmethod def from_random ( cls ) -> Color : \"\"\" Creates a Color object from a random color. Randomly generates a color in the RGB color space. Returns ------- wyvern.Color A Color object. \"\"\" return cls . from_rgb ( * [ random . randint ( 0 , 255 ) for _ in range ( 3 )]) from_rgb ( r , g , b ) classmethod Creates a Color object from RGB values. Parameters: Name Type Description Default r int The red value. required g int The green value. required b int The blue value. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_rgb(255, 0, 0) Color(16711680) >>> Color.from_rgb(0, 255, 0) Color(65280) >>> Color.from_rgb(0, 0, 255) Color(255) Source code in wyvern/colors.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @classmethod def from_rgb ( cls , r : int , g : int , b : int ) -> Color : \"\"\" Creates a Color object from RGB values. Parameters ---------- r: int The red value. g: int The green value. b: int The blue value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_rgb(255, 0, 0) Color(16711680) >>> Color.from_rgb(0, 255, 0) Color(65280) >>> Color.from_rgb(0, 0, 255) Color(255) \"\"\" return cls (( r << 16 ) + ( g << 8 ) + b ) from_string ( string ) classmethod Creates a Color object from a string. Parameters: Name Type Description Default string str The string to use. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_string('rgb(255, 0, 0)') Color(16711680) >>> Color.from_string('hsl(0, 100%, 50%)') Color(-80727249750) >>> Color.from_string('hsv(0, 100%, 100%)') Color(1022371500) >>> Color.from_string('#ff0000') Color(16776960) Source code in wyvern/colors.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 @classmethod def from_string ( cls , string : str ) -> Color : \"\"\" Creates a Color object from a string. Parameters ---------- string: str The string to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_string('rgb(255, 0, 0)') Color(16711680) >>> Color.from_string('hsl(0, 100%, 50%)') Color(-80727249750) >>> Color.from_string('hsv(0, 100%, 100%)') Color(1022371500) >>> Color.from_string('#ff0000') Color(16776960) \"\"\" if string . startswith ( \"#\" ): return cls . from_hex ( string ) elif match := cls . RGB_REGEX . match ( string ): return cls . from_rgb ( * [ int ( c ) for c in match . groups ()]) elif match := cls . HSL_REGEX . match ( string ): return cls . from_hsl ( * [ float ( c ) for c in match . groups ()]) elif match := cls . HSV_REGEX . match ( string ): return cls . from_hsv ( * [ float ( c ) for c in match . groups ()]) raise ValueError ( f \"Invalid color string: { string } \" ) g () property The green value of the color. Source code in wyvern/colors.py 288 289 290 291 @property def g ( self ) -> int : \"\"\"The green value of the color.\"\"\" return self . rgb [ 1 ] gray () classmethod Creates a Color object from the gray color. This is 0x808080 . (Gray) Source code in wyvern/colors.py 338 339 340 341 @classmethod def gray ( cls ) -> Color : \"\"\"Creates a Color object from the gray color. This is `0x808080`. (Gray)\"\"\" return cls ( 0x808080 ) green () classmethod Creates a Color object from the green color. This is 0x00ff00 . (Green) Source code in wyvern/colors.py 303 304 305 306 @classmethod def green ( cls ) -> Color : \"\"\"Creates a Color object from the green color. This is `0x00ff00`. (Green)\"\"\" return cls ( 0x00FF00 ) grey () classmethod Creates a Color object from the grey color. This is 0x808080 . (Grey) Source code in wyvern/colors.py 343 344 345 346 @classmethod def grey ( cls ) -> Color : \"\"\"Creates a Color object from the grey color. This is `0x808080`. (Grey)\"\"\" return cls ( 0x808080 ) hex () property The hex value of the color. Source code in wyvern/colors.py 263 264 265 266 @property def hex ( self ) -> str : \"\"\"The hex value of the color.\"\"\" return f \"# { self . value : 06x } \" hsl () property The HSL values of the color. Source code in wyvern/colors.py 278 279 280 281 @property def hsl ( self ) -> tuple [ float , float , float ]: \"\"\"The HSL values of the color.\"\"\" return colorsys . rgb_to_hls ( * ( c / 255 for c in self . rgb )) hsv () property The HSV values of the color. Source code in wyvern/colors.py 273 274 275 276 @property def hsv ( self ) -> tuple [ float , float , float ]: \"\"\"The HSV values of the color.\"\"\" return colorsys . rgb_to_hsv ( * ( c / 255 for c in self . rgb )) magenta () classmethod Creates a Color object from the magenta color. This is 0xff00ff . (Magenta) Source code in wyvern/colors.py 323 324 325 326 @classmethod def magenta ( cls ) -> Color : \"\"\"Creates a Color object from the magenta color. This is `0xff00ff`. (Magenta)\"\"\" return cls ( 0xFF00FF ) orange () classmethod Creates a Color object from the orange color. This is 0xffa500 . (Orange) Source code in wyvern/colors.py 348 349 350 351 @classmethod def orange ( cls ) -> Color : \"\"\"Creates a Color object from the orange color. This is `0xffa500`. (Orange)\"\"\" return cls ( 0xFFA500 ) purple () classmethod Creates a Color object from the purple color. This is #800080 . (Purple) Source code in wyvern/colors.py 353 354 355 356 @classmethod def purple ( cls ) -> Color : \"\"\"Creates a Color object from the purple color. This is `#800080`. (Purple)\"\"\" return cls ( 0x800080 ) r () property The red value of the color. Source code in wyvern/colors.py 283 284 285 286 @property def r ( self ) -> int : \"\"\"The red value of the color.\"\"\" return self . rgb [ 0 ] red () classmethod Creates a Color object from the red color. This is 0xff0000 . (Red) Source code in wyvern/colors.py 298 299 300 301 @classmethod def red ( cls ) -> Color : \"\"\"Creates a Color object from the red color. This is `0xff0000`. (Red)\"\"\" return cls ( 0xFF0000 ) rgb () property The RGB values of the color. Source code in wyvern/colors.py 268 269 270 271 @property def rgb ( self ) -> tuple [ int , int , int ]: \"\"\"The RGB values of the color.\"\"\" return ( self . value >> 16 ) & 0xFF , ( self . value >> 8 ) & 0xFF , self . value & 0xFF silver () classmethod Creates a Color object from the silver color. This is #c0c0c0 . (Silver) Source code in wyvern/colors.py 363 364 365 366 @classmethod def silver ( cls ) -> Color : \"\"\"Creates a Color object from the silver color. This is `#c0c0c0`. (Silver)\"\"\" return cls ( 0xC0C0C0 ) white () classmethod Creates a Color object from the white color. This is 0xffffff . (White) Source code in wyvern/colors.py 333 334 335 336 @classmethod def white ( cls ) -> Color : \"\"\"Creates a Color object from the white color. This is `0xffffff`. (White)\"\"\" return cls ( 0xFFFFFF ) yellow () classmethod Creates a Color object from the yellow color. This is 0xffff00 . (Yellow) Source code in wyvern/colors.py 313 314 315 316 @classmethod def yellow ( cls ) -> Color : \"\"\"Creates a Color object from the yellow color. This is `0xffff00`. (Yellow)\"\"\" return cls ( 0xFFFF00 )","title":"colors"},{"location":"api_reference/colors/#wyvern.colors.Color","text":"Class representing a color in the RGB color space. Alias name Colour exists for convenience. Attributes: Name Type Description value int The value of the color. This is a 24-bit integer, where the first 8 bits are the red value, the next 8 bits are the green value, and the last 8 bits are the blue value. Source code in wyvern/colors.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 @typing . final class Color : \"\"\" Class representing a color in the RGB color space. Alias name Colour exists for convenience. Attributes ---------- value : int The value of the color. This is a 24-bit integer, where the first 8 bits are the red value, the next 8 bits are the green value, and the last 8 bits are the blue value. \"\"\" __slots__ : tuple [ str , ... ] = ( \"value\" ,) RGB_REGEX : re . Pattern [ str ] = re . compile ( r \"rgb\\((\\d{1,3}), (\\d{1,3}), (\\d{1,3})\\)\" ) HSL_REGEX : re . Pattern [ str ] = re . compile ( r \"hsl\\((\\d{1,3}), (\\d{1,3})%, (\\d{1,3})%\\)\" ) HSV_REGEX : re . Pattern [ str ] = re . compile ( r \"hsv\\((\\d{1,3}), (\\d{1,3})%, (\\d{1,3})%\\)\" ) HEX_REGEX : re . Pattern [ str ] = re . compile ( r \"#([0-9a-fA-F] {3} |[0-9a-fA-F] {6} )\" ) def __init__ ( self , value : int ) -> None : self . value = value def __repr__ ( self ) -> str : return f \"Color( { self . value } )\" def __eq__ ( self , other : object ) -> bool : return isinstance ( other , Color ) and self . value == other . value def __hash__ ( self ) -> int : return hash ( self . value ) def __ne__ ( self , other : object ) -> bool : return self is not other @classmethod def from_hex ( cls , hex_value : str ) -> Color : \"\"\" Creates a Color object from a hex value. Parameters ---------- hex_value: str The hex value to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hex('#ff0000') Color(16776960) >>> Color.from_hex('#00ff00') Color(255) >>> Color.from_hex('#0000ff') Color(0) \"\"\" if match := cls . HEX_REGEX . match ( hex_value ): hex_value = match . group ( 1 ) if len ( hex_value ) == 3 : hex_value = \"\" . join ( c * 2 for c in hex_value ) return cls ( int ( hex_value , 16 )) raise ValueError ( f \"Invalid hex value: { hex_value } \" ) @classmethod def from_rgb ( cls , r : int , g : int , b : int ) -> Color : \"\"\" Creates a Color object from RGB values. Parameters ---------- r: int The red value. g: int The green value. b: int The blue value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_rgb(255, 0, 0) Color(16711680) >>> Color.from_rgb(0, 255, 0) Color(65280) >>> Color.from_rgb(0, 0, 255) Color(255) \"\"\" return cls (( r << 16 ) + ( g << 8 ) + b ) @classmethod def from_hsv ( cls , h : float , s : float , v : float ) -> Color : \"\"\" Creates a Color object from HSV values. Parameters ---------- h: float The hue value. s: float The saturation value. v: float The value in HSV color space. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsv(0, 1, 1) Color(16711680) >>> Color.from_hsv(120, 1, 1) Color(16711680) >>> Color.from_hsv(240, 1, 1) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hsv_to_rgb ( h , s , v )]) @classmethod def from_hsl ( cls , h : float , s : float , l : float ) -> Color : # noqa: E741 \"\"\" Creates a Color object from HSL values. Parameters ---------- h: float The hue value. s: float The saturation value. l: float The lightness value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsl(0, 1, 0.5) Color(16711680) >>> Color.from_hsl(120, 1, 0.5) Color(16711680) >>> Color.from_hsl(240, 1, 0.5) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hls_to_rgb ( h , l , s )]) @classmethod def from_random ( cls ) -> Color : \"\"\" Creates a Color object from a random color. Randomly generates a color in the RGB color space. Returns ------- wyvern.Color A Color object. \"\"\" return cls . from_rgb ( * [ random . randint ( 0 , 255 ) for _ in range ( 3 )]) @classmethod def from_string ( cls , string : str ) -> Color : \"\"\" Creates a Color object from a string. Parameters ---------- string: str The string to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_string('rgb(255, 0, 0)') Color(16711680) >>> Color.from_string('hsl(0, 100%, 50%)') Color(-80727249750) >>> Color.from_string('hsv(0, 100%, 100%)') Color(1022371500) >>> Color.from_string('#ff0000') Color(16776960) \"\"\" if string . startswith ( \"#\" ): return cls . from_hex ( string ) elif match := cls . RGB_REGEX . match ( string ): return cls . from_rgb ( * [ int ( c ) for c in match . groups ()]) elif match := cls . HSL_REGEX . match ( string ): return cls . from_hsl ( * [ float ( c ) for c in match . groups ()]) elif match := cls . HSV_REGEX . match ( string ): return cls . from_hsv ( * [ float ( c ) for c in match . groups ()]) raise ValueError ( f \"Invalid color string: { string } \" ) @classmethod def default ( cls ) -> Color : \"\"\" Creates a Color object from the default color. This is `0x000000`. (Black) Examples -------- >>> Color.default() Color(0) \"\"\" return cls ( 0x000000 ) @property def hex ( self ) -> str : \"\"\"The hex value of the color.\"\"\" return f \"# { self . value : 06x } \" @property def rgb ( self ) -> tuple [ int , int , int ]: \"\"\"The RGB values of the color.\"\"\" return ( self . value >> 16 ) & 0xFF , ( self . value >> 8 ) & 0xFF , self . value & 0xFF @property def hsv ( self ) -> tuple [ float , float , float ]: \"\"\"The HSV values of the color.\"\"\" return colorsys . rgb_to_hsv ( * ( c / 255 for c in self . rgb )) @property def hsl ( self ) -> tuple [ float , float , float ]: \"\"\"The HSL values of the color.\"\"\" return colorsys . rgb_to_hls ( * ( c / 255 for c in self . rgb )) @property def r ( self ) -> int : \"\"\"The red value of the color.\"\"\" return self . rgb [ 0 ] @property def g ( self ) -> int : \"\"\"The green value of the color.\"\"\" return self . rgb [ 1 ] @property def b ( self ) -> int : \"\"\"The blue value of the color.\"\"\" return self . rgb [ 2 ] @classmethod def red ( cls ) -> Color : \"\"\"Creates a Color object from the red color. This is `0xff0000`. (Red)\"\"\" return cls ( 0xFF0000 ) @classmethod def green ( cls ) -> Color : \"\"\"Creates a Color object from the green color. This is `0x00ff00`. (Green)\"\"\" return cls ( 0x00FF00 ) @classmethod def blue ( cls ) -> Color : \"\"\"Creates a Color object from the blue color. This is `0x0000ff`. (Blue)\"\"\" return cls ( 0x0000FF ) @classmethod def yellow ( cls ) -> Color : \"\"\"Creates a Color object from the yellow color. This is `0xffff00`. (Yellow)\"\"\" return cls ( 0xFFFF00 ) @classmethod def cyan ( cls ) -> Color : \"\"\"Creates a Color object from the cyan color. This is `0x00ffff`. (Cyan)\"\"\" return cls ( 0x00FFFF ) @classmethod def magenta ( cls ) -> Color : \"\"\"Creates a Color object from the magenta color. This is `0xff00ff`. (Magenta)\"\"\" return cls ( 0xFF00FF ) @classmethod def black ( cls ) -> Color : \"\"\"Creates a Color object from the black color. This is `0x000000`. (Black)\"\"\" return cls ( 0x000000 ) @classmethod def white ( cls ) -> Color : \"\"\"Creates a Color object from the white color. This is `0xffffff`. (White)\"\"\" return cls ( 0xFFFFFF ) @classmethod def gray ( cls ) -> Color : \"\"\"Creates a Color object from the gray color. This is `0x808080`. (Gray)\"\"\" return cls ( 0x808080 ) @classmethod def grey ( cls ) -> Color : \"\"\"Creates a Color object from the grey color. This is `0x808080`. (Grey)\"\"\" return cls ( 0x808080 ) @classmethod def orange ( cls ) -> Color : \"\"\"Creates a Color object from the orange color. This is `0xffa500`. (Orange)\"\"\" return cls ( 0xFFA500 ) @classmethod def purple ( cls ) -> Color : \"\"\"Creates a Color object from the purple color. This is `#800080`. (Purple)\"\"\" return cls ( 0x800080 ) @classmethod def brown ( cls ) -> Color : \"\"\"Creates a Color object from the brown color. This is `#a52a2a`. (Brown)\"\"\" return cls ( 0xA52A2A ) @classmethod def silver ( cls ) -> Color : \"\"\"Creates a Color object from the silver color. This is `#c0c0c0`. (Silver)\"\"\" return cls ( 0xC0C0C0 ) @classmethod def aqua ( cls ) -> Color : \"\"\"Creates a Color object from the aqua color. This is `#00ffff`. (Aqua)\"\"\" return cls ( 0x00FFFF )","title":"Color"},{"location":"api_reference/colors/#wyvern.colors.Color.aqua","text":"Creates a Color object from the aqua color. This is #00ffff . (Aqua) Source code in wyvern/colors.py 368 369 370 371 @classmethod def aqua ( cls ) -> Color : \"\"\"Creates a Color object from the aqua color. This is `#00ffff`. (Aqua)\"\"\" return cls ( 0x00FFFF )","title":"aqua()"},{"location":"api_reference/colors/#wyvern.colors.Color.b","text":"The blue value of the color. Source code in wyvern/colors.py 293 294 295 296 @property def b ( self ) -> int : \"\"\"The blue value of the color.\"\"\" return self . rgb [ 2 ]","title":"b()"},{"location":"api_reference/colors/#wyvern.colors.Color.black","text":"Creates a Color object from the black color. This is 0x000000 . (Black) Source code in wyvern/colors.py 328 329 330 331 @classmethod def black ( cls ) -> Color : \"\"\"Creates a Color object from the black color. This is `0x000000`. (Black)\"\"\" return cls ( 0x000000 )","title":"black()"},{"location":"api_reference/colors/#wyvern.colors.Color.blue","text":"Creates a Color object from the blue color. This is 0x0000ff . (Blue) Source code in wyvern/colors.py 308 309 310 311 @classmethod def blue ( cls ) -> Color : \"\"\"Creates a Color object from the blue color. This is `0x0000ff`. (Blue)\"\"\" return cls ( 0x0000FF )","title":"blue()"},{"location":"api_reference/colors/#wyvern.colors.Color.brown","text":"Creates a Color object from the brown color. This is #a52a2a . (Brown) Source code in wyvern/colors.py 358 359 360 361 @classmethod def brown ( cls ) -> Color : \"\"\"Creates a Color object from the brown color. This is `#a52a2a`. (Brown)\"\"\" return cls ( 0xA52A2A )","title":"brown()"},{"location":"api_reference/colors/#wyvern.colors.Color.cyan","text":"Creates a Color object from the cyan color. This is 0x00ffff . (Cyan) Source code in wyvern/colors.py 318 319 320 321 @classmethod def cyan ( cls ) -> Color : \"\"\"Creates a Color object from the cyan color. This is `0x00ffff`. (Cyan)\"\"\" return cls ( 0x00FFFF )","title":"cyan()"},{"location":"api_reference/colors/#wyvern.colors.Color.default","text":"Creates a Color object from the default color. This is 0x000000 . (Black) Examples: >>> Color.default() Color(0) Source code in wyvern/colors.py 249 250 251 252 253 254 255 256 257 258 259 260 261 @classmethod def default ( cls ) -> Color : \"\"\" Creates a Color object from the default color. This is `0x000000`. (Black) Examples -------- >>> Color.default() Color(0) \"\"\" return cls ( 0x000000 )","title":"default()"},{"location":"api_reference/colors/#wyvern.colors.Color.from_hex","text":"Creates a Color object from a hex value. Parameters: Name Type Description Default hex_value str The hex value to use. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_hex('#ff0000') Color(16776960) >>> Color.from_hex('#00ff00') Color(255) >>> Color.from_hex('#0000ff') Color(0) Source code in wyvern/colors.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @classmethod def from_hex ( cls , hex_value : str ) -> Color : \"\"\" Creates a Color object from a hex value. Parameters ---------- hex_value: str The hex value to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hex('#ff0000') Color(16776960) >>> Color.from_hex('#00ff00') Color(255) >>> Color.from_hex('#0000ff') Color(0) \"\"\" if match := cls . HEX_REGEX . match ( hex_value ): hex_value = match . group ( 1 ) if len ( hex_value ) == 3 : hex_value = \"\" . join ( c * 2 for c in hex_value ) return cls ( int ( hex_value , 16 )) raise ValueError ( f \"Invalid hex value: { hex_value } \" )","title":"from_hex()"},{"location":"api_reference/colors/#wyvern.colors.Color.from_hsl","text":"Creates a Color object from HSL values. Parameters: Name Type Description Default h float The hue value. required s float The saturation value. required l float The lightness value. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_hsl(0, 1, 0.5) Color(16711680) >>> Color.from_hsl(120, 1, 0.5) Color(16711680) >>> Color.from_hsl(240, 1, 0.5) Color(16711680) Source code in wyvern/colors.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 @classmethod def from_hsl ( cls , h : float , s : float , l : float ) -> Color : # noqa: E741 \"\"\" Creates a Color object from HSL values. Parameters ---------- h: float The hue value. s: float The saturation value. l: float The lightness value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsl(0, 1, 0.5) Color(16711680) >>> Color.from_hsl(120, 1, 0.5) Color(16711680) >>> Color.from_hsl(240, 1, 0.5) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hls_to_rgb ( h , l , s )])","title":"from_hsl()"},{"location":"api_reference/colors/#wyvern.colors.Color.from_hsv","text":"Creates a Color object from HSV values. Parameters: Name Type Description Default h float The hue value. required s float The saturation value. required v float The value in HSV color space. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_hsv(0, 1, 1) Color(16711680) >>> Color.from_hsv(120, 1, 1) Color(16711680) >>> Color.from_hsv(240, 1, 1) Color(16711680) Source code in wyvern/colors.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 @classmethod def from_hsv ( cls , h : float , s : float , v : float ) -> Color : \"\"\" Creates a Color object from HSV values. Parameters ---------- h: float The hue value. s: float The saturation value. v: float The value in HSV color space. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_hsv(0, 1, 1) Color(16711680) >>> Color.from_hsv(120, 1, 1) Color(16711680) >>> Color.from_hsv(240, 1, 1) Color(16711680) \"\"\" return cls . from_rgb ( * [ int ( round ( c * 255 )) for c in colorsys . hsv_to_rgb ( h , s , v )])","title":"from_hsv()"},{"location":"api_reference/colors/#wyvern.colors.Color.from_random","text":"Creates a Color object from a random color. Randomly generates a color in the RGB color space. Returns: Type Description wyvern . Color A Color object. Source code in wyvern/colors.py 196 197 198 199 200 201 202 203 204 205 206 207 @classmethod def from_random ( cls ) -> Color : \"\"\" Creates a Color object from a random color. Randomly generates a color in the RGB color space. Returns ------- wyvern.Color A Color object. \"\"\" return cls . from_rgb ( * [ random . randint ( 0 , 255 ) for _ in range ( 3 )])","title":"from_random()"},{"location":"api_reference/colors/#wyvern.colors.Color.from_rgb","text":"Creates a Color object from RGB values. Parameters: Name Type Description Default r int The red value. required g int The green value. required b int The blue value. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_rgb(255, 0, 0) Color(16711680) >>> Color.from_rgb(0, 255, 0) Color(65280) >>> Color.from_rgb(0, 0, 255) Color(255) Source code in wyvern/colors.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 @classmethod def from_rgb ( cls , r : int , g : int , b : int ) -> Color : \"\"\" Creates a Color object from RGB values. Parameters ---------- r: int The red value. g: int The green value. b: int The blue value. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_rgb(255, 0, 0) Color(16711680) >>> Color.from_rgb(0, 255, 0) Color(65280) >>> Color.from_rgb(0, 0, 255) Color(255) \"\"\" return cls (( r << 16 ) + ( g << 8 ) + b )","title":"from_rgb()"},{"location":"api_reference/colors/#wyvern.colors.Color.from_string","text":"Creates a Color object from a string. Parameters: Name Type Description Default string str The string to use. required Returns: Type Description wyvern . Color A Color object. Examples: >>> Color.from_string('rgb(255, 0, 0)') Color(16711680) >>> Color.from_string('hsl(0, 100%, 50%)') Color(-80727249750) >>> Color.from_string('hsv(0, 100%, 100%)') Color(1022371500) >>> Color.from_string('#ff0000') Color(16776960) Source code in wyvern/colors.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 @classmethod def from_string ( cls , string : str ) -> Color : \"\"\" Creates a Color object from a string. Parameters ---------- string: str The string to use. Returns ------- wyvern.Color A Color object. Examples -------- >>> Color.from_string('rgb(255, 0, 0)') Color(16711680) >>> Color.from_string('hsl(0, 100%, 50%)') Color(-80727249750) >>> Color.from_string('hsv(0, 100%, 100%)') Color(1022371500) >>> Color.from_string('#ff0000') Color(16776960) \"\"\" if string . startswith ( \"#\" ): return cls . from_hex ( string ) elif match := cls . RGB_REGEX . match ( string ): return cls . from_rgb ( * [ int ( c ) for c in match . groups ()]) elif match := cls . HSL_REGEX . match ( string ): return cls . from_hsl ( * [ float ( c ) for c in match . groups ()]) elif match := cls . HSV_REGEX . match ( string ): return cls . from_hsv ( * [ float ( c ) for c in match . groups ()]) raise ValueError ( f \"Invalid color string: { string } \" )","title":"from_string()"},{"location":"api_reference/colors/#wyvern.colors.Color.g","text":"The green value of the color. Source code in wyvern/colors.py 288 289 290 291 @property def g ( self ) -> int : \"\"\"The green value of the color.\"\"\" return self . rgb [ 1 ]","title":"g()"},{"location":"api_reference/colors/#wyvern.colors.Color.gray","text":"Creates a Color object from the gray color. This is 0x808080 . (Gray) Source code in wyvern/colors.py 338 339 340 341 @classmethod def gray ( cls ) -> Color : \"\"\"Creates a Color object from the gray color. This is `0x808080`. (Gray)\"\"\" return cls ( 0x808080 )","title":"gray()"},{"location":"api_reference/colors/#wyvern.colors.Color.green","text":"Creates a Color object from the green color. This is 0x00ff00 . (Green) Source code in wyvern/colors.py 303 304 305 306 @classmethod def green ( cls ) -> Color : \"\"\"Creates a Color object from the green color. This is `0x00ff00`. (Green)\"\"\" return cls ( 0x00FF00 )","title":"green()"},{"location":"api_reference/colors/#wyvern.colors.Color.grey","text":"Creates a Color object from the grey color. This is 0x808080 . (Grey) Source code in wyvern/colors.py 343 344 345 346 @classmethod def grey ( cls ) -> Color : \"\"\"Creates a Color object from the grey color. This is `0x808080`. (Grey)\"\"\" return cls ( 0x808080 )","title":"grey()"},{"location":"api_reference/colors/#wyvern.colors.Color.hex","text":"The hex value of the color. Source code in wyvern/colors.py 263 264 265 266 @property def hex ( self ) -> str : \"\"\"The hex value of the color.\"\"\" return f \"# { self . value : 06x } \"","title":"hex()"},{"location":"api_reference/colors/#wyvern.colors.Color.hsl","text":"The HSL values of the color. Source code in wyvern/colors.py 278 279 280 281 @property def hsl ( self ) -> tuple [ float , float , float ]: \"\"\"The HSL values of the color.\"\"\" return colorsys . rgb_to_hls ( * ( c / 255 for c in self . rgb ))","title":"hsl()"},{"location":"api_reference/colors/#wyvern.colors.Color.hsv","text":"The HSV values of the color. Source code in wyvern/colors.py 273 274 275 276 @property def hsv ( self ) -> tuple [ float , float , float ]: \"\"\"The HSV values of the color.\"\"\" return colorsys . rgb_to_hsv ( * ( c / 255 for c in self . rgb ))","title":"hsv()"},{"location":"api_reference/colors/#wyvern.colors.Color.magenta","text":"Creates a Color object from the magenta color. This is 0xff00ff . (Magenta) Source code in wyvern/colors.py 323 324 325 326 @classmethod def magenta ( cls ) -> Color : \"\"\"Creates a Color object from the magenta color. This is `0xff00ff`. (Magenta)\"\"\" return cls ( 0xFF00FF )","title":"magenta()"},{"location":"api_reference/colors/#wyvern.colors.Color.orange","text":"Creates a Color object from the orange color. This is 0xffa500 . (Orange) Source code in wyvern/colors.py 348 349 350 351 @classmethod def orange ( cls ) -> Color : \"\"\"Creates a Color object from the orange color. This is `0xffa500`. (Orange)\"\"\" return cls ( 0xFFA500 )","title":"orange()"},{"location":"api_reference/colors/#wyvern.colors.Color.purple","text":"Creates a Color object from the purple color. This is #800080 . (Purple) Source code in wyvern/colors.py 353 354 355 356 @classmethod def purple ( cls ) -> Color : \"\"\"Creates a Color object from the purple color. This is `#800080`. (Purple)\"\"\" return cls ( 0x800080 )","title":"purple()"},{"location":"api_reference/colors/#wyvern.colors.Color.r","text":"The red value of the color. Source code in wyvern/colors.py 283 284 285 286 @property def r ( self ) -> int : \"\"\"The red value of the color.\"\"\" return self . rgb [ 0 ]","title":"r()"},{"location":"api_reference/colors/#wyvern.colors.Color.red","text":"Creates a Color object from the red color. This is 0xff0000 . (Red) Source code in wyvern/colors.py 298 299 300 301 @classmethod def red ( cls ) -> Color : \"\"\"Creates a Color object from the red color. This is `0xff0000`. (Red)\"\"\" return cls ( 0xFF0000 )","title":"red()"},{"location":"api_reference/colors/#wyvern.colors.Color.rgb","text":"The RGB values of the color. Source code in wyvern/colors.py 268 269 270 271 @property def rgb ( self ) -> tuple [ int , int , int ]: \"\"\"The RGB values of the color.\"\"\" return ( self . value >> 16 ) & 0xFF , ( self . value >> 8 ) & 0xFF , self . value & 0xFF","title":"rgb()"},{"location":"api_reference/colors/#wyvern.colors.Color.silver","text":"Creates a Color object from the silver color. This is #c0c0c0 . (Silver) Source code in wyvern/colors.py 363 364 365 366 @classmethod def silver ( cls ) -> Color : \"\"\"Creates a Color object from the silver color. This is `#c0c0c0`. (Silver)\"\"\" return cls ( 0xC0C0C0 )","title":"silver()"},{"location":"api_reference/colors/#wyvern.colors.Color.white","text":"Creates a Color object from the white color. This is 0xffffff . (White) Source code in wyvern/colors.py 333 334 335 336 @classmethod def white ( cls ) -> Color : \"\"\"Creates a Color object from the white color. This is `0xffffff`. (White)\"\"\" return cls ( 0xFFFFFF )","title":"white()"},{"location":"api_reference/colors/#wyvern.colors.Color.yellow","text":"Creates a Color object from the yellow color. This is 0xffff00 . (Yellow) Source code in wyvern/colors.py 313 314 315 316 @classmethod def yellow ( cls ) -> Color : \"\"\"Creates a Color object from the yellow color. This is `0xffff00`. (Yellow)\"\"\" return cls ( 0xFFFF00 )","title":"yellow()"},{"location":"api_reference/events/","text":"Events Event Bases: enum . Enum Event Enums. Source code in wyvern/events.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @typing . final class Event ( enum . Enum ): \"\"\"Event Enums.\"\"\" READY = \"READY\" MESSAGE_CREATE = \"MESSAGE_CREATE\" \"\"\"Triggered when a message is created. Arguments provided: * message ([wyvern.Message][]) \"\"\" INTERACTION_CREATE = \"INTERACTION_CREATE\" \"\"\"Triggered when an interaction is created. Arguments provided: * interaction ([wyvern.Interaction]) !!! note The interaction argument can be any derivative of interaction!. \"\"\" GUILD_CREATE = \"GUILD_CREATE\" # Library Events STARTING = \"STARTING\" \"\"\"Triggered when bot is loaded and is starting. Note: This event gets triggerd once in a runtime. Arguments provided: * client ([wyvern.GatewayClient][])\"\"\" STARTED = \"STARTED\" \"\"\"Triggered when the bot has successfully verified its token and is running. Arguments provided: * client ([wyvern.GatewayClient][])\"\"\" GATEWAY_CONNECTED = \"GATEWAY_CONNECTED\" \"\"\"Triggered when the gateway initalises a connection. Arguments provided: * client ([wyvern.GatewayClient][])\"\"\" GATEWAY_CONNECTED = 'GATEWAY_CONNECTED' class-attribute Triggered when the gateway initalises a connection. Arguments provided: client ( wyvern.GatewayClient ) INTERACTION_CREATE = 'INTERACTION_CREATE' class-attribute Triggered when an interaction is created. Arguments provided: interaction ([wyvern.Interaction]) Note The interaction argument can be any derivative of interaction!. MESSAGE_CREATE = 'MESSAGE_CREATE' class-attribute Triggered when a message is created. Arguments provided: message ( wyvern.Message ) STARTED = 'STARTED' class-attribute Triggered when the bot has successfully verified its token and is running. Arguments provided: client ( wyvern.GatewayClient ) STARTING = 'STARTING' class-attribute Triggered when bot is loaded and is starting. Note: This event gets triggerd once in a runtime. Arguments provided: client ( wyvern.GatewayClient ) EventHandler Bases: _InClassEventContainer Event handler to deal with incoming events from the Gateway. Parameters: Name Type Description Default client wyvern . clients . GatewayClient The client binded with the event handler. required Attributes: Name Type Description listeners dict [ str | [ wyvern . events . Event ], list [ wyvern . events . EventListener ]] A container for event listeners. Source code in wyvern/events.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class EventHandler ( _InClassEventContainer ): \"\"\" Event handler to deal with incoming events from the Gateway. Parameters ---------- client : wyvern.clients.GatewayClient The client binded with the event handler. Attributes ---------- listeners: dict[str | [wyvern.events.Event], list[wyvern.events.EventListener]] A container for event listeners. \"\"\" listeners : dict [ Event , list [ EventListener ]] = {} __identity__ : str = \"event_handler_class\" # this is meant for callback signature verification, don't override. def __init__ ( self , client : \"GatewayClient\" ) -> None : self . client = client def setup_listeners ( self ) -> None : [[ self . add_listener ( listener ) for listener in listeners ] for listeners in self . __internal_listeners__ . values ()] def add_listener ( self , event_listener : EventListener ) -> EventListener : \"\"\"Adds a listener to the handler. Parameters ---------- event_listener: wyvern.events.EventListener The listener to be added. \"\"\" self . listeners . setdefault ( event_listener . event_type , []) . append ( event_listener ) event_listener . event_handler = self return event_listener def dispatch ( self , event : Event , * args : typing . Any ) -> None : \"\"\"Dispatches events from the gateway. This method runs all the listeners registered in the container for the specific event. Parameters ---------- event: wyvern.events.Event Name of the event to be dispatched. *args: tuple[typing.Any, ...] Arguments to provide in callbacks. \"\"\" self . client . _logger . debug ( f \"Dispatching { event } event.\" ) invokes = [ lsnr ( * args ) for lsnr in self . listeners . get ( event , []) if lsnr . max_trigger > lsnr . trigger_count ] asyncio . gather ( * invokes ) add_listener ( event_listener ) Adds a listener to the handler. Parameters: Name Type Description Default event_listener EventListener The listener to be added. required Source code in wyvern/events.py 218 219 220 221 222 223 224 225 226 227 228 def add_listener ( self , event_listener : EventListener ) -> EventListener : \"\"\"Adds a listener to the handler. Parameters ---------- event_listener: wyvern.events.EventListener The listener to be added. \"\"\" self . listeners . setdefault ( event_listener . event_type , []) . append ( event_listener ) event_listener . event_handler = self return event_listener dispatch ( event , * args ) Dispatches events from the gateway. This method runs all the listeners registered in the container for the specific event. Parameters: Name Type Description Default event Event Name of the event to be dispatched. required *args typing . Any Arguments to provide in callbacks. () Source code in wyvern/events.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def dispatch ( self , event : Event , * args : typing . Any ) -> None : \"\"\"Dispatches events from the gateway. This method runs all the listeners registered in the container for the specific event. Parameters ---------- event: wyvern.events.Event Name of the event to be dispatched. *args: tuple[typing.Any, ...] Arguments to provide in callbacks. \"\"\" self . client . _logger . debug ( f \"Dispatching { event } event.\" ) invokes = [ lsnr ( * args ) for lsnr in self . listeners . get ( event , []) if lsnr . max_trigger > lsnr . trigger_count ] asyncio . gather ( * invokes ) EventListener Class representating a callable to be called when a specific event type is dispatched. Parameters: Name Type Description Default event_type str | wyvern . events . Event The type of event this listener belongs to. required callback typing . Callable [..., typing . Awaitable [ typing . Any ]] The coroutine to run when event is dispatched required max_trigger int | float Max amount of time this listener will be triggered. required checks Checks added to the event listener. required Attributes: Name Type Description trigger_count int Number of times this listener has been triggered Source code in wyvern/events.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 @typing . final @attrs . define class EventListener : \"\"\"Class representating a callable to be called when a specific event type is dispatched. Parameters ---------- event_type : str | wyvern.events.Event The type of event this listener belongs to. callback : typing.Callable[..., typing.Awaitable[typing.Any]] The coroutine to run when event is dispatched max_trigger : int | float Max amount of time this listener will be triggered. checks: list[wyvern._types.CheckT] Checks added to the event listener. Attributes ---------- trigger_count: int Number of times this listener has been triggered \"\"\" __parent_identity__ : str = attrs . field ( init = False , default = \"-\" ) event_type : Event callback : AnyCallableT max_trigger : int | float trigger_count : int = 0 event_handler : EventHandler | None = None checks : list [ CheckT ] = attrs . field ( init = False , default = []) def check ( self , predicate : CheckT ) -> CheckT : \"\"\"Adds an check to the listener. The check callback accepts the same arguments as the related event. The predicate should return a bool ( strict to True or False ). Example import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def msg_create(msg: wyvern.Message) -> None: await msg.respond(\"This message was created when the check passed.\") @msg_create.check async def msg_create_check(msg: wyvern.Message) -> bool: return msg.author.id == 1234567890123456789 client.run() \"\"\" def inner () -> CheckT : nonlocal predicate if not get_arg_count ( predicate ) == get_arg_count ( self . callback ): raise TypeError ( \"EventListener and check callbacks should accept same number of arguments.\" ) self . checks . append ( predicate ) return predicate return inner () async def process_checks ( self , * args : typing . Any ) -> bool : assert self . event_handler results = [ await check ( * args ) for check in self . checks ] if any ( faulty_checks := [ results . index ( result ) for result in results if result not in ( True , False )]): self . event_handler . client . _logger . warning ( \"Got non-bool return values from checks in %s : %s \" , self . __call__ . __name__ , \", \" . join ( map ( lambda c : self . checks [ c ] . __name__ , faulty_checks )), ) return all ( results ) async def __call__ ( self , * args : typing . Any ) -> None : if ( await self . process_checks ( * args )) is False : return assert ( handler := self . event_handler ) is not None finalargs : tuple [ typing . Any , ... ] = tuple () if self . __parent_identity__ == \"-\" : finalargs = args elif self . __parent_identity__ == \"bot_class\" : finalargs = ( handler . client ,) + args elif self . __parent_identity__ == \"event_handler_class\" : finalargs = ( handler ,) + args self . trigger_count += 1 await self . callback ( * finalargs ) check ( predicate ) Adds an check to the listener. The check callback accepts the same arguments as the related event. The predicate should return a bool ( strict to True or False ). Example import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def msg_create(msg: wyvern.Message) -> None: await msg.respond(\"This message was created when the check passed.\") @msg_create.check async def msg_create_check(msg: wyvern.Message) -> bool: return msg.author.id == 1234567890123456789 client.run() Source code in wyvern/events.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def check ( self , predicate : CheckT ) -> CheckT : \"\"\"Adds an check to the listener. The check callback accepts the same arguments as the related event. The predicate should return a bool ( strict to True or False ). Example import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def msg_create(msg: wyvern.Message) -> None: await msg.respond(\"This message was created when the check passed.\") @msg_create.check async def msg_create_check(msg: wyvern.Message) -> bool: return msg.author.id == 1234567890123456789 client.run() \"\"\" def inner () -> CheckT : nonlocal predicate if not get_arg_count ( predicate ) == get_arg_count ( self . callback ): raise TypeError ( \"EventListener and check callbacks should accept same number of arguments.\" ) self . checks . append ( predicate ) return predicate return inner () as_listener ( event , * , max_trigger = float ( 'inf' )) Creates a wyvern.events.EventListener object. Parameters: Name Type Description Default event Event The event to listen. required max_trigger int | float Maximum number of times this listener has to be triggered. float('inf') Returns: Type Description wyvern . events . EventListener A EventListener object. Source code in wyvern/events.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def as_listener ( event : Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], EventListener ]: \"\"\"Creates a [wyvern.events.EventListener][] object. Parameters ---------- event: wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> EventListener : nonlocal event , max_trigger return EventListener ( event , callback , max_trigger , 0 ) return inner","title":"events"},{"location":"api_reference/events/#events","text":"","title":"Events"},{"location":"api_reference/events/#wyvern.events.Event","text":"Bases: enum . Enum Event Enums. Source code in wyvern/events.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 @typing . final class Event ( enum . Enum ): \"\"\"Event Enums.\"\"\" READY = \"READY\" MESSAGE_CREATE = \"MESSAGE_CREATE\" \"\"\"Triggered when a message is created. Arguments provided: * message ([wyvern.Message][]) \"\"\" INTERACTION_CREATE = \"INTERACTION_CREATE\" \"\"\"Triggered when an interaction is created. Arguments provided: * interaction ([wyvern.Interaction]) !!! note The interaction argument can be any derivative of interaction!. \"\"\" GUILD_CREATE = \"GUILD_CREATE\" # Library Events STARTING = \"STARTING\" \"\"\"Triggered when bot is loaded and is starting. Note: This event gets triggerd once in a runtime. Arguments provided: * client ([wyvern.GatewayClient][])\"\"\" STARTED = \"STARTED\" \"\"\"Triggered when the bot has successfully verified its token and is running. Arguments provided: * client ([wyvern.GatewayClient][])\"\"\" GATEWAY_CONNECTED = \"GATEWAY_CONNECTED\" \"\"\"Triggered when the gateway initalises a connection. Arguments provided: * client ([wyvern.GatewayClient][])\"\"\"","title":"Event"},{"location":"api_reference/events/#wyvern.events.Event.GATEWAY_CONNECTED","text":"Triggered when the gateway initalises a connection. Arguments provided: client ( wyvern.GatewayClient )","title":"GATEWAY_CONNECTED"},{"location":"api_reference/events/#wyvern.events.Event.INTERACTION_CREATE","text":"Triggered when an interaction is created. Arguments provided: interaction ([wyvern.Interaction]) Note The interaction argument can be any derivative of interaction!.","title":"INTERACTION_CREATE"},{"location":"api_reference/events/#wyvern.events.Event.MESSAGE_CREATE","text":"Triggered when a message is created. Arguments provided: message ( wyvern.Message )","title":"MESSAGE_CREATE"},{"location":"api_reference/events/#wyvern.events.Event.STARTED","text":"Triggered when the bot has successfully verified its token and is running. Arguments provided: client ( wyvern.GatewayClient )","title":"STARTED"},{"location":"api_reference/events/#wyvern.events.Event.STARTING","text":"Triggered when bot is loaded and is starting. Note: This event gets triggerd once in a runtime. Arguments provided: client ( wyvern.GatewayClient )","title":"STARTING"},{"location":"api_reference/events/#wyvern.events.EventHandler","text":"Bases: _InClassEventContainer Event handler to deal with incoming events from the Gateway. Parameters: Name Type Description Default client wyvern . clients . GatewayClient The client binded with the event handler. required Attributes: Name Type Description listeners dict [ str | [ wyvern . events . Event ], list [ wyvern . events . EventListener ]] A container for event listeners. Source code in wyvern/events.py 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class EventHandler ( _InClassEventContainer ): \"\"\" Event handler to deal with incoming events from the Gateway. Parameters ---------- client : wyvern.clients.GatewayClient The client binded with the event handler. Attributes ---------- listeners: dict[str | [wyvern.events.Event], list[wyvern.events.EventListener]] A container for event listeners. \"\"\" listeners : dict [ Event , list [ EventListener ]] = {} __identity__ : str = \"event_handler_class\" # this is meant for callback signature verification, don't override. def __init__ ( self , client : \"GatewayClient\" ) -> None : self . client = client def setup_listeners ( self ) -> None : [[ self . add_listener ( listener ) for listener in listeners ] for listeners in self . __internal_listeners__ . values ()] def add_listener ( self , event_listener : EventListener ) -> EventListener : \"\"\"Adds a listener to the handler. Parameters ---------- event_listener: wyvern.events.EventListener The listener to be added. \"\"\" self . listeners . setdefault ( event_listener . event_type , []) . append ( event_listener ) event_listener . event_handler = self return event_listener def dispatch ( self , event : Event , * args : typing . Any ) -> None : \"\"\"Dispatches events from the gateway. This method runs all the listeners registered in the container for the specific event. Parameters ---------- event: wyvern.events.Event Name of the event to be dispatched. *args: tuple[typing.Any, ...] Arguments to provide in callbacks. \"\"\" self . client . _logger . debug ( f \"Dispatching { event } event.\" ) invokes = [ lsnr ( * args ) for lsnr in self . listeners . get ( event , []) if lsnr . max_trigger > lsnr . trigger_count ] asyncio . gather ( * invokes )","title":"EventHandler"},{"location":"api_reference/events/#wyvern.events.EventHandler.add_listener","text":"Adds a listener to the handler. Parameters: Name Type Description Default event_listener EventListener The listener to be added. required Source code in wyvern/events.py 218 219 220 221 222 223 224 225 226 227 228 def add_listener ( self , event_listener : EventListener ) -> EventListener : \"\"\"Adds a listener to the handler. Parameters ---------- event_listener: wyvern.events.EventListener The listener to be added. \"\"\" self . listeners . setdefault ( event_listener . event_type , []) . append ( event_listener ) event_listener . event_handler = self return event_listener","title":"add_listener()"},{"location":"api_reference/events/#wyvern.events.EventHandler.dispatch","text":"Dispatches events from the gateway. This method runs all the listeners registered in the container for the specific event. Parameters: Name Type Description Default event Event Name of the event to be dispatched. required *args typing . Any Arguments to provide in callbacks. () Source code in wyvern/events.py 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 def dispatch ( self , event : Event , * args : typing . Any ) -> None : \"\"\"Dispatches events from the gateway. This method runs all the listeners registered in the container for the specific event. Parameters ---------- event: wyvern.events.Event Name of the event to be dispatched. *args: tuple[typing.Any, ...] Arguments to provide in callbacks. \"\"\" self . client . _logger . debug ( f \"Dispatching { event } event.\" ) invokes = [ lsnr ( * args ) for lsnr in self . listeners . get ( event , []) if lsnr . max_trigger > lsnr . trigger_count ] asyncio . gather ( * invokes )","title":"dispatch()"},{"location":"api_reference/events/#wyvern.events.EventListener","text":"Class representating a callable to be called when a specific event type is dispatched. Parameters: Name Type Description Default event_type str | wyvern . events . Event The type of event this listener belongs to. required callback typing . Callable [..., typing . Awaitable [ typing . Any ]] The coroutine to run when event is dispatched required max_trigger int | float Max amount of time this listener will be triggered. required checks Checks added to the event listener. required Attributes: Name Type Description trigger_count int Number of times this listener has been triggered Source code in wyvern/events.py 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 @typing . final @attrs . define class EventListener : \"\"\"Class representating a callable to be called when a specific event type is dispatched. Parameters ---------- event_type : str | wyvern.events.Event The type of event this listener belongs to. callback : typing.Callable[..., typing.Awaitable[typing.Any]] The coroutine to run when event is dispatched max_trigger : int | float Max amount of time this listener will be triggered. checks: list[wyvern._types.CheckT] Checks added to the event listener. Attributes ---------- trigger_count: int Number of times this listener has been triggered \"\"\" __parent_identity__ : str = attrs . field ( init = False , default = \"-\" ) event_type : Event callback : AnyCallableT max_trigger : int | float trigger_count : int = 0 event_handler : EventHandler | None = None checks : list [ CheckT ] = attrs . field ( init = False , default = []) def check ( self , predicate : CheckT ) -> CheckT : \"\"\"Adds an check to the listener. The check callback accepts the same arguments as the related event. The predicate should return a bool ( strict to True or False ). Example import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def msg_create(msg: wyvern.Message) -> None: await msg.respond(\"This message was created when the check passed.\") @msg_create.check async def msg_create_check(msg: wyvern.Message) -> bool: return msg.author.id == 1234567890123456789 client.run() \"\"\" def inner () -> CheckT : nonlocal predicate if not get_arg_count ( predicate ) == get_arg_count ( self . callback ): raise TypeError ( \"EventListener and check callbacks should accept same number of arguments.\" ) self . checks . append ( predicate ) return predicate return inner () async def process_checks ( self , * args : typing . Any ) -> bool : assert self . event_handler results = [ await check ( * args ) for check in self . checks ] if any ( faulty_checks := [ results . index ( result ) for result in results if result not in ( True , False )]): self . event_handler . client . _logger . warning ( \"Got non-bool return values from checks in %s : %s \" , self . __call__ . __name__ , \", \" . join ( map ( lambda c : self . checks [ c ] . __name__ , faulty_checks )), ) return all ( results ) async def __call__ ( self , * args : typing . Any ) -> None : if ( await self . process_checks ( * args )) is False : return assert ( handler := self . event_handler ) is not None finalargs : tuple [ typing . Any , ... ] = tuple () if self . __parent_identity__ == \"-\" : finalargs = args elif self . __parent_identity__ == \"bot_class\" : finalargs = ( handler . client ,) + args elif self . __parent_identity__ == \"event_handler_class\" : finalargs = ( handler ,) + args self . trigger_count += 1 await self . callback ( * finalargs )","title":"EventListener"},{"location":"api_reference/events/#wyvern.events.EventListener.check","text":"Adds an check to the listener. The check callback accepts the same arguments as the related event. The predicate should return a bool ( strict to True or False ). Example import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def msg_create(msg: wyvern.Message) -> None: await msg.respond(\"This message was created when the check passed.\") @msg_create.check async def msg_create_check(msg: wyvern.Message) -> bool: return msg.author.id == 1234567890123456789 client.run() Source code in wyvern/events.py 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def check ( self , predicate : CheckT ) -> CheckT : \"\"\"Adds an check to the listener. The check callback accepts the same arguments as the related event. The predicate should return a bool ( strict to True or False ). Example import wyvern client = wyvern.GatewayClient(\"TOKEN\") @client.with_listener(wyvern.Event.MESSAGE_CREATE) async def msg_create(msg: wyvern.Message) -> None: await msg.respond(\"This message was created when the check passed.\") @msg_create.check async def msg_create_check(msg: wyvern.Message) -> bool: return msg.author.id == 1234567890123456789 client.run() \"\"\" def inner () -> CheckT : nonlocal predicate if not get_arg_count ( predicate ) == get_arg_count ( self . callback ): raise TypeError ( \"EventListener and check callbacks should accept same number of arguments.\" ) self . checks . append ( predicate ) return predicate return inner ()","title":"check()"},{"location":"api_reference/events/#wyvern.events.as_listener","text":"Creates a wyvern.events.EventListener object. Parameters: Name Type Description Default event Event The event to listen. required max_trigger int | float Maximum number of times this listener has to be triggered. float('inf') Returns: Type Description wyvern . events . EventListener A EventListener object. Source code in wyvern/events.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 def as_listener ( event : Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], EventListener ]: \"\"\"Creates a [wyvern.events.EventListener][] object. Parameters ---------- event: wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> EventListener : nonlocal event , max_trigger return EventListener ( event , callback , max_trigger , 0 ) return inner","title":"as_listener()"},{"location":"api_reference/intents/","text":"Intents Bases: BitWiseFlag Intents constructor to provide to the gateway. Attributes: Name Type Description value int The final value of intents generated by the constructor. Source code in wyvern/intents.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 @typing . final class Intents ( BitWiseFlag ): \"\"\" Intents constructor to provide to the gateway. Attributes ---------- value: int The final value of intents generated by the constructor. \"\"\" NONE = 0 \"\"\" No intents. \"\"\" GUILDS = 1 << 0 \"\"\"Required for these gateway events: * `GUILD_CREATE` * `GUILD_UPDATE` * `GUILD_DELETE` * `GUILD_ROLE_CREATE` * `GUILD_ROLE_UPDATE` * `GUILD_ROLE_DELETE` * `CHANNEL_CREATE` * `CHANNEL_UPDATE` * `CHANNEL_DELETE` * `CHANNEL_PINS_UPDATE` * `THREAD_CREATE` * `THREAD_UPDATE` * `THREAD_DELETE` * `THREAD_LIST_SYNC` * `THREAD_MEMBER_UPDATE` * `THREAD_MEMBERS_UPDATE` * `STAGE_INSTANCE_CREATE` * `STAGE_INSTANCE_UPDATE` * `STAGE_INSTANCE_DELETE` \"\"\" GUILD_MEMBERS = 1 << 1 \"\"\"Required for these gateway events: * `GUILD_MEMBER_ADD` * `GUILD_MEMBER_UPDATE` * `GUILD_MEMBER_REMOVE` * `THREAD_MEMBERS_UPDATE` !!! warning This is a privileged intent. \"\"\" GUILD_BANS = 1 << 2 \"\"\"Required for these gateway events: * `GUILD_BAN_ADD` * `GUILD_BAN_REMOVE` \"\"\" GUILD_EMOJIS = 1 << 3 \"\"\"Required for these gateway events: * `GUILD_EMOJIS_UPDATE` * `GUILD_STICKERS_UPDATE` \"\"\" GUILD_INTEGRATIONS = 1 << 4 \"\"\"Required for these gateway events: * `GUILD_INTEGRATIONS_UPDATE` * `INTEGRATION_CREATE` * `INTEGRATION_UPDATE` * `INTEGRATION_DELETE` \"\"\" GUILD_WEBHOOKS = 1 << 5 \"\"\"Required for these gateway events: * `WEBHOOKS_UPDATE` \"\"\" GUILD_INVITES = 1 << 6 \"\"\"Required for these gateway events: * `INVITE_CREATE` * `INVITE_DELETE` \"\"\" GUILD_VOICE_STATES = 1 << 7 \"\"\"Required for these gateway events: * `VOICE_STATE_UPDATE` \"\"\" GUILD_PRESENCES = 1 << 8 \"\"\"Required for these gateway events: * `PRESENCE_UPDATE` !!! warning This is a privileged intent. \"\"\" GUILD_MESSAGES = 1 << 9 \"\"\"Required for these gateway events: * `MESSAGE_CREATE` * `MESSAGE_UPDATE` * `MESSAGE_DELETE` * `MESSAGE_DELETE_BULK` \"\"\" GUILD_MESSAGE_REACTIONS = 1 << 10 \"\"\"Required for these gateway events: * `MESSAGE_REACTION_ADD` * `MESSAGE_REACTION_REMOVE` * `MESSAGE_REACTION_REMOVE_ALL` * `MESSAGE_REACTION_REMOVE_EMOJI` \"\"\" GUILD_MESSAGE_TYPING = 1 << 11 \"\"\"Required for these gateway events: * `TYPING_START` \"\"\" DIRECT_MESSAGES = 1 << 12 \"\"\"Required for these gateway events: * `MESSAGE_CREATE` * `MESSAGE_UPDATE` * `MESSAGE_DELETE` * `CHANNEL_PINS_UPDATE` \"\"\" DIRECT_MESSAGE_REACTIONS = 1 << 13 \"\"\"Required for these gateway events: * `MESSAGE_REACTION_ADD` * `MESSAGE_REACTION_REMOVE` * `MESSAGE_REACTION_REMOVE_ALL` * `MESSAGE_REACTION_REMOVE_EMOJI` \"\"\" DIRECT_MESSAGE_TYPING = 1 << 14 \"\"\"Required for these gateway events: * `TYPING_START` \"\"\" MESSAGE_CONTENT = 1 << 15 \"\"\"Required for guild message's content. !!! warning This is a privileged intent. \"\"\" GUILD_SCHEDULED_EVENTS = 1 << 16 \"\"\"Required for these gateway events: * `GUILD_SCHEDULED_EVENT_CREATE` * `GUILD_SCHEDULED_EVENT_UPDATE` * `GUILD_SCHEDULED_EVENT_DELETE` * `GUILD_SCHEDULED_EVENT_USER_ADD` * `GUILD_SCHEDULED_EVENT_USER_REMOVE` \"\"\" AUTO_MODERATION_CONFIGURATION = 1 << 20 \"\"\"Required for these gateway events: * `AUTO_MODERATION_RULE_CREATE` * `AUTO_MODERATION_RULE_UPDATE` * `AUTO_MODERATION_RULE_DELETE` \"\"\" AUTO_MODERATION_EXECUTION = 1 << 21 \"\"\"Required for these gateway events: * `AUTO_MODERATION_ACTION_EXECUTION` \"\"\" UNPRIVILEGED = ( GUILDS | GUILD_EMOJIS | GUILD_INTEGRATIONS | GUILD_WEBHOOKS | GUILD_INVITES | GUILD_VOICE_STATES | GUILD_MESSAGE_REACTIONS | GUILD_MESSAGE_TYPING | GUILD_MESSAGES | DIRECT_MESSAGES | DIRECT_MESSAGE_TYPING | DIRECT_MESSAGE_REACTIONS | AUTO_MODERATION_CONFIGURATION | AUTO_MODERATION_EXECUTION ) \"\"\"All unprivileged intents.\"\"\" PRIVILEGED = MESSAGE_CONTENT | GUILD_MEMBERS | GUILD_PRESENCES \"\"\"All privileged intents.\"\"\" ALL = PRIVILEGED | UNPRIVILEGED \"\"\"All intents.\"\"\" ALL = PRIVILEGED | UNPRIVILEGED class-attribute All intents. AUTO_MODERATION_CONFIGURATION = 1 << 20 class-attribute Required for these gateway events: AUTO_MODERATION_RULE_CREATE AUTO_MODERATION_RULE_UPDATE AUTO_MODERATION_RULE_DELETE AUTO_MODERATION_EXECUTION = 1 << 21 class-attribute Required for these gateway events: AUTO_MODERATION_ACTION_EXECUTION DIRECT_MESSAGES = 1 << 12 class-attribute Required for these gateway events: MESSAGE_CREATE MESSAGE_UPDATE MESSAGE_DELETE CHANNEL_PINS_UPDATE DIRECT_MESSAGE_REACTIONS = 1 << 13 class-attribute Required for these gateway events: MESSAGE_REACTION_ADD MESSAGE_REACTION_REMOVE MESSAGE_REACTION_REMOVE_ALL MESSAGE_REACTION_REMOVE_EMOJI DIRECT_MESSAGE_TYPING = 1 << 14 class-attribute Required for these gateway events: TYPING_START GUILDS = 1 << 0 class-attribute Required for these gateway events: GUILD_CREATE GUILD_UPDATE GUILD_DELETE GUILD_ROLE_CREATE GUILD_ROLE_UPDATE GUILD_ROLE_DELETE CHANNEL_CREATE CHANNEL_UPDATE CHANNEL_DELETE CHANNEL_PINS_UPDATE THREAD_CREATE THREAD_UPDATE THREAD_DELETE THREAD_LIST_SYNC THREAD_MEMBER_UPDATE THREAD_MEMBERS_UPDATE STAGE_INSTANCE_CREATE STAGE_INSTANCE_UPDATE STAGE_INSTANCE_DELETE GUILD_BANS = 1 << 2 class-attribute Required for these gateway events: GUILD_BAN_ADD GUILD_BAN_REMOVE GUILD_EMOJIS = 1 << 3 class-attribute Required for these gateway events: GUILD_EMOJIS_UPDATE GUILD_STICKERS_UPDATE GUILD_INTEGRATIONS = 1 << 4 class-attribute Required for these gateway events: GUILD_INTEGRATIONS_UPDATE INTEGRATION_CREATE INTEGRATION_UPDATE INTEGRATION_DELETE GUILD_INVITES = 1 << 6 class-attribute Required for these gateway events: INVITE_CREATE INVITE_DELETE GUILD_MEMBERS = 1 << 1 class-attribute Required for these gateway events: GUILD_MEMBER_ADD GUILD_MEMBER_UPDATE GUILD_MEMBER_REMOVE THREAD_MEMBERS_UPDATE Warning This is a privileged intent. GUILD_MESSAGES = 1 << 9 class-attribute Required for these gateway events: MESSAGE_CREATE MESSAGE_UPDATE MESSAGE_DELETE MESSAGE_DELETE_BULK GUILD_MESSAGE_REACTIONS = 1 << 10 class-attribute Required for these gateway events: MESSAGE_REACTION_ADD MESSAGE_REACTION_REMOVE MESSAGE_REACTION_REMOVE_ALL MESSAGE_REACTION_REMOVE_EMOJI GUILD_MESSAGE_TYPING = 1 << 11 class-attribute Required for these gateway events: TYPING_START GUILD_PRESENCES = 1 << 8 class-attribute Required for these gateway events: PRESENCE_UPDATE Warning This is a privileged intent. GUILD_SCHEDULED_EVENTS = 1 << 16 class-attribute Required for these gateway events: GUILD_SCHEDULED_EVENT_CREATE GUILD_SCHEDULED_EVENT_UPDATE GUILD_SCHEDULED_EVENT_DELETE GUILD_SCHEDULED_EVENT_USER_ADD GUILD_SCHEDULED_EVENT_USER_REMOVE GUILD_VOICE_STATES = 1 << 7 class-attribute Required for these gateway events: VOICE_STATE_UPDATE GUILD_WEBHOOKS = 1 << 5 class-attribute Required for these gateway events: WEBHOOKS_UPDATE MESSAGE_CONTENT = 1 << 15 class-attribute Required for guild message's content. Warning This is a privileged intent. NONE = 0 class-attribute No intents. PRIVILEGED = MESSAGE_CONTENT | GUILD_MEMBERS | GUILD_PRESENCES class-attribute All privileged intents. UNPRIVILEGED = GUILDS | GUILD_EMOJIS | GUILD_INTEGRATIONS | GUILD_WEBHOOKS | GUILD_INVITES | GUILD_VOICE_STATES | GUILD_MESSAGE_REACTIONS | GUILD_MESSAGE_TYPING | GUILD_MESSAGES | DIRECT_MESSAGES | DIRECT_MESSAGE_TYPING | DIRECT_MESSAGE_REACTIONS | AUTO_MODERATION_CONFIGURATION | AUTO_MODERATION_EXECUTION class-attribute All unprivileged intents.","title":"intents"},{"location":"api_reference/intents/#wyvern.intents.Intents","text":"Bases: BitWiseFlag Intents constructor to provide to the gateway. Attributes: Name Type Description value int The final value of intents generated by the constructor. Source code in wyvern/intents.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 @typing . final class Intents ( BitWiseFlag ): \"\"\" Intents constructor to provide to the gateway. Attributes ---------- value: int The final value of intents generated by the constructor. \"\"\" NONE = 0 \"\"\" No intents. \"\"\" GUILDS = 1 << 0 \"\"\"Required for these gateway events: * `GUILD_CREATE` * `GUILD_UPDATE` * `GUILD_DELETE` * `GUILD_ROLE_CREATE` * `GUILD_ROLE_UPDATE` * `GUILD_ROLE_DELETE` * `CHANNEL_CREATE` * `CHANNEL_UPDATE` * `CHANNEL_DELETE` * `CHANNEL_PINS_UPDATE` * `THREAD_CREATE` * `THREAD_UPDATE` * `THREAD_DELETE` * `THREAD_LIST_SYNC` * `THREAD_MEMBER_UPDATE` * `THREAD_MEMBERS_UPDATE` * `STAGE_INSTANCE_CREATE` * `STAGE_INSTANCE_UPDATE` * `STAGE_INSTANCE_DELETE` \"\"\" GUILD_MEMBERS = 1 << 1 \"\"\"Required for these gateway events: * `GUILD_MEMBER_ADD` * `GUILD_MEMBER_UPDATE` * `GUILD_MEMBER_REMOVE` * `THREAD_MEMBERS_UPDATE` !!! warning This is a privileged intent. \"\"\" GUILD_BANS = 1 << 2 \"\"\"Required for these gateway events: * `GUILD_BAN_ADD` * `GUILD_BAN_REMOVE` \"\"\" GUILD_EMOJIS = 1 << 3 \"\"\"Required for these gateway events: * `GUILD_EMOJIS_UPDATE` * `GUILD_STICKERS_UPDATE` \"\"\" GUILD_INTEGRATIONS = 1 << 4 \"\"\"Required for these gateway events: * `GUILD_INTEGRATIONS_UPDATE` * `INTEGRATION_CREATE` * `INTEGRATION_UPDATE` * `INTEGRATION_DELETE` \"\"\" GUILD_WEBHOOKS = 1 << 5 \"\"\"Required for these gateway events: * `WEBHOOKS_UPDATE` \"\"\" GUILD_INVITES = 1 << 6 \"\"\"Required for these gateway events: * `INVITE_CREATE` * `INVITE_DELETE` \"\"\" GUILD_VOICE_STATES = 1 << 7 \"\"\"Required for these gateway events: * `VOICE_STATE_UPDATE` \"\"\" GUILD_PRESENCES = 1 << 8 \"\"\"Required for these gateway events: * `PRESENCE_UPDATE` !!! warning This is a privileged intent. \"\"\" GUILD_MESSAGES = 1 << 9 \"\"\"Required for these gateway events: * `MESSAGE_CREATE` * `MESSAGE_UPDATE` * `MESSAGE_DELETE` * `MESSAGE_DELETE_BULK` \"\"\" GUILD_MESSAGE_REACTIONS = 1 << 10 \"\"\"Required for these gateway events: * `MESSAGE_REACTION_ADD` * `MESSAGE_REACTION_REMOVE` * `MESSAGE_REACTION_REMOVE_ALL` * `MESSAGE_REACTION_REMOVE_EMOJI` \"\"\" GUILD_MESSAGE_TYPING = 1 << 11 \"\"\"Required for these gateway events: * `TYPING_START` \"\"\" DIRECT_MESSAGES = 1 << 12 \"\"\"Required for these gateway events: * `MESSAGE_CREATE` * `MESSAGE_UPDATE` * `MESSAGE_DELETE` * `CHANNEL_PINS_UPDATE` \"\"\" DIRECT_MESSAGE_REACTIONS = 1 << 13 \"\"\"Required for these gateway events: * `MESSAGE_REACTION_ADD` * `MESSAGE_REACTION_REMOVE` * `MESSAGE_REACTION_REMOVE_ALL` * `MESSAGE_REACTION_REMOVE_EMOJI` \"\"\" DIRECT_MESSAGE_TYPING = 1 << 14 \"\"\"Required for these gateway events: * `TYPING_START` \"\"\" MESSAGE_CONTENT = 1 << 15 \"\"\"Required for guild message's content. !!! warning This is a privileged intent. \"\"\" GUILD_SCHEDULED_EVENTS = 1 << 16 \"\"\"Required for these gateway events: * `GUILD_SCHEDULED_EVENT_CREATE` * `GUILD_SCHEDULED_EVENT_UPDATE` * `GUILD_SCHEDULED_EVENT_DELETE` * `GUILD_SCHEDULED_EVENT_USER_ADD` * `GUILD_SCHEDULED_EVENT_USER_REMOVE` \"\"\" AUTO_MODERATION_CONFIGURATION = 1 << 20 \"\"\"Required for these gateway events: * `AUTO_MODERATION_RULE_CREATE` * `AUTO_MODERATION_RULE_UPDATE` * `AUTO_MODERATION_RULE_DELETE` \"\"\" AUTO_MODERATION_EXECUTION = 1 << 21 \"\"\"Required for these gateway events: * `AUTO_MODERATION_ACTION_EXECUTION` \"\"\" UNPRIVILEGED = ( GUILDS | GUILD_EMOJIS | GUILD_INTEGRATIONS | GUILD_WEBHOOKS | GUILD_INVITES | GUILD_VOICE_STATES | GUILD_MESSAGE_REACTIONS | GUILD_MESSAGE_TYPING | GUILD_MESSAGES | DIRECT_MESSAGES | DIRECT_MESSAGE_TYPING | DIRECT_MESSAGE_REACTIONS | AUTO_MODERATION_CONFIGURATION | AUTO_MODERATION_EXECUTION ) \"\"\"All unprivileged intents.\"\"\" PRIVILEGED = MESSAGE_CONTENT | GUILD_MEMBERS | GUILD_PRESENCES \"\"\"All privileged intents.\"\"\" ALL = PRIVILEGED | UNPRIVILEGED \"\"\"All intents.\"\"\"","title":"Intents"},{"location":"api_reference/intents/#wyvern.intents.Intents.ALL","text":"All intents.","title":"ALL"},{"location":"api_reference/intents/#wyvern.intents.Intents.AUTO_MODERATION_CONFIGURATION","text":"Required for these gateway events: AUTO_MODERATION_RULE_CREATE AUTO_MODERATION_RULE_UPDATE AUTO_MODERATION_RULE_DELETE","title":"AUTO_MODERATION_CONFIGURATION"},{"location":"api_reference/intents/#wyvern.intents.Intents.AUTO_MODERATION_EXECUTION","text":"Required for these gateway events: AUTO_MODERATION_ACTION_EXECUTION","title":"AUTO_MODERATION_EXECUTION"},{"location":"api_reference/intents/#wyvern.intents.Intents.DIRECT_MESSAGES","text":"Required for these gateway events: MESSAGE_CREATE MESSAGE_UPDATE MESSAGE_DELETE CHANNEL_PINS_UPDATE","title":"DIRECT_MESSAGES"},{"location":"api_reference/intents/#wyvern.intents.Intents.DIRECT_MESSAGE_REACTIONS","text":"Required for these gateway events: MESSAGE_REACTION_ADD MESSAGE_REACTION_REMOVE MESSAGE_REACTION_REMOVE_ALL MESSAGE_REACTION_REMOVE_EMOJI","title":"DIRECT_MESSAGE_REACTIONS"},{"location":"api_reference/intents/#wyvern.intents.Intents.DIRECT_MESSAGE_TYPING","text":"Required for these gateway events: TYPING_START","title":"DIRECT_MESSAGE_TYPING"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILDS","text":"Required for these gateway events: GUILD_CREATE GUILD_UPDATE GUILD_DELETE GUILD_ROLE_CREATE GUILD_ROLE_UPDATE GUILD_ROLE_DELETE CHANNEL_CREATE CHANNEL_UPDATE CHANNEL_DELETE CHANNEL_PINS_UPDATE THREAD_CREATE THREAD_UPDATE THREAD_DELETE THREAD_LIST_SYNC THREAD_MEMBER_UPDATE THREAD_MEMBERS_UPDATE STAGE_INSTANCE_CREATE STAGE_INSTANCE_UPDATE STAGE_INSTANCE_DELETE","title":"GUILDS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_BANS","text":"Required for these gateway events: GUILD_BAN_ADD GUILD_BAN_REMOVE","title":"GUILD_BANS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_EMOJIS","text":"Required for these gateway events: GUILD_EMOJIS_UPDATE GUILD_STICKERS_UPDATE","title":"GUILD_EMOJIS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_INTEGRATIONS","text":"Required for these gateway events: GUILD_INTEGRATIONS_UPDATE INTEGRATION_CREATE INTEGRATION_UPDATE INTEGRATION_DELETE","title":"GUILD_INTEGRATIONS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_INVITES","text":"Required for these gateway events: INVITE_CREATE INVITE_DELETE","title":"GUILD_INVITES"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_MEMBERS","text":"Required for these gateway events: GUILD_MEMBER_ADD GUILD_MEMBER_UPDATE GUILD_MEMBER_REMOVE THREAD_MEMBERS_UPDATE Warning This is a privileged intent.","title":"GUILD_MEMBERS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_MESSAGES","text":"Required for these gateway events: MESSAGE_CREATE MESSAGE_UPDATE MESSAGE_DELETE MESSAGE_DELETE_BULK","title":"GUILD_MESSAGES"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_MESSAGE_REACTIONS","text":"Required for these gateway events: MESSAGE_REACTION_ADD MESSAGE_REACTION_REMOVE MESSAGE_REACTION_REMOVE_ALL MESSAGE_REACTION_REMOVE_EMOJI","title":"GUILD_MESSAGE_REACTIONS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_MESSAGE_TYPING","text":"Required for these gateway events: TYPING_START","title":"GUILD_MESSAGE_TYPING"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_PRESENCES","text":"Required for these gateway events: PRESENCE_UPDATE Warning This is a privileged intent.","title":"GUILD_PRESENCES"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_SCHEDULED_EVENTS","text":"Required for these gateway events: GUILD_SCHEDULED_EVENT_CREATE GUILD_SCHEDULED_EVENT_UPDATE GUILD_SCHEDULED_EVENT_DELETE GUILD_SCHEDULED_EVENT_USER_ADD GUILD_SCHEDULED_EVENT_USER_REMOVE","title":"GUILD_SCHEDULED_EVENTS"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_VOICE_STATES","text":"Required for these gateway events: VOICE_STATE_UPDATE","title":"GUILD_VOICE_STATES"},{"location":"api_reference/intents/#wyvern.intents.Intents.GUILD_WEBHOOKS","text":"Required for these gateway events: WEBHOOKS_UPDATE","title":"GUILD_WEBHOOKS"},{"location":"api_reference/intents/#wyvern.intents.Intents.MESSAGE_CONTENT","text":"Required for guild message's content. Warning This is a privileged intent.","title":"MESSAGE_CONTENT"},{"location":"api_reference/intents/#wyvern.intents.Intents.NONE","text":"No intents.","title":"NONE"},{"location":"api_reference/intents/#wyvern.intents.Intents.PRIVILEGED","text":"All privileged intents.","title":"PRIVILEGED"},{"location":"api_reference/intents/#wyvern.intents.Intents.UNPRIVILEGED","text":"All unprivileged intents.","title":"UNPRIVILEGED"},{"location":"api_reference/plugins/","text":"Plugin Plugins for extendibility. Parameters: Name Type Description Default name str Name of the plugin. required description str | None Description of the plugin. None Source code in wyvern/plugins.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Plugin : \"\"\"Plugins for extendibility. Parameters ---------- name: str Name of the plugin. description : str | None Description of the plugin. \"\"\" name : str \"\"\"Name of the plugin.\"\"\" description : str | None = None \"\"\"Description of the plugin.\"\"\" client : GatewayClient \"\"\"Client attached to the plugin.\"\"\" listeners : list [ EventListener ] = [] \"\"\"EventListeners attached to the plugin.\"\"\" def __init__ ( self , name : str , * , description : str | None = None ) -> None : self . name = name self . description = description def setup_plugin ( self , client : \"GatewayClient\" ) -> None : self . client = client for listener in self . listeners : client . event_handler . add_listener ( listener ) def with_listener ( self , event : Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], EventListener ]: \"\"\" Creates and adds a new listenet to the client's event handler. Parameters ---------- event: wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> EventListener : lsnr = as_listener ( event , max_trigger = max_trigger )( callback ) self . listeners . append ( lsnr ) return lsnr return inner client : GatewayClient class-attribute Client attached to the plugin. listeners : list [ EventListener ] = [] class-attribute EventListeners attached to the plugin. with_listener ( event , * , max_trigger = float ( 'inf' )) Creates and adds a new listenet to the client's event handler. Parameters: Name Type Description Default event Event The event to listen. required max_trigger int | float Maximum number of times this listener has to be triggered. float('inf') Returns: Type Description wyvern . events . EventListener A EventListener object. Source code in wyvern/plugins.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def with_listener ( self , event : Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], EventListener ]: \"\"\" Creates and adds a new listenet to the client's event handler. Parameters ---------- event: wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> EventListener : lsnr = as_listener ( event , max_trigger = max_trigger )( callback ) self . listeners . append ( lsnr ) return lsnr return inner","title":"plugins"},{"location":"api_reference/plugins/#wyvern.plugins.Plugin","text":"Plugins for extendibility. Parameters: Name Type Description Default name str Name of the plugin. required description str | None Description of the plugin. None Source code in wyvern/plugins.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Plugin : \"\"\"Plugins for extendibility. Parameters ---------- name: str Name of the plugin. description : str | None Description of the plugin. \"\"\" name : str \"\"\"Name of the plugin.\"\"\" description : str | None = None \"\"\"Description of the plugin.\"\"\" client : GatewayClient \"\"\"Client attached to the plugin.\"\"\" listeners : list [ EventListener ] = [] \"\"\"EventListeners attached to the plugin.\"\"\" def __init__ ( self , name : str , * , description : str | None = None ) -> None : self . name = name self . description = description def setup_plugin ( self , client : \"GatewayClient\" ) -> None : self . client = client for listener in self . listeners : client . event_handler . add_listener ( listener ) def with_listener ( self , event : Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], EventListener ]: \"\"\" Creates and adds a new listenet to the client's event handler. Parameters ---------- event: wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> EventListener : lsnr = as_listener ( event , max_trigger = max_trigger )( callback ) self . listeners . append ( lsnr ) return lsnr return inner","title":"Plugin"},{"location":"api_reference/plugins/#wyvern.plugins.Plugin.client","text":"Client attached to the plugin.","title":"client"},{"location":"api_reference/plugins/#wyvern.plugins.Plugin.listeners","text":"EventListeners attached to the plugin.","title":"listeners"},{"location":"api_reference/plugins/#wyvern.plugins.Plugin.with_listener","text":"Creates and adds a new listenet to the client's event handler. Parameters: Name Type Description Default event Event The event to listen. required max_trigger int | float Maximum number of times this listener has to be triggered. float('inf') Returns: Type Description wyvern . events . EventListener A EventListener object. Source code in wyvern/plugins.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def with_listener ( self , event : Event , * , max_trigger : int | float = float ( \"inf\" ) ) -> typing . Callable [[ typing . Callable [ ... , typing . Awaitable [ typing . Any ]]], EventListener ]: \"\"\" Creates and adds a new listenet to the client's event handler. Parameters ---------- event: wyvern.events.Event The event to listen. max_trigger: int | float Maximum number of times this listener has to be triggered. Returns ------- wyvern.events.EventListener A EventListener object. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> EventListener : lsnr = as_listener ( event , max_trigger = max_trigger )( callback ) self . listeners . append ( lsnr ) return lsnr return inner","title":"with_listener()"},{"location":"api_reference/presences/","text":"Activity Represents a base activity with minumum info. Base class for all activities and for bot's gateway payload. Parameters: Name Type Description Default name str Name of the activity. required type wyvern . presences . ActivityType Type of the activity. required url The URL this activity points to. None Source code in wyvern/presences.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Activity : \"\"\"Represents a base activity with minumum info. Base class for all activities and for bot's gateway payload. Parameters ---------- name : str Name of the activity. type : wyvern.presences.ActivityType Type of the activity. url : The URL this activity points to. \"\"\" name : str \"\"\"Name of the activity.\"\"\" type : ActivityType \"\"\"Type of activity.\"\"\" url : str | None \"\"\"URL this activity points to.\"\"\" def __init__ ( self , * , name : str , type : ActivityType , url : str | None = None ) -> None : self . name = name self . type = type self . url = url def to_event_payload ( self , ) -> dict [ str , str | int | None ]: return { \"name\" : self . name , \"type\" : int ( self . type ), \"url\" : self . url } ActivityType Bases: enum . IntEnum Type of activity. Source code in wyvern/presences.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @typing . final class ActivityType ( enum . IntEnum ): \"\"\"Type of activity.\"\"\" GAME = 0 \"\"\"The user is playing a game.\"\"\" STREAMING = 1 \"\"\"Activity where user is streaming.\"\"\" LISTENING = 2 \"\"\"Listening activity.\"\"\" WATCHING = 3 \"\"\"Watching activity.\"\"\" CUSTOM = 4 \"\"\"This activity is a custom status.\"\"\" COMPETING = 5 \"\"\"Compoeting activity.\"\"\" COMPETING = 5 class-attribute Compoeting activity. CUSTOM = 4 class-attribute This activity is a custom status. GAME = 0 class-attribute The user is playing a game. LISTENING = 2 class-attribute Listening activity. STREAMING = 1 class-attribute Activity where user is streaming. WATCHING = 3 class-attribute Watching activity. Status Bases: enum . Enum Enum for User's status Source code in wyvern/presences.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @typing . final class Status ( enum . Enum ): \"\"\"Enum for User's status\"\"\" ONLINE = \"online\" \"\"\"Online status.\"\"\" DND = \"dnd\" \"\"\"DND status.\"\"\" IDLE = \"idle\" \"\"\"IDLE status.\"\"\" INVISIBLE = \"invisible\" \"\"\"Invisible status.\"\"\" OFFLINE = \"offline\" \"\"\"Offline status.\"\"\" DND = 'dnd' class-attribute DND status. IDLE = 'idle' class-attribute IDLE status. INVISIBLE = 'invisible' class-attribute Invisible status. OFFLINE = 'offline' class-attribute Offline status. ONLINE = 'online' class-attribute Online status.","title":"presences"},{"location":"api_reference/presences/#wyvern.presences.Activity","text":"Represents a base activity with minumum info. Base class for all activities and for bot's gateway payload. Parameters: Name Type Description Default name str Name of the activity. required type wyvern . presences . ActivityType Type of the activity. required url The URL this activity points to. None Source code in wyvern/presences.py 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 class Activity : \"\"\"Represents a base activity with minumum info. Base class for all activities and for bot's gateway payload. Parameters ---------- name : str Name of the activity. type : wyvern.presences.ActivityType Type of the activity. url : The URL this activity points to. \"\"\" name : str \"\"\"Name of the activity.\"\"\" type : ActivityType \"\"\"Type of activity.\"\"\" url : str | None \"\"\"URL this activity points to.\"\"\" def __init__ ( self , * , name : str , type : ActivityType , url : str | None = None ) -> None : self . name = name self . type = type self . url = url def to_event_payload ( self , ) -> dict [ str , str | int | None ]: return { \"name\" : self . name , \"type\" : int ( self . type ), \"url\" : self . url }","title":"Activity"},{"location":"api_reference/presences/#wyvern.presences.ActivityType","text":"Bases: enum . IntEnum Type of activity. Source code in wyvern/presences.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 @typing . final class ActivityType ( enum . IntEnum ): \"\"\"Type of activity.\"\"\" GAME = 0 \"\"\"The user is playing a game.\"\"\" STREAMING = 1 \"\"\"Activity where user is streaming.\"\"\" LISTENING = 2 \"\"\"Listening activity.\"\"\" WATCHING = 3 \"\"\"Watching activity.\"\"\" CUSTOM = 4 \"\"\"This activity is a custom status.\"\"\" COMPETING = 5 \"\"\"Compoeting activity.\"\"\"","title":"ActivityType"},{"location":"api_reference/presences/#wyvern.presences.ActivityType.COMPETING","text":"Compoeting activity.","title":"COMPETING"},{"location":"api_reference/presences/#wyvern.presences.ActivityType.CUSTOM","text":"This activity is a custom status.","title":"CUSTOM"},{"location":"api_reference/presences/#wyvern.presences.ActivityType.GAME","text":"The user is playing a game.","title":"GAME"},{"location":"api_reference/presences/#wyvern.presences.ActivityType.LISTENING","text":"Listening activity.","title":"LISTENING"},{"location":"api_reference/presences/#wyvern.presences.ActivityType.STREAMING","text":"Activity where user is streaming.","title":"STREAMING"},{"location":"api_reference/presences/#wyvern.presences.ActivityType.WATCHING","text":"Watching activity.","title":"WATCHING"},{"location":"api_reference/presences/#wyvern.presences.Status","text":"Bases: enum . Enum Enum for User's status Source code in wyvern/presences.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 @typing . final class Status ( enum . Enum ): \"\"\"Enum for User's status\"\"\" ONLINE = \"online\" \"\"\"Online status.\"\"\" DND = \"dnd\" \"\"\"DND status.\"\"\" IDLE = \"idle\" \"\"\"IDLE status.\"\"\" INVISIBLE = \"invisible\" \"\"\"Invisible status.\"\"\" OFFLINE = \"offline\" \"\"\"Offline status.\"\"\"","title":"Status"},{"location":"api_reference/presences/#wyvern.presences.Status.DND","text":"DND status.","title":"DND"},{"location":"api_reference/presences/#wyvern.presences.Status.IDLE","text":"IDLE status.","title":"IDLE"},{"location":"api_reference/presences/#wyvern.presences.Status.INVISIBLE","text":"Invisible status.","title":"INVISIBLE"},{"location":"api_reference/presences/#wyvern.presences.Status.OFFLINE","text":"Offline status.","title":"OFFLINE"},{"location":"api_reference/presences/#wyvern.presences.Status.ONLINE","text":"Online status.","title":"ONLINE"},{"location":"api_reference/rest/","text":"The REST Client that deals with disocrd REST Api requests. Source code in wyvern/rest/__init__.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class RESTClient : \"\"\"The REST Client that deals with disocrd REST Api requests.\"\"\" def __init__ ( self , * , client : \"GatewayClient\" , token : str , api_version : int = 10 , client_session : aiohttp . ClientSession | None = None , ) -> None : self . _client = client self . _session : aiohttp . ClientSession self . _token = token self . _api_version = api_version self . _headers : dict [ str , multidict . istr ] = { \"Authorization\" : multidict . istr ( f \"Bot { token } \" )} if client_session is not None : self . _session = client_session async def _create_websocket ( self ) -> aiohttp . ClientWebSocketResponse : if getattr ( self , \"_session\" , None ) is None : self . _session = aiohttp . ClientSession ( headers = self . _headers ) return await self . _session . ws_connect ( # type: ignore f \"wss://gateway.discord.gg/?v= { self . _api_version } &encoding=json\" ) async def request ( self , route : RequestRoute ) -> typing . Any : headers = self . _headers . copy () headers [ \"Content-Type\" ] = multidict . istr ( \"application/json\" ) self . _client . _logger . debug ( f \"Creating a { route . type } request to { route . _url } endpoint.\" ) res = await self . _session . request ( route . type , route . url , headers = headers , json = route . json ) if res . status in ( 200 , 201 ): return await res . json () if res . status in ( 204 , 304 ): return else : self . handle_error ( exc := HTTPException (( await res . json ())[ \"message\" ], res . status , route ) . create ()) raise exc def handle_error ( self , exc : HTTPException ) -> None : self . _client . _logger . error ( \"Exception while creating a HTTP request. \\n Type: %s , Endpoint: %s \\n Exception: %s \" , exc . route . type , exc . route . url , exc . message , ) async def fetch_user ( self , user_id : int ) -> models . User : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.NotFound The targetted user was not found. \"\"\" res = await self . request ( RequestRoute ( Endpoints . get_user ( user_id ))) return models . _converters . payload_to_user ( self . _client , res ) async def fetch_client_user ( self ) -> \"models.BotUser\" : \"\"\" Fetchs the bot's user object. Returns ------- wyvern.models.users.BotUser BotUser object representating the bot's user. \"\"\" res = await self . request ( RequestRoute ( Endpoints . get_current_user ())) return models . _converters . payload_to_botuser ( self . _client , res ) async def edit_client_user ( self , username : str | None = None , avatar : bytes | None = None ) -> \"models.BotUser\" : \"\"\"Edits the bot's user. Parameters ---------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" payload : dict [ str , bytes | str ] = {} if username is not None : payload [ \"username\" ] = username if avatar is not None : payload [ \"avatar\" ] = avatar res : dict [ str , int | str | bool ] = await self . request ( RequestRoute ( Endpoints . get_current_user (), type = \"PATCH\" , json = payload ) ) return models . _converters . payload_to_botuser ( self . _client , res ) async def fetch_member ( self , guild_id : int , member_id : int ) -> models . Member : res = await self . request ( RequestRoute ( Endpoints . get_guild_member ( guild_id , member_id ), ) ) return models . _converters . payload_to_member ( self . _client , models . Snowflake . create ( guild_id ), res ) async def create_message ( self , channel_id : int , content : str | None = None , * , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ ActionRowContainer ] = (), reference : int | models . MessageReference | None = None , allowed_mentions : models . AllowedMentions | None = None , flags : models . messages . MessageFlags | None = None , delete_after : int | None = None , ) -> \"models.messages.Message\" : \"\"\"Create a new message. Parameters ---------- channel_id : int ID of the channel where the message is to be sent. content : str | None The text content of the message. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. reference : int | wyvern.models.messages.MessageReference | None ID or a message reference to which this is a response to. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" payload : dict [ str , typing . Any ] = { \"content\" : content , \"embeds\" : [ embed . _payload for embed in embeds ], \"components\" : [ comp . to_payload () for comp in components ], \"allowed_mentions\" : ( allowed_mentions or self . _client . allowed_mentions ) . to_payload (), \"flags\" : flags . value if flags else None , } if reference is not None : if isinstance ( reference , models . MessageReference ): payload [ \"message_reference\" ] = reference . to_payload () else : payload [ \"message_reference\" ] = models . MessageReference ( message_id = reference ) . to_payload () res : dict [ str , typing . Any ] = await self . request ( RequestRoute ( Endpoints . create_message ( channel_id ), type = \"POST\" , json = payload ), ) msg = models . _converters . payload_to_message ( self . _client , res ) async def _delete_after ( sec : int ) -> None : await asyncio . sleep ( sec ) await self . delete_message ( msg . channel_id , msg . id ) if delete_after is not None : asyncio . create_task ( _delete_after ( delete_after )) return msg async def delete_message ( self , channel_id : int , message_id : int ) -> None : await self . request ( RequestRoute ( Endpoints . delete_message ( channel_id , message_id ), type = \"DELETE\" )) async def fetch_message ( self , channel_id : int , message_id : int ) -> models . Message : res = await self . request ( RequestRoute ( Endpoints . get_channel_message ( channel_id , message_id ))) return models . _converters . payload_to_message ( self . _client , res ) async def fetch_messages ( self , channel_id : int , around : datetime . datetime ) -> dict [ models . Snowflake , models . Message ]: try : res = await self . request ( RequestRoute ( Endpoints . get_channel_messages ( channel_id ))) return { msg . id : msg for msg in [ models . _converters . payload_to_message ( self . _client , payload ) for payload in res ] } except HTTPException as e : raise e async def create_application_command ( self , * , name : str , description : str , options : typing . Sequence [ commands . slash_commands . CommandOption ] = (), dm_permission : bool = True , type : interactions . base . InteractionCommandType , ) -> typing . Any : payload = { \"name\" : name , \"description\" : description , \"options\" : [ option . to_payload () for option in options ], \"dm_permission\" : dm_permission , \"type\" : type , } return await self . request ( RequestRoute ( Endpoints . interaction_command ( self . _client . _client_id ), type = \"POST\" , json = payload ) ) async def _create_app_command_from_payload ( self , payload : dict [ str , typing . Any ]) -> typing . Any : return await self . request ( RequestRoute ( Endpoints . interaction_command ( self . _client . _client_id ), type = \"POST\" , json = payload ) ) async def create_interaction_response ( self , interaction : interactions . Interaction , response_type : interactions . InteractionResponseType , * , content : str | None = None , embeds : typing . Sequence [ EmbedConstructor ] = (), components : typing . Sequence [ ActionRowContainer ] = (), flags : models . messages . MessageFlags | None = None , allowed_mentions : models . messages . AllowedMentions | None = None , modal : Modal | None = None , ) -> None : payload : dict [ str , typing . Any ] = { \"type\" : int ( response_type ), \"data\" : {}} if response_type is interactions . InteractionResponseType . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE : pass elif response_type is interactions . InteractionResponseType . CHANNEL_MESSAGE_WITH_SOURCE : payload [ \"data\" ][ \"content\" ] = content payload [ \"data\" ][ \"embeds\" ] = [ embed . _payload for embed in embeds ] payload [ \"data\" ][ \"components\" ] = [ builder . to_payload () for builder in components ] payload [ \"data\" ][ \"allowed_mentions\" ] = ( allowed_mentions or self . _client . allowed_mentions ) . to_payload () payload [ \"data\" ][ \"flags\" ] = flags . value if flags else None elif response_type is interactions . InteractionResponseType . MODAL : if modal is None : raise ValueError ( \"No Modal instance provided to send.\" ) payload [ \"data\" ][ \"custom_id\" ] = modal . custom_id payload [ \"data\" ][ \"title\" ] = modal . title payload [ \"data\" ][ \"components\" ] = [{ \"type\" : 1 }] payload [ \"data\" ][ \"components\" ][ 0 ][ \"components\" ] = [ comp . to_payload () for comp in modal . text_inputs ] await self . request ( RequestRoute ( Endpoints . interaction_callback ( interaction . id , interaction . token , ), type = \"POST\" , json = payload , ) ) create_message ( channel_id , content = None , * , embeds = (), components = (), reference = None , allowed_mentions = None , flags = None , delete_after = None ) async Create a new message. Parameters: Name Type Description Default channel_id int ID of the channel where the message is to be sent. required content str | None The text content of the message. None embeds typing . Sequence [ wyvern . constructors . embeds . EmbedConstructor ] Sequence of embeds to send. () components typing . Sequence [ wyvern . components . container . ActionRowContainer ] Sequence of action rows to send. () reference int | wyvern . models . messages . MessageReference | None ID or a message reference to which this is a response to. None allowed_mentions wyvern . models . messages . AllowedMentions | None Allowed mentions configs. None Returns: Type Description wyvern . models . messages . Message The message object that got created. Source code in wyvern/rest/__init__.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 async def create_message ( self , channel_id : int , content : str | None = None , * , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ ActionRowContainer ] = (), reference : int | models . MessageReference | None = None , allowed_mentions : models . AllowedMentions | None = None , flags : models . messages . MessageFlags | None = None , delete_after : int | None = None , ) -> \"models.messages.Message\" : \"\"\"Create a new message. Parameters ---------- channel_id : int ID of the channel where the message is to be sent. content : str | None The text content of the message. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. reference : int | wyvern.models.messages.MessageReference | None ID or a message reference to which this is a response to. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" payload : dict [ str , typing . Any ] = { \"content\" : content , \"embeds\" : [ embed . _payload for embed in embeds ], \"components\" : [ comp . to_payload () for comp in components ], \"allowed_mentions\" : ( allowed_mentions or self . _client . allowed_mentions ) . to_payload (), \"flags\" : flags . value if flags else None , } if reference is not None : if isinstance ( reference , models . MessageReference ): payload [ \"message_reference\" ] = reference . to_payload () else : payload [ \"message_reference\" ] = models . MessageReference ( message_id = reference ) . to_payload () res : dict [ str , typing . Any ] = await self . request ( RequestRoute ( Endpoints . create_message ( channel_id ), type = \"POST\" , json = payload ), ) msg = models . _converters . payload_to_message ( self . _client , res ) async def _delete_after ( sec : int ) -> None : await asyncio . sleep ( sec ) await self . delete_message ( msg . channel_id , msg . id ) if delete_after is not None : asyncio . create_task ( _delete_after ( delete_after )) return msg edit_client_user ( username = None , avatar = None ) async Edits the bot's user. Parameters: Name Type Description Default username str The new username. None avatar bytes The new avatar bytes. None Returns: Type Description wyvern . models . users . BotUser The updated user of bot. Source code in wyvern/rest/__init__.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def edit_client_user ( self , username : str | None = None , avatar : bytes | None = None ) -> \"models.BotUser\" : \"\"\"Edits the bot's user. Parameters ---------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" payload : dict [ str , bytes | str ] = {} if username is not None : payload [ \"username\" ] = username if avatar is not None : payload [ \"avatar\" ] = avatar res : dict [ str , int | str | bool ] = await self . request ( RequestRoute ( Endpoints . get_current_user (), type = \"PATCH\" , json = payload ) ) return models . _converters . payload_to_botuser ( self . _client , res ) fetch_client_user () async Fetchs the bot's user object. Returns: Type Description wyvern . models . users . BotUser BotUser object representating the bot's user. Source code in wyvern/rest/__init__.py 130 131 132 133 134 135 136 137 138 139 140 141 async def fetch_client_user ( self ) -> \"models.BotUser\" : \"\"\" Fetchs the bot's user object. Returns ------- wyvern.models.users.BotUser BotUser object representating the bot's user. \"\"\" res = await self . request ( RequestRoute ( Endpoints . get_current_user ())) return models . _converters . payload_to_botuser ( self . _client , res ) fetch_user ( user_id ) async Fetchs a user using the REST api. Parameters: Name Type Description Default user_id int ID of the user that is to be fetched. required Returns: Type Description wyvern . models . users . User The user object that was fetched. Raises: Type Description wyvern . exceptions . NotFound The targetted user was not found. Source code in wyvern/rest/__init__.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 async def fetch_user ( self , user_id : int ) -> models . User : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.NotFound The targetted user was not found. \"\"\" res = await self . request ( RequestRoute ( Endpoints . get_user ( user_id ))) return models . _converters . payload_to_user ( self . _client , res )","title":"rest"},{"location":"api_reference/rest/#wyvern.rest.RESTClient.create_message","text":"Create a new message. Parameters: Name Type Description Default channel_id int ID of the channel where the message is to be sent. required content str | None The text content of the message. None embeds typing . Sequence [ wyvern . constructors . embeds . EmbedConstructor ] Sequence of embeds to send. () components typing . Sequence [ wyvern . components . container . ActionRowContainer ] Sequence of action rows to send. () reference int | wyvern . models . messages . MessageReference | None ID or a message reference to which this is a response to. None allowed_mentions wyvern . models . messages . AllowedMentions | None Allowed mentions configs. None Returns: Type Description wyvern . models . messages . Message The message object that got created. Source code in wyvern/rest/__init__.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 async def create_message ( self , channel_id : int , content : str | None = None , * , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ ActionRowContainer ] = (), reference : int | models . MessageReference | None = None , allowed_mentions : models . AllowedMentions | None = None , flags : models . messages . MessageFlags | None = None , delete_after : int | None = None , ) -> \"models.messages.Message\" : \"\"\"Create a new message. Parameters ---------- channel_id : int ID of the channel where the message is to be sent. content : str | None The text content of the message. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. reference : int | wyvern.models.messages.MessageReference | None ID or a message reference to which this is a response to. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" payload : dict [ str , typing . Any ] = { \"content\" : content , \"embeds\" : [ embed . _payload for embed in embeds ], \"components\" : [ comp . to_payload () for comp in components ], \"allowed_mentions\" : ( allowed_mentions or self . _client . allowed_mentions ) . to_payload (), \"flags\" : flags . value if flags else None , } if reference is not None : if isinstance ( reference , models . MessageReference ): payload [ \"message_reference\" ] = reference . to_payload () else : payload [ \"message_reference\" ] = models . MessageReference ( message_id = reference ) . to_payload () res : dict [ str , typing . Any ] = await self . request ( RequestRoute ( Endpoints . create_message ( channel_id ), type = \"POST\" , json = payload ), ) msg = models . _converters . payload_to_message ( self . _client , res ) async def _delete_after ( sec : int ) -> None : await asyncio . sleep ( sec ) await self . delete_message ( msg . channel_id , msg . id ) if delete_after is not None : asyncio . create_task ( _delete_after ( delete_after )) return msg","title":"create_message()"},{"location":"api_reference/rest/#wyvern.rest.RESTClient.edit_client_user","text":"Edits the bot's user. Parameters: Name Type Description Default username str The new username. None avatar bytes The new avatar bytes. None Returns: Type Description wyvern . models . users . BotUser The updated user of bot. Source code in wyvern/rest/__init__.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 async def edit_client_user ( self , username : str | None = None , avatar : bytes | None = None ) -> \"models.BotUser\" : \"\"\"Edits the bot's user. Parameters ---------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" payload : dict [ str , bytes | str ] = {} if username is not None : payload [ \"username\" ] = username if avatar is not None : payload [ \"avatar\" ] = avatar res : dict [ str , int | str | bool ] = await self . request ( RequestRoute ( Endpoints . get_current_user (), type = \"PATCH\" , json = payload ) ) return models . _converters . payload_to_botuser ( self . _client , res )","title":"edit_client_user()"},{"location":"api_reference/rest/#wyvern.rest.RESTClient.fetch_client_user","text":"Fetchs the bot's user object. Returns: Type Description wyvern . models . users . BotUser BotUser object representating the bot's user. Source code in wyvern/rest/__init__.py 130 131 132 133 134 135 136 137 138 139 140 141 async def fetch_client_user ( self ) -> \"models.BotUser\" : \"\"\" Fetchs the bot's user object. Returns ------- wyvern.models.users.BotUser BotUser object representating the bot's user. \"\"\" res = await self . request ( RequestRoute ( Endpoints . get_current_user ())) return models . _converters . payload_to_botuser ( self . _client , res )","title":"fetch_client_user()"},{"location":"api_reference/rest/#wyvern.rest.RESTClient.fetch_user","text":"Fetchs a user using the REST api. Parameters: Name Type Description Default user_id int ID of the user that is to be fetched. required Returns: Type Description wyvern . models . users . User The user object that was fetched. Raises: Type Description wyvern . exceptions . NotFound The targetted user was not found. Source code in wyvern/rest/__init__.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 async def fetch_user ( self , user_id : int ) -> models . User : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.NotFound The targetted user was not found. \"\"\" res = await self . request ( RequestRoute ( Endpoints . get_user ( user_id ))) return models . _converters . payload_to_user ( self . _client , res )","title":"fetch_user()"},{"location":"api_reference/utils/","text":"Utility functions and classes for the library. Eval Class for code evaluation. Warning This class is not sandboxed so data like environmental variables will be evaluated when the methods gets executed as well. Source code in wyvern/utils.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class Eval : \"\"\"Class for code evaluation. !!! warning This class is not sandboxed so data like environmental variables will be evaluated when the methods gets executed as well. \"\"\" def add_returns ( self , body : typing . Any ) -> None : if isinstance ( body [ - 1 ], ast . Expr ): body [ - 1 ] = ast . Return ( body [ - 1 ] . value ) ast . fix_missing_locations ( body [ - 1 ]) # for if statements, we insert returns into the body and the orelse if isinstance ( body [ - 1 ], ast . If ): self . add_returns ( body [ - 1 ] . body ) self . add_returns ( body [ - 1 ] . orelse ) # for with blocks, again we insert returns into the body if isinstance ( body [ - 1 ], ast . With ): self . add_returns ( body [ - 1 ] . body ) async def f_eval ( self , * , code : str , renv : dict [ str , typing . Any ]) -> typing . Any : \"\"\"Evaluates the code in the bot's namespace. Parameters ---------- code : str The code to evaluate. renv: dict[str, typing.Any] Environment to evaluate code in. Returns ------- typing.Any The result of the code. \"\"\" _fn_name = \"__wyvern_eval\" code = \" \\n \" . join ( f \" { i } \" for i in code . strip () . splitlines ()) parsed : typing . Any = ast . parse ( f \"async def { _fn_name } : \\n { code } \" ) self . add_returns ( parsed . body [ 0 ] . body ) exec ( compile ( parsed , filename = \"<ast>\" , mode = \"exec\" ), renv ) fn = renv [ _fn_name ] return await fn () f_eval ( * , code , renv ) async Evaluates the code in the bot's namespace. Parameters: Name Type Description Default code str The code to evaluate. required renv dict [ str , typing . Any ] Environment to evaluate code in. required Returns: Type Description typing . Any The result of the code. Source code in wyvern/utils.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 async def f_eval ( self , * , code : str , renv : dict [ str , typing . Any ]) -> typing . Any : \"\"\"Evaluates the code in the bot's namespace. Parameters ---------- code : str The code to evaluate. renv: dict[str, typing.Any] Environment to evaluate code in. Returns ------- typing.Any The result of the code. \"\"\" _fn_name = \"__wyvern_eval\" code = \" \\n \" . join ( f \" { i } \" for i in code . strip () . splitlines ()) parsed : typing . Any = ast . parse ( f \"async def { _fn_name } : \\n { code } \" ) self . add_returns ( parsed . body [ 0 ] . body ) exec ( compile ( parsed , filename = \"<ast>\" , mode = \"exec\" ), renv ) fn = renv [ _fn_name ] return await fn () Hook Hooks for per-module setup. They can be loaded using GatewayClient.load_hooks Source code in wyvern/utils.py 95 96 97 98 99 100 101 102 103 104 105 @attrs . define class Hook : \"\"\"Hooks for per-module setup. They can be loaded using `GatewayClient.load_hooks`\"\"\" callback : typing . Callable [ ... , typing . Any ] \"\"\"Callback of the hook.\"\"\" name : str \"\"\"Name of the hook.\"\"\" def __call__ ( self , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : return self . callback ( * args , ** kwargs ) callback : typing . Callable [ ... , typing . Any ] class-attribute Callback of the hook. name : str class-attribute Name of the hook. as_hook ( name = None ) Creates a wyvern.utils.Hook Parameters: Name Type Description Default name str Name of the hook. None Returns: Type Description wyvern . utils . Hook The hook that was created. Source code in wyvern/utils.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def as_hook ( name : str | None = None ) -> typing . Callable [ ... , Hook ]: \"\"\"Creates a [wyvern.utils.Hook][] Parameters ---------- name : str Name of the hook. Returns ------- wyvern.utils.Hook The hook that was created. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Any ]) -> Hook : return Hook ( callback , name or callback . __name__ ) return inner create_timestamp ( dt , * , style = 't' ) Creates an UNIX timestamp for provided datetime or timedelta object. Parameters: Name Type Description Default dt datetime . datetime | datetime . timedelta The datetime or timedelta to convert. required Returns: Type Description str The UNIX timestamp. Source code in wyvern/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def create_timestamp ( dt : datetime . datetime | datetime . timedelta , * , style : str = \"t\" ) -> str : \"\"\"Creates an UNIX timestamp for provided datetime or timedelta object. Parameters ---------- dt : datetime.datetime | datetime.timedelta The datetime or timedelta to convert. Returns ------- str The UNIX timestamp. \"\"\" if isinstance ( dt , datetime . timedelta ): dt = datetime . datetime . utcnow () + dt return f \"<t: { int ( dt . timestamp ()) } : { style } >\" get_arg_count ( callable ) Counts the number of args in a callable. Parameters: Name Type Description Default callable typing . Callable [..., typing . Any ] The callable to get arg count of. required Returns: Type Description int Number of arguments in a callable. Source code in wyvern/utils.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def get_arg_count ( callable : typing . Callable [ ... , typing . Any ]) -> int : \"\"\"Counts the number of args in a callable. Parameters ---------- callable : typing.Callable[..., typing.Any] The callable to get arg count of. Returns ------- int Number of arguments in a callable. \"\"\" return len ( inspect . getargs ( callable . __code__ ) . args )","title":"utils"},{"location":"api_reference/utils/#wyvern.utils.Eval","text":"Class for code evaluation. Warning This class is not sandboxed so data like environmental variables will be evaluated when the methods gets executed as well. Source code in wyvern/utils.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 class Eval : \"\"\"Class for code evaluation. !!! warning This class is not sandboxed so data like environmental variables will be evaluated when the methods gets executed as well. \"\"\" def add_returns ( self , body : typing . Any ) -> None : if isinstance ( body [ - 1 ], ast . Expr ): body [ - 1 ] = ast . Return ( body [ - 1 ] . value ) ast . fix_missing_locations ( body [ - 1 ]) # for if statements, we insert returns into the body and the orelse if isinstance ( body [ - 1 ], ast . If ): self . add_returns ( body [ - 1 ] . body ) self . add_returns ( body [ - 1 ] . orelse ) # for with blocks, again we insert returns into the body if isinstance ( body [ - 1 ], ast . With ): self . add_returns ( body [ - 1 ] . body ) async def f_eval ( self , * , code : str , renv : dict [ str , typing . Any ]) -> typing . Any : \"\"\"Evaluates the code in the bot's namespace. Parameters ---------- code : str The code to evaluate. renv: dict[str, typing.Any] Environment to evaluate code in. Returns ------- typing.Any The result of the code. \"\"\" _fn_name = \"__wyvern_eval\" code = \" \\n \" . join ( f \" { i } \" for i in code . strip () . splitlines ()) parsed : typing . Any = ast . parse ( f \"async def { _fn_name } : \\n { code } \" ) self . add_returns ( parsed . body [ 0 ] . body ) exec ( compile ( parsed , filename = \"<ast>\" , mode = \"exec\" ), renv ) fn = renv [ _fn_name ] return await fn ()","title":"Eval"},{"location":"api_reference/utils/#wyvern.utils.Eval.f_eval","text":"Evaluates the code in the bot's namespace. Parameters: Name Type Description Default code str The code to evaluate. required renv dict [ str , typing . Any ] Environment to evaluate code in. required Returns: Type Description typing . Any The result of the code. Source code in wyvern/utils.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 async def f_eval ( self , * , code : str , renv : dict [ str , typing . Any ]) -> typing . Any : \"\"\"Evaluates the code in the bot's namespace. Parameters ---------- code : str The code to evaluate. renv: dict[str, typing.Any] Environment to evaluate code in. Returns ------- typing.Any The result of the code. \"\"\" _fn_name = \"__wyvern_eval\" code = \" \\n \" . join ( f \" { i } \" for i in code . strip () . splitlines ()) parsed : typing . Any = ast . parse ( f \"async def { _fn_name } : \\n { code } \" ) self . add_returns ( parsed . body [ 0 ] . body ) exec ( compile ( parsed , filename = \"<ast>\" , mode = \"exec\" ), renv ) fn = renv [ _fn_name ] return await fn ()","title":"f_eval()"},{"location":"api_reference/utils/#wyvern.utils.Hook","text":"Hooks for per-module setup. They can be loaded using GatewayClient.load_hooks Source code in wyvern/utils.py 95 96 97 98 99 100 101 102 103 104 105 @attrs . define class Hook : \"\"\"Hooks for per-module setup. They can be loaded using `GatewayClient.load_hooks`\"\"\" callback : typing . Callable [ ... , typing . Any ] \"\"\"Callback of the hook.\"\"\" name : str \"\"\"Name of the hook.\"\"\" def __call__ ( self , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : return self . callback ( * args , ** kwargs )","title":"Hook"},{"location":"api_reference/utils/#wyvern.utils.Hook.callback","text":"Callback of the hook.","title":"callback"},{"location":"api_reference/utils/#wyvern.utils.Hook.name","text":"Name of the hook.","title":"name"},{"location":"api_reference/utils/#wyvern.utils.as_hook","text":"Creates a wyvern.utils.Hook Parameters: Name Type Description Default name str Name of the hook. None Returns: Type Description wyvern . utils . Hook The hook that was created. Source code in wyvern/utils.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def as_hook ( name : str | None = None ) -> typing . Callable [ ... , Hook ]: \"\"\"Creates a [wyvern.utils.Hook][] Parameters ---------- name : str Name of the hook. Returns ------- wyvern.utils.Hook The hook that was created. \"\"\" def inner ( callback : typing . Callable [ ... , typing . Any ]) -> Hook : return Hook ( callback , name or callback . __name__ ) return inner","title":"as_hook()"},{"location":"api_reference/utils/#wyvern.utils.create_timestamp","text":"Creates an UNIX timestamp for provided datetime or timedelta object. Parameters: Name Type Description Default dt datetime . datetime | datetime . timedelta The datetime or timedelta to convert. required Returns: Type Description str The UNIX timestamp. Source code in wyvern/utils.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 def create_timestamp ( dt : datetime . datetime | datetime . timedelta , * , style : str = \"t\" ) -> str : \"\"\"Creates an UNIX timestamp for provided datetime or timedelta object. Parameters ---------- dt : datetime.datetime | datetime.timedelta The datetime or timedelta to convert. Returns ------- str The UNIX timestamp. \"\"\" if isinstance ( dt , datetime . timedelta ): dt = datetime . datetime . utcnow () + dt return f \"<t: { int ( dt . timestamp ()) } : { style } >\"","title":"create_timestamp()"},{"location":"api_reference/utils/#wyvern.utils.get_arg_count","text":"Counts the number of args in a callable. Parameters: Name Type Description Default callable typing . Callable [..., typing . Any ] The callable to get arg count of. required Returns: Type Description int Number of arguments in a callable. Source code in wyvern/utils.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 def get_arg_count ( callable : typing . Callable [ ... , typing . Any ]) -> int : \"\"\"Counts the number of args in a callable. Parameters ---------- callable : typing.Callable[..., typing.Any] The callable to get arg count of. Returns ------- int Number of arguments in a callable. \"\"\" return len ( inspect . getargs ( callable . __code__ ) . args )","title":"get_arg_count()"},{"location":"api_reference/components/base/","text":"ButtonStyle Bases: enum . IntEnum Enums for Button style. Source code in wyvern/components/base.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class ButtonStyle ( enum . IntEnum ): \"\"\"Enums for Button style.\"\"\" PRIMARY = 1 \"\"\"A primary blurple discord button.\"\"\" SECONDARY = 2 \"\"\"A secondary gray discord button.\"\"\" SUCCESS = 3 \"\"\"Green discord button.\"\"\" DANGER = 4 \"\"\"Red discord button.\"\"\" LINK = 5 \"\"\"Button pointing to an URL\"\"\" BLURPLE = PRIMARY \"\"\"Alias for PRIMARY\"\"\" GRAY = SECONDARY \"\"\"Alias for SECONDARY\"\"\" GREY = SECONDARY \"\"\"Alias for SECONDARY\"\"\" GREEN = SUCCESS \"\"\"Alias for SUCCESS\"\"\" RED = DANGER \"\"\"Alias for DANGER\"\"\" URL = LINK \"\"\"Alias for LINK\"\"\" BLURPLE = PRIMARY class-attribute Alias for PRIMARY DANGER = 4 class-attribute Red discord button. GRAY = SECONDARY class-attribute Alias for SECONDARY GREEN = SUCCESS class-attribute Alias for SUCCESS GREY = SECONDARY class-attribute Alias for SECONDARY LINK = 5 class-attribute Button pointing to an URL PRIMARY = 1 class-attribute A primary blurple discord button. RED = DANGER class-attribute Alias for DANGER SECONDARY = 2 class-attribute A secondary gray discord button. SUCCESS = 3 class-attribute Green discord button. URL = LINK class-attribute Alias for LINK Component Bases: abc . ABC Represents a discord component. Is the base class for other components. Source code in wyvern/components/base.py 70 71 72 73 74 75 class Component ( abc . ABC ): \"\"\"Represents a discord component. Is the base class for other components.\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return {}","title":"base"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle","text":"Bases: enum . IntEnum Enums for Button style. Source code in wyvern/components/base.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 class ButtonStyle ( enum . IntEnum ): \"\"\"Enums for Button style.\"\"\" PRIMARY = 1 \"\"\"A primary blurple discord button.\"\"\" SECONDARY = 2 \"\"\"A secondary gray discord button.\"\"\" SUCCESS = 3 \"\"\"Green discord button.\"\"\" DANGER = 4 \"\"\"Red discord button.\"\"\" LINK = 5 \"\"\"Button pointing to an URL\"\"\" BLURPLE = PRIMARY \"\"\"Alias for PRIMARY\"\"\" GRAY = SECONDARY \"\"\"Alias for SECONDARY\"\"\" GREY = SECONDARY \"\"\"Alias for SECONDARY\"\"\" GREEN = SUCCESS \"\"\"Alias for SUCCESS\"\"\" RED = DANGER \"\"\"Alias for DANGER\"\"\" URL = LINK \"\"\"Alias for LINK\"\"\"","title":"ButtonStyle"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.BLURPLE","text":"Alias for PRIMARY","title":"BLURPLE"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.DANGER","text":"Red discord button.","title":"DANGER"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.GRAY","text":"Alias for SECONDARY","title":"GRAY"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.GREEN","text":"Alias for SUCCESS","title":"GREEN"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.GREY","text":"Alias for SECONDARY","title":"GREY"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.LINK","text":"Button pointing to an URL","title":"LINK"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.PRIMARY","text":"A primary blurple discord button.","title":"PRIMARY"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.RED","text":"Alias for DANGER","title":"RED"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.SECONDARY","text":"A secondary gray discord button.","title":"SECONDARY"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.SUCCESS","text":"Green discord button.","title":"SUCCESS"},{"location":"api_reference/components/base/#wyvern.components.base.ButtonStyle.URL","text":"Alias for LINK","title":"URL"},{"location":"api_reference/components/base/#wyvern.components.base.Component","text":"Bases: abc . ABC Represents a discord component. Is the base class for other components. Source code in wyvern/components/base.py 70 71 72 73 74 75 class Component ( abc . ABC ): \"\"\"Represents a discord component. Is the base class for other components.\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return {}","title":"Component"},{"location":"api_reference/components/buttons/","text":"Button Bases: Component Represents a discord button. The properties mentioned below can be used to create a button. Source code in wyvern/components/buttons.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @attrs . define ( kw_only = True , slots = True , repr = True ) class Button ( Component ): \"\"\"Represents a discord button. The properties mentioned below can be used to create a button. \"\"\" style : ButtonStyle = ButtonStyle . SECONDARY \"\"\"Style of the button.\"\"\" label : str | None = None \"\"\"Button's label.\"\"\" emoji : str | \"CustomEmoji\" | None = None \"\"\"Emoji embedded in the button.\"\"\" custom_id : str | None = None \"\"\"Custom id for the component.\"\"\" disabled : bool = False \"\"\"True if the component is disabled.\"\"\" url : str | None = None \"\"\"The URL this button points to, if any.\"\"\" type : ComponentType = ComponentType . BUTTON def to_payload ( self ) -> dict [ str , typing . Any ]: payload : dict [ str , typing . Any ] = { \"type\" : int ( self . type ), \"style\" : int ( self . style ), \"label\" : self . label , \"custom_id\" : self . custom_id or \"wyvern.NO_CUSTOM_ID\" , \"disabled\" : self . disabled , \"url\" : self . url , } if self . emoji is not None : payload [ \"emoji\" ] = ( { \"name\" : self . emoji } if ( not isinstance ( self . emoji , CustomEmoji )) else { \"name\" : self . emoji . name , \"id\" : self . emoji . id , \"animated\" : self . emoji . is_animated } ) return payload custom_id : str | None = None class-attribute Custom id for the component. disabled : bool = False class-attribute True if the component is disabled. emoji : str | CustomEmoji | None = None class-attribute Emoji embedded in the button. label : str | None = None class-attribute Button's label. style : ButtonStyle = ButtonStyle . SECONDARY class-attribute Style of the button. url : str | None = None class-attribute The URL this button points to, if any.","title":"buttons"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button","text":"Bases: Component Represents a discord button. The properties mentioned below can be used to create a button. Source code in wyvern/components/buttons.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @attrs . define ( kw_only = True , slots = True , repr = True ) class Button ( Component ): \"\"\"Represents a discord button. The properties mentioned below can be used to create a button. \"\"\" style : ButtonStyle = ButtonStyle . SECONDARY \"\"\"Style of the button.\"\"\" label : str | None = None \"\"\"Button's label.\"\"\" emoji : str | \"CustomEmoji\" | None = None \"\"\"Emoji embedded in the button.\"\"\" custom_id : str | None = None \"\"\"Custom id for the component.\"\"\" disabled : bool = False \"\"\"True if the component is disabled.\"\"\" url : str | None = None \"\"\"The URL this button points to, if any.\"\"\" type : ComponentType = ComponentType . BUTTON def to_payload ( self ) -> dict [ str , typing . Any ]: payload : dict [ str , typing . Any ] = { \"type\" : int ( self . type ), \"style\" : int ( self . style ), \"label\" : self . label , \"custom_id\" : self . custom_id or \"wyvern.NO_CUSTOM_ID\" , \"disabled\" : self . disabled , \"url\" : self . url , } if self . emoji is not None : payload [ \"emoji\" ] = ( { \"name\" : self . emoji } if ( not isinstance ( self . emoji , CustomEmoji )) else { \"name\" : self . emoji . name , \"id\" : self . emoji . id , \"animated\" : self . emoji . is_animated } ) return payload","title":"Button"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button.custom_id","text":"Custom id for the component.","title":"custom_id"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button.disabled","text":"True if the component is disabled.","title":"disabled"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button.emoji","text":"Emoji embedded in the button.","title":"emoji"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button.label","text":"Button's label.","title":"label"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button.style","text":"Style of the button.","title":"style"},{"location":"api_reference/components/buttons/#wyvern.components.buttons.Button.url","text":"The URL this button points to, if any.","title":"url"},{"location":"api_reference/components/container/","text":"ActionRowContainer Bases: Component Interface to create an Action Row. This class accepts and stores. other discord components. Source code in wyvern/components/container.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class ActionRowContainer ( Component ): \"\"\"Interface to create an Action Row. This class accepts and stores. other discord components. \"\"\" type = ComponentType . ACTION_ROW items : list [ Component ] = [] \"\"\"List of items stored in the container.\"\"\" def __init__ ( self , * items : Component ) -> None : for item in items : self . items . append ( item ) super () . __init__ () def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"type\" : int ( self . type ), \"components\" : [ item . to_payload () for item in self . items ]} def add_select ( self , * , type : SelectType = SelectType . STRING , custom_id : str , options : typing . Sequence [ SelectOption ] = (), channel_types : typing . Sequence [ ChannelType ] = (), min_values : int | None = None , max_values : int | None = None , disabled : bool = False , ) -> Select : \"\"\"Adds a select menu to the container. Parameters ---------- type: SelectType Type of the select custom_id: str Custom ID of the select. options: list[SelectOption] Options attached to the select. channel_types: list[ChannelType] | None Channel types for CHANNEL type select. min_values: int | None Minimum selections max_values: int | None Maximum selections disabled: bool True if the select is disabled. Returns ------- Select The select that was created. \"\"\" self . items . append ( select := Select ( type = type , custom_id = custom_id , options = list ( options ), channel_types = list ( channel_types ), min_values = min_values , max_values = max_values , disabled = disabled , ) ) return select def add_button ( self , * , style : ButtonStyle = ButtonStyle . SECONDARY , label : str | None = None , emoji : str | CustomEmoji | None = None , custom_id : str | None = None , disabled : bool = False , url : str | None = None , ) -> Button : \"\"\"Adds a button to the container. Parameters ---------- style : wyvern.components.base.ButtonStyle The style of button. label : str | None Button's label. emoji : str | wyvern.models.emojis.CustomEmoji A unicode emoji or a custom one. custom_id : str A custom id set to the button. disabled : bool Set this to [True][] to disable clicks on button. url : str The URL this button points to. Returns ------- wyvern.components.buttons.Button The button that was created. \"\"\" self . items . append ( button := Button ( type = ComponentType . BUTTON , style = style , label = label , emoji = emoji , custom_id = custom_id , disabled = disabled , url = url , ) ) return button items : list [ Component ] = [] class-attribute List of items stored in the container. add_button ( * , style = ButtonStyle . SECONDARY , label = None , emoji = None , custom_id = None , disabled = False , url = None ) Adds a button to the container. Parameters: Name Type Description Default style wyvern . components . base . ButtonStyle The style of button. ButtonStyle.SECONDARY label str | None Button's label. None emoji str | wyvern . models . emojis . CustomEmoji A unicode emoji or a custom one. None custom_id str A custom id set to the button. None disabled bool Set this to True to disable clicks on button. False url str The URL this button points to. None Returns: Type Description wyvern . components . buttons . Button The button that was created. Source code in wyvern/components/container.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def add_button ( self , * , style : ButtonStyle = ButtonStyle . SECONDARY , label : str | None = None , emoji : str | CustomEmoji | None = None , custom_id : str | None = None , disabled : bool = False , url : str | None = None , ) -> Button : \"\"\"Adds a button to the container. Parameters ---------- style : wyvern.components.base.ButtonStyle The style of button. label : str | None Button's label. emoji : str | wyvern.models.emojis.CustomEmoji A unicode emoji or a custom one. custom_id : str A custom id set to the button. disabled : bool Set this to [True][] to disable clicks on button. url : str The URL this button points to. Returns ------- wyvern.components.buttons.Button The button that was created. \"\"\" self . items . append ( button := Button ( type = ComponentType . BUTTON , style = style , label = label , emoji = emoji , custom_id = custom_id , disabled = disabled , url = url , ) ) return button add_select ( * , type = SelectType . STRING , custom_id , options = (), channel_types = (), min_values = None , max_values = None , disabled = False ) Adds a select menu to the container. Parameters: Name Type Description Default type SelectType Type of the select SelectType.STRING custom_id str Custom ID of the select. required options typing . Sequence [ SelectOption ] Options attached to the select. () channel_types typing . Sequence [ ChannelType ] Channel types for CHANNEL type select. () min_values int | None Minimum selections None max_values int | None Maximum selections None disabled bool True if the select is disabled. False Returns: Type Description Select The select that was created. Source code in wyvern/components/container.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def add_select ( self , * , type : SelectType = SelectType . STRING , custom_id : str , options : typing . Sequence [ SelectOption ] = (), channel_types : typing . Sequence [ ChannelType ] = (), min_values : int | None = None , max_values : int | None = None , disabled : bool = False , ) -> Select : \"\"\"Adds a select menu to the container. Parameters ---------- type: SelectType Type of the select custom_id: str Custom ID of the select. options: list[SelectOption] Options attached to the select. channel_types: list[ChannelType] | None Channel types for CHANNEL type select. min_values: int | None Minimum selections max_values: int | None Maximum selections disabled: bool True if the select is disabled. Returns ------- Select The select that was created. \"\"\" self . items . append ( select := Select ( type = type , custom_id = custom_id , options = list ( options ), channel_types = list ( channel_types ), min_values = min_values , max_values = max_values , disabled = disabled , ) ) return select","title":"container"},{"location":"api_reference/components/container/#wyvern.components.container.ActionRowContainer","text":"Bases: Component Interface to create an Action Row. This class accepts and stores. other discord components. Source code in wyvern/components/container.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 class ActionRowContainer ( Component ): \"\"\"Interface to create an Action Row. This class accepts and stores. other discord components. \"\"\" type = ComponentType . ACTION_ROW items : list [ Component ] = [] \"\"\"List of items stored in the container.\"\"\" def __init__ ( self , * items : Component ) -> None : for item in items : self . items . append ( item ) super () . __init__ () def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"type\" : int ( self . type ), \"components\" : [ item . to_payload () for item in self . items ]} def add_select ( self , * , type : SelectType = SelectType . STRING , custom_id : str , options : typing . Sequence [ SelectOption ] = (), channel_types : typing . Sequence [ ChannelType ] = (), min_values : int | None = None , max_values : int | None = None , disabled : bool = False , ) -> Select : \"\"\"Adds a select menu to the container. Parameters ---------- type: SelectType Type of the select custom_id: str Custom ID of the select. options: list[SelectOption] Options attached to the select. channel_types: list[ChannelType] | None Channel types for CHANNEL type select. min_values: int | None Minimum selections max_values: int | None Maximum selections disabled: bool True if the select is disabled. Returns ------- Select The select that was created. \"\"\" self . items . append ( select := Select ( type = type , custom_id = custom_id , options = list ( options ), channel_types = list ( channel_types ), min_values = min_values , max_values = max_values , disabled = disabled , ) ) return select def add_button ( self , * , style : ButtonStyle = ButtonStyle . SECONDARY , label : str | None = None , emoji : str | CustomEmoji | None = None , custom_id : str | None = None , disabled : bool = False , url : str | None = None , ) -> Button : \"\"\"Adds a button to the container. Parameters ---------- style : wyvern.components.base.ButtonStyle The style of button. label : str | None Button's label. emoji : str | wyvern.models.emojis.CustomEmoji A unicode emoji or a custom one. custom_id : str A custom id set to the button. disabled : bool Set this to [True][] to disable clicks on button. url : str The URL this button points to. Returns ------- wyvern.components.buttons.Button The button that was created. \"\"\" self . items . append ( button := Button ( type = ComponentType . BUTTON , style = style , label = label , emoji = emoji , custom_id = custom_id , disabled = disabled , url = url , ) ) return button","title":"ActionRowContainer"},{"location":"api_reference/components/container/#wyvern.components.container.ActionRowContainer.items","text":"List of items stored in the container.","title":"items"},{"location":"api_reference/components/container/#wyvern.components.container.ActionRowContainer.add_button","text":"Adds a button to the container. Parameters: Name Type Description Default style wyvern . components . base . ButtonStyle The style of button. ButtonStyle.SECONDARY label str | None Button's label. None emoji str | wyvern . models . emojis . CustomEmoji A unicode emoji or a custom one. None custom_id str A custom id set to the button. None disabled bool Set this to True to disable clicks on button. False url str The URL this button points to. None Returns: Type Description wyvern . components . buttons . Button The button that was created. Source code in wyvern/components/container.py 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def add_button ( self , * , style : ButtonStyle = ButtonStyle . SECONDARY , label : str | None = None , emoji : str | CustomEmoji | None = None , custom_id : str | None = None , disabled : bool = False , url : str | None = None , ) -> Button : \"\"\"Adds a button to the container. Parameters ---------- style : wyvern.components.base.ButtonStyle The style of button. label : str | None Button's label. emoji : str | wyvern.models.emojis.CustomEmoji A unicode emoji or a custom one. custom_id : str A custom id set to the button. disabled : bool Set this to [True][] to disable clicks on button. url : str The URL this button points to. Returns ------- wyvern.components.buttons.Button The button that was created. \"\"\" self . items . append ( button := Button ( type = ComponentType . BUTTON , style = style , label = label , emoji = emoji , custom_id = custom_id , disabled = disabled , url = url , ) ) return button","title":"add_button()"},{"location":"api_reference/components/container/#wyvern.components.container.ActionRowContainer.add_select","text":"Adds a select menu to the container. Parameters: Name Type Description Default type SelectType Type of the select SelectType.STRING custom_id str Custom ID of the select. required options typing . Sequence [ SelectOption ] Options attached to the select. () channel_types typing . Sequence [ ChannelType ] Channel types for CHANNEL type select. () min_values int | None Minimum selections None max_values int | None Maximum selections None disabled bool True if the select is disabled. False Returns: Type Description Select The select that was created. Source code in wyvern/components/container.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def add_select ( self , * , type : SelectType = SelectType . STRING , custom_id : str , options : typing . Sequence [ SelectOption ] = (), channel_types : typing . Sequence [ ChannelType ] = (), min_values : int | None = None , max_values : int | None = None , disabled : bool = False , ) -> Select : \"\"\"Adds a select menu to the container. Parameters ---------- type: SelectType Type of the select custom_id: str Custom ID of the select. options: list[SelectOption] Options attached to the select. channel_types: list[ChannelType] | None Channel types for CHANNEL type select. min_values: int | None Minimum selections max_values: int | None Maximum selections disabled: bool True if the select is disabled. Returns ------- Select The select that was created. \"\"\" self . items . append ( select := Select ( type = type , custom_id = custom_id , options = list ( options ), channel_types = list ( channel_types ), min_values = min_values , max_values = max_values , disabled = disabled , ) ) return select","title":"add_select()"},{"location":"api_reference/components/modals/","text":"Modal Represents a discord modal form. Source code in wyvern/components/modals.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @attrs . define ( kw_only = True , slots = True ) class Modal : \"\"\"Represents a discord modal form.\"\"\" title : str \"\"\"Title of the modal.\"\"\" custom_id : str \"\"\"Custom ID of the modal\"\"\" text_inputs : list [ TextInput ] = [] \"\"\"A list of [TextInputs] to use in the modal.\"\"\" def add_item ( self , text_input : TextInput ) -> None : \"\"\"Method to add a textinput to the Modal.\"\"\" self . text_inputs . append ( text_input ) custom_id : str class-attribute Custom ID of the modal text_inputs : list [ TextInput ] = [] class-attribute A list of [TextInputs] to use in the modal. title : str class-attribute Title of the modal. add_item ( text_input ) Method to add a textinput to the Modal. Source code in wyvern/components/modals.py 89 90 91 def add_item ( self , text_input : TextInput ) -> None : \"\"\"Method to add a textinput to the Modal.\"\"\" self . text_inputs . append ( text_input ) TextInput Bases: Component Represents a modal text-input. Source code in wyvern/components/modals.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @typing . final @attrs . define ( kw_only = True , slots = True , repr = True ) class TextInput ( Component ): \"\"\"Represents a modal text-input.\"\"\" type : ComponentType = ComponentType . TEXT_INPUT custom_id : str \"\"\"Custom id of the textinput.\"\"\" label : str \"\"\"Label of the textinput.\"\"\" style : TextInputStyle = TextInputStyle . SHORT \"\"\"Textinput style.\"\"\" min_length : int | None = None \"\"\"The maximum allowed length for textinput.\"\"\" max_length : int | None = None \"\"\"The minimum allowed length for textinput.\"\"\" required : bool = True \"\"\"Weather the field is required.\"\"\" default_value : str | None = None \"\"\"Default value for this textinput.\"\"\" placeholder : str | None = None \"\"\"The placeholder to use, if any.\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"type\" : int ( self . type ), \"custom_id\" : self . custom_id , \"label\" : self . label , \"style\" : int ( self . style ), \"min_length\" : self . min_length , \"max_length\" : self . max_length , \"required\" : self . required , \"value\" : self . default_value , \"placeholder\" : self . placeholder , } custom_id : str class-attribute Custom id of the textinput. default_value : str | None = None class-attribute Default value for this textinput. label : str class-attribute Label of the textinput. max_length : int | None = None class-attribute The minimum allowed length for textinput. min_length : int | None = None class-attribute The maximum allowed length for textinput. placeholder : str | None = None class-attribute The placeholder to use, if any. required : bool = True class-attribute Weather the field is required. style : TextInputStyle = TextInputStyle . SHORT class-attribute Textinput style. TextInputStyle Bases: enum . IntFlag Source code in wyvern/components/modals.py 34 35 36 37 38 class TextInputStyle ( enum . IntFlag ): SHORT = 1 \"\"\"For single line text-inputs.\"\"\" PARAGRAPH = 2 \"\"\"For multi line text-inputs.\"\"\" PARAGRAPH = 2 class-attribute For multi line text-inputs. SHORT = 1 class-attribute For single line text-inputs.","title":"modals"},{"location":"api_reference/components/modals/#wyvern.components.modals.Modal","text":"Represents a discord modal form. Source code in wyvern/components/modals.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @attrs . define ( kw_only = True , slots = True ) class Modal : \"\"\"Represents a discord modal form.\"\"\" title : str \"\"\"Title of the modal.\"\"\" custom_id : str \"\"\"Custom ID of the modal\"\"\" text_inputs : list [ TextInput ] = [] \"\"\"A list of [TextInputs] to use in the modal.\"\"\" def add_item ( self , text_input : TextInput ) -> None : \"\"\"Method to add a textinput to the Modal.\"\"\" self . text_inputs . append ( text_input )","title":"Modal"},{"location":"api_reference/components/modals/#wyvern.components.modals.Modal.custom_id","text":"Custom ID of the modal","title":"custom_id"},{"location":"api_reference/components/modals/#wyvern.components.modals.Modal.text_inputs","text":"A list of [TextInputs] to use in the modal.","title":"text_inputs"},{"location":"api_reference/components/modals/#wyvern.components.modals.Modal.title","text":"Title of the modal.","title":"title"},{"location":"api_reference/components/modals/#wyvern.components.modals.Modal.add_item","text":"Method to add a textinput to the Modal. Source code in wyvern/components/modals.py 89 90 91 def add_item ( self , text_input : TextInput ) -> None : \"\"\"Method to add a textinput to the Modal.\"\"\" self . text_inputs . append ( text_input )","title":"add_item()"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput","text":"Bases: Component Represents a modal text-input. Source code in wyvern/components/modals.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 @typing . final @attrs . define ( kw_only = True , slots = True , repr = True ) class TextInput ( Component ): \"\"\"Represents a modal text-input.\"\"\" type : ComponentType = ComponentType . TEXT_INPUT custom_id : str \"\"\"Custom id of the textinput.\"\"\" label : str \"\"\"Label of the textinput.\"\"\" style : TextInputStyle = TextInputStyle . SHORT \"\"\"Textinput style.\"\"\" min_length : int | None = None \"\"\"The maximum allowed length for textinput.\"\"\" max_length : int | None = None \"\"\"The minimum allowed length for textinput.\"\"\" required : bool = True \"\"\"Weather the field is required.\"\"\" default_value : str | None = None \"\"\"Default value for this textinput.\"\"\" placeholder : str | None = None \"\"\"The placeholder to use, if any.\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"type\" : int ( self . type ), \"custom_id\" : self . custom_id , \"label\" : self . label , \"style\" : int ( self . style ), \"min_length\" : self . min_length , \"max_length\" : self . max_length , \"required\" : self . required , \"value\" : self . default_value , \"placeholder\" : self . placeholder , }","title":"TextInput"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.custom_id","text":"Custom id of the textinput.","title":"custom_id"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.default_value","text":"Default value for this textinput.","title":"default_value"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.label","text":"Label of the textinput.","title":"label"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.max_length","text":"The minimum allowed length for textinput.","title":"max_length"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.min_length","text":"The maximum allowed length for textinput.","title":"min_length"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.placeholder","text":"The placeholder to use, if any.","title":"placeholder"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.required","text":"Weather the field is required.","title":"required"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInput.style","text":"Textinput style.","title":"style"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInputStyle","text":"Bases: enum . IntFlag Source code in wyvern/components/modals.py 34 35 36 37 38 class TextInputStyle ( enum . IntFlag ): SHORT = 1 \"\"\"For single line text-inputs.\"\"\" PARAGRAPH = 2 \"\"\"For multi line text-inputs.\"\"\"","title":"TextInputStyle"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInputStyle.PARAGRAPH","text":"For multi line text-inputs.","title":"PARAGRAPH"},{"location":"api_reference/components/modals/#wyvern.components.modals.TextInputStyle.SHORT","text":"For single line text-inputs.","title":"SHORT"},{"location":"api_reference/components/selects/","text":"Select Bases: Component Represents a discord Select menu. Source code in wyvern/components/selects.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 @attrs . define ( kw_only = True , slots = True ) class Select ( Component ): \"\"\"Represents a discord Select menu.\"\"\" type : SelectType = SelectType . STRING \"\"\"Type of the select\"\"\" custom_id : str \"\"\"Custom ID of the select.\"\"\" options : list [ SelectOption ] = [] \"\"\"Options attached to the select.\"\"\" channel_types : list [ ChannelType ] | None = None \"\"\"Channel types for CHANNEL type select.\"\"\" min_values : int | None = None \"\"\"Minimum selections.\"\"\" max_values : int | None = None \"\"\"Maximum selections.\"\"\" disabled : bool = False \"\"\"True if the select is disabled.\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"type\" : self . type , \"custom_id\" : self . custom_id , \"options\" : [ opt . to_payload () for opt in self . options ], \"channel_types\" : self . channel_types , \"min_values\" : self . max_values , \"max_values\" : self . max_values , \"disabled\" : self . disabled , } channel_types : list [ ChannelType ] | None = None class-attribute Channel types for CHANNEL type select. custom_id : str class-attribute Custom ID of the select. disabled : bool = False class-attribute True if the select is disabled. max_values : int | None = None class-attribute Maximum selections. min_values : int | None = None class-attribute Minimum selections. options : list [ SelectOption ] = [] class-attribute Options attached to the select. type : SelectType = SelectType . STRING class-attribute Type of the select SelectOption Represents a Select option. Source code in wyvern/components/selects.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @attrs . define ( kw_only = True , slots = True ) class SelectOption : \"\"\"Represents a Select option.\"\"\" label : str \"\"\"Label of the option.\"\"\" _value : str | None = None \"\"\"Value of the option, defaults to the label.\"\"\" description : str | None \"\"\"Description of the option.\"\"\" emoji : str | CustomEmoji | None = None \"\"\"Emoji attached to the option.\"\"\" default : bool = False \"\"\"Set to `True` if the option is to be used as default.\"\"\" @property def value ( self ) -> str : return self . _value or self . label def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"label\" : self . label , \"value\" : self . value , \"description\" : self . description , \"emoji\" : str ( self . emoji ), \"default\" : self . default , } default : bool = False class-attribute Set to True if the option is to be used as default. description : str | None class-attribute Description of the option. emoji : str | CustomEmoji | None = None class-attribute Emoji attached to the option. label : str class-attribute Label of the option. SelectType Bases: enum . IntEnum Type of the select option Source code in wyvern/components/selects.py 39 40 41 42 43 44 45 46 47 48 49 50 51 class SelectType ( enum . IntEnum ): \"\"\"Type of the select option\"\"\" STRING = 3 \"\"\"String type select, this requires the `options` kwarg in the [Select][] class.\"\"\" USER = 5 \"\"\"User type select menu.\"\"\" ROLE = 6 \"\"\"Role type select menu.\"\"\" MENTIONABLE = 7 \"\"\"Mentionable type select menu.\"\"\" CHANNEL = 8 \"\"\"Channel type select menu.\"\"\" CHANNEL = 8 class-attribute Channel type select menu. MENTIONABLE = 7 class-attribute Mentionable type select menu. ROLE = 6 class-attribute Role type select menu. STRING = 3 class-attribute String type select, this requires the options kwarg in the Select class. USER = 5 class-attribute User type select menu.","title":"selects"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select","text":"Bases: Component Represents a discord Select menu. Source code in wyvern/components/selects.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 @attrs . define ( kw_only = True , slots = True ) class Select ( Component ): \"\"\"Represents a discord Select menu.\"\"\" type : SelectType = SelectType . STRING \"\"\"Type of the select\"\"\" custom_id : str \"\"\"Custom ID of the select.\"\"\" options : list [ SelectOption ] = [] \"\"\"Options attached to the select.\"\"\" channel_types : list [ ChannelType ] | None = None \"\"\"Channel types for CHANNEL type select.\"\"\" min_values : int | None = None \"\"\"Minimum selections.\"\"\" max_values : int | None = None \"\"\"Maximum selections.\"\"\" disabled : bool = False \"\"\"True if the select is disabled.\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"type\" : self . type , \"custom_id\" : self . custom_id , \"options\" : [ opt . to_payload () for opt in self . options ], \"channel_types\" : self . channel_types , \"min_values\" : self . max_values , \"max_values\" : self . max_values , \"disabled\" : self . disabled , }","title":"Select"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.channel_types","text":"Channel types for CHANNEL type select.","title":"channel_types"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.custom_id","text":"Custom ID of the select.","title":"custom_id"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.disabled","text":"True if the select is disabled.","title":"disabled"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.max_values","text":"Maximum selections.","title":"max_values"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.min_values","text":"Minimum selections.","title":"min_values"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.options","text":"Options attached to the select.","title":"options"},{"location":"api_reference/components/selects/#wyvern.components.selects.Select.type","text":"Type of the select","title":"type"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectOption","text":"Represents a Select option. Source code in wyvern/components/selects.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 @attrs . define ( kw_only = True , slots = True ) class SelectOption : \"\"\"Represents a Select option.\"\"\" label : str \"\"\"Label of the option.\"\"\" _value : str | None = None \"\"\"Value of the option, defaults to the label.\"\"\" description : str | None \"\"\"Description of the option.\"\"\" emoji : str | CustomEmoji | None = None \"\"\"Emoji attached to the option.\"\"\" default : bool = False \"\"\"Set to `True` if the option is to be used as default.\"\"\" @property def value ( self ) -> str : return self . _value or self . label def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"label\" : self . label , \"value\" : self . value , \"description\" : self . description , \"emoji\" : str ( self . emoji ), \"default\" : self . default , }","title":"SelectOption"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectOption.default","text":"Set to True if the option is to be used as default.","title":"default"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectOption.description","text":"Description of the option.","title":"description"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectOption.emoji","text":"Emoji attached to the option.","title":"emoji"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectOption.label","text":"Label of the option.","title":"label"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectType","text":"Bases: enum . IntEnum Type of the select option Source code in wyvern/components/selects.py 39 40 41 42 43 44 45 46 47 48 49 50 51 class SelectType ( enum . IntEnum ): \"\"\"Type of the select option\"\"\" STRING = 3 \"\"\"String type select, this requires the `options` kwarg in the [Select][] class.\"\"\" USER = 5 \"\"\"User type select menu.\"\"\" ROLE = 6 \"\"\"Role type select menu.\"\"\" MENTIONABLE = 7 \"\"\"Mentionable type select menu.\"\"\" CHANNEL = 8 \"\"\"Channel type select menu.\"\"\"","title":"SelectType"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectType.CHANNEL","text":"Channel type select menu.","title":"CHANNEL"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectType.MENTIONABLE","text":"Mentionable type select menu.","title":"MENTIONABLE"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectType.ROLE","text":"Role type select menu.","title":"ROLE"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectType.STRING","text":"String type select, this requires the options kwarg in the Select class.","title":"STRING"},{"location":"api_reference/components/selects/#wyvern.components.selects.SelectType.USER","text":"User type select menu.","title":"USER"},{"location":"api_reference/constructors/embeds/","text":"Embed Read-only Embed class returned while parsing message objects. To create a sendable embed, use wyvern.constructors.embeds.EmbedConstructor instead. Source code in wyvern/constructors/embeds.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 @typing . final @attrs . define ( slots = True , kw_only = True , eq = True , repr = True ) class Embed : \"\"\" Read-only Embed class returned while parsing message objects. To create a sendable embed, use [wyvern.constructors.embeds.EmbedConstructor][] instead. \"\"\" payload : dict [ str , typing . Any ] \"\"\"The raw payload.\"\"\" title : str | None = None \"\"\"Title of the embed.\"\"\" description : str | None = None \"\"\"Description fo the embed\"\"\" url : str | None = None \"\"\"URL of the embed\"\"\" color : int = 0 \"\"\"Color of the embed.\"\"\" timestamp : datetime . datetime | None = None \"\"\"Timestamp of the embed.\"\"\" colour = color \"\"\"Alias for color.\"\"\" fields : list [ EmbedField ] = [] \"\"\"List of fields related to this embed.\"\"\" author : EmbedAuthor | None = None \"\"\"Author of the embed.\"\"\" footer : EmbedFooter | None = None \"\"\"Footer of the embed.\"\"\" def to_constructor ( self ) -> EmbedConstructor : embed = EmbedConstructor () embed . _payload = self . payload return embed @classmethod def from_payload ( cls , payload : dict [ str , typing . Any ]) -> \"Embed\" : const = EmbedConstructor () const . _payload = payload return const . build () author : EmbedAuthor | None = None class-attribute Author of the embed. color : int = 0 class-attribute Color of the embed. colour = color class-attribute Alias for color. description : str | None = None class-attribute Description fo the embed fields : list [ EmbedField ] = [] class-attribute List of fields related to this embed. footer : EmbedFooter | None = None class-attribute Footer of the embed. payload : dict [ str , typing . Any ] class-attribute The raw payload. timestamp : datetime . datetime | None = None class-attribute Timestamp of the embed. title : str | None = None class-attribute Title of the embed. url : str | None = None class-attribute URL of the embed EmbedAuthor Represents an embed author. Source code in wyvern/constructors/embeds.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @typing . final @attrs . define ( slots = True ) class EmbedAuthor : \"\"\"Represents an embed author.\"\"\" name : str \"\"\"Name of the author.\"\"\" url : str | None = None \"\"\"URL that the author points to.\"\"\" icon_url : str | None = None \"\"\"URL of the author icon\"\"\" proxy_icon_url : str | None = None \"\"\"Proxy URL of icon.\"\"\" def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the author to its payload.\"\"\" return { \"name\" : self . name , \"url\" : self . url , \"icon_url\" : self . icon_url } icon_url : str | None = None class-attribute URL of the author icon name : str class-attribute Name of the author. proxy_icon_url : str | None = None class-attribute Proxy URL of icon. url : str | None = None class-attribute URL that the author points to. to_payload () Converts the author to its payload. Source code in wyvern/constructors/embeds.py 49 50 51 def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the author to its payload.\"\"\" return { \"name\" : self . name , \"url\" : self . url , \"icon_url\" : self . icon_url } EmbedConstructor Creates an sendable discord embed. Parameters: Name Type Description Default title str Name of the embed. None description str Description of the embed None color int Color of the embed. 0 url str URL which the title points to. None timestamp datetime . datetime Timestamp to put in the embed. None Source code in wyvern/constructors/embeds.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class EmbedConstructor : \"\"\" Creates an sendable discord embed. Parameters ---------- title : str Name of the embed. description : str Description of the embed color : int Color of the embed. url : str URL which the title points to. timestamp : datetime.datetime Timestamp to put in the embed. \"\"\" __slots__ : tuple [ str , ... ] = ( \"_payload\" ,) def __init__ ( self , * , title : str | None = None , description : str | None = None , color : int = 0 , colour : int = 0 , url : str | None = None , timestamp : datetime . datetime | None = None , ) -> None : self . _payload : dict [ str , typing . Any ] = { \"type\" : \"rich\" , \"fields\" : [], \"title\" : title , \"description\" : description , \"color\" : color or colour , \"url\" : url , \"timestamp\" : int ( timestamp . timestamp ()) if isinstance ( timestamp , datetime . datetime ) else None , } def add_field ( self , * , name : str , value : str , inline : bool = True ) -> \"EmbedConstructor\" : \"\"\"Adds a field to the embed. Parameters ---------- name: str Name of the field. value: str Value of the filed inline: bool Weather the field is inline or not, defaults to [True][] Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" field = EmbedField ( name , value , inline ) self . _payload [ \"fields\" ] . append ( field . to_payload ()) return self def set_author ( self , * , name : str , url : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the author for the embed. Parameters ---------- name: str Name of the author field. url: str The URL author points to. icon_url: str URL for image to embed in the author. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" author = EmbedAuthor ( name , url , icon_url ) self . _payload [ \"author\" ] = author . to_payload () return self def set_footer ( self , * , text : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the footer for the embed. Parameters ---------- text: str The text to appear in the footer icon_url: str URL for image to embed in the footer. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" footer = EmbedFooter ( text , icon_url ) self . _payload [ \"footer\" ] = footer . to_payload () return self def edit_init ( self , * , title : str | None | utils . Empty = utils . EMPTY , description : str | None | utils . Empty = utils . EMPTY , color : int | utils . Empty = utils . EMPTY , colour : int | utils . Empty = utils . EMPTY , url : str | None | utils . Empty = utils . EMPTY , timestamp : datetime . datetime | None | utils . Empty = utils . EMPTY , ) -> \"EmbedConstructor\" : if title != utils . EMPTY : self . _payload [ \"title\" ] = title if description != utils . EMPTY : self . _payload [ \"description\" ] = description if color != utils . EMPTY : self . _payload [ \"color\" ] = color if colour != utils . EMPTY : self . _payload [ \"color\" ] = colour if url != utils . EMPTY : self . _payload [ \"url\" ] = url if timestamp != utils . EMPTY : self . _payload [ \"timestamp\" ] = ( int ( timestamp . timestamp ()) if isinstance ( timestamp , datetime . datetime ) else None ) return self def build ( self ) -> \"Embed\" : return Embed ( payload = self . _payload , title = self . _payload . get ( \"title\" ), description = self . _payload . get ( \"description\" ), url = self . _payload . get ( \"url\" ), color = self . _payload . get ( \"color\" , 0 ), fields = [ EmbedField ( ** kargs . to_payload ()) for kargs in self . _payload . get ( \"fields\" , [])], author = self . _payload . get ( \"author\" ), footer = self . _payload . get ( \"footer\" ), ) add_field ( * , name , value , inline = True ) Adds a field to the embed. Parameters: Name Type Description Default name str Name of the field. required value str Value of the filed required inline bool Weather the field is inline or not, defaults to True True Returns: Type Description wyvern . constructors . embeds . EmbedConstructor The constructor. Source code in wyvern/constructors/embeds.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def add_field ( self , * , name : str , value : str , inline : bool = True ) -> \"EmbedConstructor\" : \"\"\"Adds a field to the embed. Parameters ---------- name: str Name of the field. value: str Value of the filed inline: bool Weather the field is inline or not, defaults to [True][] Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" field = EmbedField ( name , value , inline ) self . _payload [ \"fields\" ] . append ( field . to_payload ()) return self set_author ( * , name , url , icon_url = None ) Set's the author for the embed. Parameters: Name Type Description Default name str Name of the author field. required url str The URL author points to. required icon_url str | None URL for image to embed in the author. None Returns: Type Description wyvern . constructors . embeds . EmbedConstructor The constructor. Source code in wyvern/constructors/embeds.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def set_author ( self , * , name : str , url : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the author for the embed. Parameters ---------- name: str Name of the author field. url: str The URL author points to. icon_url: str URL for image to embed in the author. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" author = EmbedAuthor ( name , url , icon_url ) self . _payload [ \"author\" ] = author . to_payload () return self set_footer ( * , text , icon_url = None ) Set's the footer for the embed. Parameters: Name Type Description Default text str The text to appear in the footer required icon_url str | None URL for image to embed in the footer. None Returns: Type Description wyvern . constructors . embeds . EmbedConstructor The constructor. Source code in wyvern/constructors/embeds.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def set_footer ( self , * , text : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the footer for the embed. Parameters ---------- text: str The text to appear in the footer icon_url: str URL for image to embed in the footer. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" footer = EmbedFooter ( text , icon_url ) self . _payload [ \"footer\" ] = footer . to_payload () return self EmbedField Represnts an embed field. Source code in wyvern/constructors/embeds.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typing . final @attrs . define ( slots = True ) class EmbedField : \"\"\"Represnts an embed field.\"\"\" name : str \"\"\"Name of the field.\"\"\" value : str \"\"\"Value of the field.\"\"\" inline : bool = True \"\"\"Inline value for the file, defaults to True.\"\"\" def to_payload ( self ) -> dict [ str , str | bool ]: return { \"name\" : self . name , \"value\" : self . value , \"inline\" : self . inline } inline : bool = True class-attribute Inline value for the file, defaults to True. name : str class-attribute Name of the field. value : str class-attribute Value of the field. EmbedFooter Represents an embed footer Source code in wyvern/constructors/embeds.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @typing . final @attrs . define ( slots = True ) class EmbedFooter : \"\"\"Represents an embed footer\"\"\" text : str \"\"\"The text in the footer.\"\"\" icon_url : str | None = None \"\"\"URL of the footer icon.\"\"\" proxy_icon_url : str | None = None \"\"\"Proxy URL of the icon\"\"\" def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the footer to its payload.\"\"\" return { \"text\" : self . text , \"icon_url\" : self . icon_url } icon_url : str | None = None class-attribute URL of the footer icon. proxy_icon_url : str | None = None class-attribute Proxy URL of the icon text : str class-attribute The text in the footer. to_payload () Converts the footer to its payload. Source code in wyvern/constructors/embeds.py 66 67 68 def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the footer to its payload.\"\"\" return { \"text\" : self . text , \"icon_url\" : self . icon_url }","title":"embed"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed","text":"Read-only Embed class returned while parsing message objects. To create a sendable embed, use wyvern.constructors.embeds.EmbedConstructor instead. Source code in wyvern/constructors/embeds.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 @typing . final @attrs . define ( slots = True , kw_only = True , eq = True , repr = True ) class Embed : \"\"\" Read-only Embed class returned while parsing message objects. To create a sendable embed, use [wyvern.constructors.embeds.EmbedConstructor][] instead. \"\"\" payload : dict [ str , typing . Any ] \"\"\"The raw payload.\"\"\" title : str | None = None \"\"\"Title of the embed.\"\"\" description : str | None = None \"\"\"Description fo the embed\"\"\" url : str | None = None \"\"\"URL of the embed\"\"\" color : int = 0 \"\"\"Color of the embed.\"\"\" timestamp : datetime . datetime | None = None \"\"\"Timestamp of the embed.\"\"\" colour = color \"\"\"Alias for color.\"\"\" fields : list [ EmbedField ] = [] \"\"\"List of fields related to this embed.\"\"\" author : EmbedAuthor | None = None \"\"\"Author of the embed.\"\"\" footer : EmbedFooter | None = None \"\"\"Footer of the embed.\"\"\" def to_constructor ( self ) -> EmbedConstructor : embed = EmbedConstructor () embed . _payload = self . payload return embed @classmethod def from_payload ( cls , payload : dict [ str , typing . Any ]) -> \"Embed\" : const = EmbedConstructor () const . _payload = payload return const . build ()","title":"Embed"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.author","text":"Author of the embed.","title":"author"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.color","text":"Color of the embed.","title":"color"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.colour","text":"Alias for color.","title":"colour"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.description","text":"Description fo the embed","title":"description"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.fields","text":"List of fields related to this embed.","title":"fields"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.footer","text":"Footer of the embed.","title":"footer"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.payload","text":"The raw payload.","title":"payload"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.timestamp","text":"Timestamp of the embed.","title":"timestamp"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.title","text":"Title of the embed.","title":"title"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.Embed.url","text":"URL of the embed","title":"url"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedAuthor","text":"Represents an embed author. Source code in wyvern/constructors/embeds.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @typing . final @attrs . define ( slots = True ) class EmbedAuthor : \"\"\"Represents an embed author.\"\"\" name : str \"\"\"Name of the author.\"\"\" url : str | None = None \"\"\"URL that the author points to.\"\"\" icon_url : str | None = None \"\"\"URL of the author icon\"\"\" proxy_icon_url : str | None = None \"\"\"Proxy URL of icon.\"\"\" def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the author to its payload.\"\"\" return { \"name\" : self . name , \"url\" : self . url , \"icon_url\" : self . icon_url }","title":"EmbedAuthor"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedAuthor.icon_url","text":"URL of the author icon","title":"icon_url"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedAuthor.name","text":"Name of the author.","title":"name"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedAuthor.proxy_icon_url","text":"Proxy URL of icon.","title":"proxy_icon_url"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedAuthor.url","text":"URL that the author points to.","title":"url"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedAuthor.to_payload","text":"Converts the author to its payload. Source code in wyvern/constructors/embeds.py 49 50 51 def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the author to its payload.\"\"\" return { \"name\" : self . name , \"url\" : self . url , \"icon_url\" : self . icon_url }","title":"to_payload()"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedConstructor","text":"Creates an sendable discord embed. Parameters: Name Type Description Default title str Name of the embed. None description str Description of the embed None color int Color of the embed. 0 url str URL which the title points to. None timestamp datetime . datetime Timestamp to put in the embed. None Source code in wyvern/constructors/embeds.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class EmbedConstructor : \"\"\" Creates an sendable discord embed. Parameters ---------- title : str Name of the embed. description : str Description of the embed color : int Color of the embed. url : str URL which the title points to. timestamp : datetime.datetime Timestamp to put in the embed. \"\"\" __slots__ : tuple [ str , ... ] = ( \"_payload\" ,) def __init__ ( self , * , title : str | None = None , description : str | None = None , color : int = 0 , colour : int = 0 , url : str | None = None , timestamp : datetime . datetime | None = None , ) -> None : self . _payload : dict [ str , typing . Any ] = { \"type\" : \"rich\" , \"fields\" : [], \"title\" : title , \"description\" : description , \"color\" : color or colour , \"url\" : url , \"timestamp\" : int ( timestamp . timestamp ()) if isinstance ( timestamp , datetime . datetime ) else None , } def add_field ( self , * , name : str , value : str , inline : bool = True ) -> \"EmbedConstructor\" : \"\"\"Adds a field to the embed. Parameters ---------- name: str Name of the field. value: str Value of the filed inline: bool Weather the field is inline or not, defaults to [True][] Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" field = EmbedField ( name , value , inline ) self . _payload [ \"fields\" ] . append ( field . to_payload ()) return self def set_author ( self , * , name : str , url : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the author for the embed. Parameters ---------- name: str Name of the author field. url: str The URL author points to. icon_url: str URL for image to embed in the author. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" author = EmbedAuthor ( name , url , icon_url ) self . _payload [ \"author\" ] = author . to_payload () return self def set_footer ( self , * , text : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the footer for the embed. Parameters ---------- text: str The text to appear in the footer icon_url: str URL for image to embed in the footer. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" footer = EmbedFooter ( text , icon_url ) self . _payload [ \"footer\" ] = footer . to_payload () return self def edit_init ( self , * , title : str | None | utils . Empty = utils . EMPTY , description : str | None | utils . Empty = utils . EMPTY , color : int | utils . Empty = utils . EMPTY , colour : int | utils . Empty = utils . EMPTY , url : str | None | utils . Empty = utils . EMPTY , timestamp : datetime . datetime | None | utils . Empty = utils . EMPTY , ) -> \"EmbedConstructor\" : if title != utils . EMPTY : self . _payload [ \"title\" ] = title if description != utils . EMPTY : self . _payload [ \"description\" ] = description if color != utils . EMPTY : self . _payload [ \"color\" ] = color if colour != utils . EMPTY : self . _payload [ \"color\" ] = colour if url != utils . EMPTY : self . _payload [ \"url\" ] = url if timestamp != utils . EMPTY : self . _payload [ \"timestamp\" ] = ( int ( timestamp . timestamp ()) if isinstance ( timestamp , datetime . datetime ) else None ) return self def build ( self ) -> \"Embed\" : return Embed ( payload = self . _payload , title = self . _payload . get ( \"title\" ), description = self . _payload . get ( \"description\" ), url = self . _payload . get ( \"url\" ), color = self . _payload . get ( \"color\" , 0 ), fields = [ EmbedField ( ** kargs . to_payload ()) for kargs in self . _payload . get ( \"fields\" , [])], author = self . _payload . get ( \"author\" ), footer = self . _payload . get ( \"footer\" ), )","title":"EmbedConstructor"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedConstructor.add_field","text":"Adds a field to the embed. Parameters: Name Type Description Default name str Name of the field. required value str Value of the filed required inline bool Weather the field is inline or not, defaults to True True Returns: Type Description wyvern . constructors . embeds . EmbedConstructor The constructor. Source code in wyvern/constructors/embeds.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def add_field ( self , * , name : str , value : str , inline : bool = True ) -> \"EmbedConstructor\" : \"\"\"Adds a field to the embed. Parameters ---------- name: str Name of the field. value: str Value of the filed inline: bool Weather the field is inline or not, defaults to [True][] Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" field = EmbedField ( name , value , inline ) self . _payload [ \"fields\" ] . append ( field . to_payload ()) return self","title":"add_field()"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedConstructor.set_author","text":"Set's the author for the embed. Parameters: Name Type Description Default name str Name of the author field. required url str The URL author points to. required icon_url str | None URL for image to embed in the author. None Returns: Type Description wyvern . constructors . embeds . EmbedConstructor The constructor. Source code in wyvern/constructors/embeds.py 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 def set_author ( self , * , name : str , url : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the author for the embed. Parameters ---------- name: str Name of the author field. url: str The URL author points to. icon_url: str URL for image to embed in the author. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" author = EmbedAuthor ( name , url , icon_url ) self . _payload [ \"author\" ] = author . to_payload () return self","title":"set_author()"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedConstructor.set_footer","text":"Set's the footer for the embed. Parameters: Name Type Description Default text str The text to appear in the footer required icon_url str | None URL for image to embed in the footer. None Returns: Type Description wyvern . constructors . embeds . EmbedConstructor The constructor. Source code in wyvern/constructors/embeds.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def set_footer ( self , * , text : str , icon_url : str | None = None ) -> \"EmbedConstructor\" : \"\"\" Set's the footer for the embed. Parameters ---------- text: str The text to appear in the footer icon_url: str URL for image to embed in the footer. Returns ------- wyvern.constructors.embeds.EmbedConstructor The constructor. \"\"\" footer = EmbedFooter ( text , icon_url ) self . _payload [ \"footer\" ] = footer . to_payload () return self","title":"set_footer()"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedField","text":"Represnts an embed field. Source code in wyvern/constructors/embeds.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @typing . final @attrs . define ( slots = True ) class EmbedField : \"\"\"Represnts an embed field.\"\"\" name : str \"\"\"Name of the field.\"\"\" value : str \"\"\"Value of the field.\"\"\" inline : bool = True \"\"\"Inline value for the file, defaults to True.\"\"\" def to_payload ( self ) -> dict [ str , str | bool ]: return { \"name\" : self . name , \"value\" : self . value , \"inline\" : self . inline }","title":"EmbedField"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedField.inline","text":"Inline value for the file, defaults to True.","title":"inline"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedField.name","text":"Name of the field.","title":"name"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedField.value","text":"Value of the field.","title":"value"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedFooter","text":"Represents an embed footer Source code in wyvern/constructors/embeds.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @typing . final @attrs . define ( slots = True ) class EmbedFooter : \"\"\"Represents an embed footer\"\"\" text : str \"\"\"The text in the footer.\"\"\" icon_url : str | None = None \"\"\"URL of the footer icon.\"\"\" proxy_icon_url : str | None = None \"\"\"Proxy URL of the icon\"\"\" def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the footer to its payload.\"\"\" return { \"text\" : self . text , \"icon_url\" : self . icon_url }","title":"EmbedFooter"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedFooter.icon_url","text":"URL of the footer icon.","title":"icon_url"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedFooter.proxy_icon_url","text":"Proxy URL of the icon","title":"proxy_icon_url"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedFooter.text","text":"The text in the footer.","title":"text"},{"location":"api_reference/constructors/embeds/#wyvern.constructors.embeds.EmbedFooter.to_payload","text":"Converts the footer to its payload. Source code in wyvern/constructors/embeds.py 66 67 68 def to_payload ( self ) -> dict [ str , str | None ]: \"\"\"Converts the footer to its payload.\"\"\" return { \"text\" : self . text , \"icon_url\" : self . icon_url }","title":"to_payload()"},{"location":"api_reference/extensions/tasks/","text":"Task Represents a task that gets triggerd after some interval of time repeatedly. Source code in wyvern/extensions/tasks.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @attrs . define ( kw_only = True , slots = True ) class Task : \"\"\"Represents a task that gets triggerd after some interval of time repeatedly.\"\"\" trigger : typing . Callable [ ... , typing . Awaitable [ typing . Any ]] \"\"\"The coro to trigger at every interval.\"\"\" delay : float \"\"\"Time delay between triggers ( in seconds )\"\"\" wait_until_complete : bool = True \"\"\"Weather to wait before one trigger is complete.\"\"\" is_running : bool = False \"\"\"True if the task is running.\"\"\" def update_delay ( self , delay : float ) -> None : self . delay = delay async def _runner ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : loop = asyncio . get_event_loop () while self . is_running is True : if self . wait_until_complete is False : loop . create_task ( self . trigger ( * args , ** kwargs )) # type: ignore else : await self . trigger ( * args , ** kwargs ) await asyncio . sleep ( self . delay ) def run ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Starts the task.\"\"\" if self . is_running is False : self . is_running = True else : raise Exception ( \"The task is already running.\" ) loop = asyncio . get_event_loop () loop . create_task ( self . _runner ( * args , * kwargs )) def stop ( self ) -> None : \"\"\"Stops the task.\"\"\" self . is_running = False delay : float class-attribute Time delay between triggers ( in seconds ) is_running : bool = False class-attribute True if the task is running. trigger : typing . Callable [ ... , typing . Awaitable [ typing . Any ]] class-attribute The coro to trigger at every interval. wait_until_complete : bool = True class-attribute Weather to wait before one trigger is complete. run ( * args , ** kwargs ) Starts the task. Source code in wyvern/extensions/tasks.py 59 60 61 62 63 64 65 66 def run ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Starts the task.\"\"\" if self . is_running is False : self . is_running = True else : raise Exception ( \"The task is already running.\" ) loop = asyncio . get_event_loop () loop . create_task ( self . _runner ( * args , * kwargs )) stop () Stops the task. Source code in wyvern/extensions/tasks.py 68 69 70 def stop ( self ) -> None : \"\"\"Stops the task.\"\"\" self . is_running = False task ( s = None , m = None , h = None , wait_until_complete = True ) Interface to create a task. Parameters: Name Type Description Default WIP typing . Any Docs to be added. required Source code in wyvern/extensions/tasks.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def task ( s : float | None = None , m : float | None = None , h : float | None = None , wait_until_complete : bool = True ) -> typing . Callable [ ... , Task ]: \"\"\"Interface to create a task. Parameters ---------- WIP : typing.Any Docs to be added. \"\"\" def inner ( trigger : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> Task : nonlocal s , m , h if ( delays := len ([ item for item in [ s , m , h ] if item is not None ])) > 1 or delays == 0 : raise ValueError ( \"Only one delay field can be used for the decorator.\" ) delay = 0.0 if s : delay = s elif m : delay = m * 60.0 elif h : delay = h * 60 * 60.0 return Task ( delay = delay , trigger = trigger , wait_until_complete = wait_until_complete , ) return inner","title":"tasks"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task","text":"Represents a task that gets triggerd after some interval of time repeatedly. Source code in wyvern/extensions/tasks.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @attrs . define ( kw_only = True , slots = True ) class Task : \"\"\"Represents a task that gets triggerd after some interval of time repeatedly.\"\"\" trigger : typing . Callable [ ... , typing . Awaitable [ typing . Any ]] \"\"\"The coro to trigger at every interval.\"\"\" delay : float \"\"\"Time delay between triggers ( in seconds )\"\"\" wait_until_complete : bool = True \"\"\"Weather to wait before one trigger is complete.\"\"\" is_running : bool = False \"\"\"True if the task is running.\"\"\" def update_delay ( self , delay : float ) -> None : self . delay = delay async def _runner ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : loop = asyncio . get_event_loop () while self . is_running is True : if self . wait_until_complete is False : loop . create_task ( self . trigger ( * args , ** kwargs )) # type: ignore else : await self . trigger ( * args , ** kwargs ) await asyncio . sleep ( self . delay ) def run ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Starts the task.\"\"\" if self . is_running is False : self . is_running = True else : raise Exception ( \"The task is already running.\" ) loop = asyncio . get_event_loop () loop . create_task ( self . _runner ( * args , * kwargs )) def stop ( self ) -> None : \"\"\"Stops the task.\"\"\" self . is_running = False","title":"Task"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task.delay","text":"Time delay between triggers ( in seconds )","title":"delay"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task.is_running","text":"True if the task is running.","title":"is_running"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task.trigger","text":"The coro to trigger at every interval.","title":"trigger"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task.wait_until_complete","text":"Weather to wait before one trigger is complete.","title":"wait_until_complete"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task.run","text":"Starts the task. Source code in wyvern/extensions/tasks.py 59 60 61 62 63 64 65 66 def run ( self , * args : typing . Any , ** kwargs : typing . Any ) -> None : \"\"\"Starts the task.\"\"\" if self . is_running is False : self . is_running = True else : raise Exception ( \"The task is already running.\" ) loop = asyncio . get_event_loop () loop . create_task ( self . _runner ( * args , * kwargs ))","title":"run()"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.Task.stop","text":"Stops the task. Source code in wyvern/extensions/tasks.py 68 69 70 def stop ( self ) -> None : \"\"\"Stops the task.\"\"\" self . is_running = False","title":"stop()"},{"location":"api_reference/extensions/tasks/#wyvern.extensions.tasks.task","text":"Interface to create a task. Parameters: Name Type Description Default WIP typing . Any Docs to be added. required Source code in wyvern/extensions/tasks.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def task ( s : float | None = None , m : float | None = None , h : float | None = None , wait_until_complete : bool = True ) -> typing . Callable [ ... , Task ]: \"\"\"Interface to create a task. Parameters ---------- WIP : typing.Any Docs to be added. \"\"\" def inner ( trigger : typing . Callable [ ... , typing . Awaitable [ typing . Any ]]) -> Task : nonlocal s , m , h if ( delays := len ([ item for item in [ s , m , h ] if item is not None ])) > 1 or delays == 0 : raise ValueError ( \"Only one delay field can be used for the decorator.\" ) delay = 0.0 if s : delay = s elif m : delay = m * 60.0 elif h : delay = h * 60 * 60.0 return Task ( delay = delay , trigger = trigger , wait_until_complete = wait_until_complete , ) return inner","title":"task()"},{"location":"api_reference/interactions/applications/","text":"ApplicationCommandInteraction Bases: Interaction Represents an application command interaction. Source code in wyvern/interactions/applications.py 131 132 133 134 class ApplicationCommandInteraction ( Interaction ): \"\"\"Represents an application command interaction.\"\"\" data : ApplicationCommandInteractionData ApplicationCommandInteractionData Data related to an application command interaction. Source code in wyvern/interactions/applications.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @typing . final @attrs . define ( kw_only = True , slots = True , repr = True ) class ApplicationCommandInteractionData : \"\"\"Data related to an application command interaction.\"\"\" payload : dict [ str , typing . Any ] \"\"\"Raw payload recieved from discord.\"\"\" type = InteractionType . APPLICATION_COMMAND \"\"\"Type of the interaction.\"\"\" command_id : models . base . Snowflake \"\"\"ID of the command.\"\"\" command_name : str \"\"\"Name of the command.\"\"\" command_type : InteractionCommandType \"\"\"Type of the interaction command.\"\"\" guild_id : models . base . Snowflake | None \"\"\"ID of the guild where interaction was triggered\"\"\" target_id : models . base . Snowflake | None \"\"\"ID of the application command target.\"\"\" options : list [ InteractionOption ] \"\"\"List of options used in the interaction.\"\"\" resoloved : ApplicationCommandInteractionResolvedData | None \"\"\"The resolved interaction data.\"\"\" command_id : models . base . Snowflake class-attribute ID of the command. command_name : str class-attribute Name of the command. command_type : InteractionCommandType class-attribute Type of the interaction command. guild_id : models . base . Snowflake | None class-attribute ID of the guild where interaction was triggered options : list [ InteractionOption ] class-attribute List of options used in the interaction. payload : dict [ str , typing . Any ] class-attribute Raw payload recieved from discord. resoloved : ApplicationCommandInteractionResolvedData | None class-attribute The resolved interaction data. target_id : models . base . Snowflake | None class-attribute ID of the application command target. type = InteractionType . APPLICATION_COMMAND class-attribute Type of the interaction. ApplicationCommandInteractionResolvedData Resloved data of the app command interaction. Source code in wyvern/interactions/applications.py 94 95 96 97 98 99 100 101 102 103 @typing . final @attrs . define ( kw_only = True , slots = True ) class ApplicationCommandInteractionResolvedData : \"\"\"Resloved data of the app command interaction.\"\"\" users : dict [ models . base . Snowflake , models . User ] members : dict [ models . base . Snowflake , models . Member ] messages : dict [ models . base . Snowflake , models . Message ] attachments : dict [ models . base . Snowflake , files . Attachment ] channels : dict [ models . base . Snowflake , models . ChannelLike ] AutocompleteInteraction Bases: Interaction Represents an autocomplete interaction. Source code in wyvern/interactions/applications.py 137 138 139 140 class AutocompleteInteraction ( Interaction ): \"\"\"Represents an autocomplete interaction.\"\"\" ... InteractionOption Represents a interaction option for slash commands. (From the api.) Note This class is not the same as commands.slash_commands.CommandOption class. Source code in wyvern/interactions/applications.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @typing . final @attrs . define ( kw_only = True , slots = True ) class InteractionOption : \"\"\"Represents a interaction option for slash commands. (From the api.) !!! note This class is not the same as [commands.slash_commands.CommandOption][] class. \"\"\" name : str \"\"\"Name of the option.\"\"\" type : InteractionCommandOptionType \"\"\"Type of the option.\"\"\" value : int | str | None \"\"\"Value of the option.\"\"\" options : list [ InteractionOption ] \"\"\"List of options in the options, if any.\"\"\" required : bool = True \"\"\"True if the option is required.\"\"\" is_focused : bool \"\"\"If the current option focused in an autocomplete interaction.\"\"\" autocomplete : bool = False \"\"\"Weather to enable autocomplete for this option or not.\"\"\" choices : list [ CommandOption ] = [] \"\"\"List of choices to add to the option.\"\"\" channel_types : list [ models . ChannelType ] = [] \"\"\"List of channel types for channel options.\"\"\" min_value : int | None = None \"\"\"Minimum value for the option\"\"\" max_value : int | None = None \"\"\"Maximum value for the option\"\"\" min_length : int | None = None \"\"\"Minimum length acceptable for the option\"\"\" max_length : int | None = None \"\"\"Maximum length acceptable for the option\"\"\" name_locales : Localizations | None = None \"\"\"Name locales for the option description\"\"\" description_locales : Localizations | None = None \"\"\"Name locales for the option description\"\"\" def __str__ ( self ) -> str : return self . name autocomplete : bool = False class-attribute Weather to enable autocomplete for this option or not. channel_types : list [ models . ChannelType ] = [] class-attribute List of channel types for channel options. choices : list [ CommandOption ] = [] class-attribute List of choices to add to the option. description_locales : Localizations | None = None class-attribute Name locales for the option description is_focused : bool class-attribute If the current option focused in an autocomplete interaction. max_length : int | None = None class-attribute Maximum length acceptable for the option max_value : int | None = None class-attribute Maximum value for the option min_length : int | None = None class-attribute Minimum length acceptable for the option min_value : int | None = None class-attribute Minimum value for the option name : str class-attribute Name of the option. name_locales : Localizations | None = None class-attribute Name locales for the option description options : list [ InteractionOption ] class-attribute List of options in the options, if any. required : bool = True class-attribute True if the option is required. type : InteractionCommandOptionType class-attribute Type of the option. value : int | str | None class-attribute Value of the option.","title":"applications"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteraction","text":"Bases: Interaction Represents an application command interaction. Source code in wyvern/interactions/applications.py 131 132 133 134 class ApplicationCommandInteraction ( Interaction ): \"\"\"Represents an application command interaction.\"\"\" data : ApplicationCommandInteractionData","title":"ApplicationCommandInteraction"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData","text":"Data related to an application command interaction. Source code in wyvern/interactions/applications.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @typing . final @attrs . define ( kw_only = True , slots = True , repr = True ) class ApplicationCommandInteractionData : \"\"\"Data related to an application command interaction.\"\"\" payload : dict [ str , typing . Any ] \"\"\"Raw payload recieved from discord.\"\"\" type = InteractionType . APPLICATION_COMMAND \"\"\"Type of the interaction.\"\"\" command_id : models . base . Snowflake \"\"\"ID of the command.\"\"\" command_name : str \"\"\"Name of the command.\"\"\" command_type : InteractionCommandType \"\"\"Type of the interaction command.\"\"\" guild_id : models . base . Snowflake | None \"\"\"ID of the guild where interaction was triggered\"\"\" target_id : models . base . Snowflake | None \"\"\"ID of the application command target.\"\"\" options : list [ InteractionOption ] \"\"\"List of options used in the interaction.\"\"\" resoloved : ApplicationCommandInteractionResolvedData | None \"\"\"The resolved interaction data.\"\"\"","title":"ApplicationCommandInteractionData"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.command_id","text":"ID of the command.","title":"command_id"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.command_name","text":"Name of the command.","title":"command_name"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.command_type","text":"Type of the interaction command.","title":"command_type"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.guild_id","text":"ID of the guild where interaction was triggered","title":"guild_id"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.options","text":"List of options used in the interaction.","title":"options"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.payload","text":"Raw payload recieved from discord.","title":"payload"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.resoloved","text":"The resolved interaction data.","title":"resoloved"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.target_id","text":"ID of the application command target.","title":"target_id"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionData.type","text":"Type of the interaction.","title":"type"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.ApplicationCommandInteractionResolvedData","text":"Resloved data of the app command interaction. Source code in wyvern/interactions/applications.py 94 95 96 97 98 99 100 101 102 103 @typing . final @attrs . define ( kw_only = True , slots = True ) class ApplicationCommandInteractionResolvedData : \"\"\"Resloved data of the app command interaction.\"\"\" users : dict [ models . base . Snowflake , models . User ] members : dict [ models . base . Snowflake , models . Member ] messages : dict [ models . base . Snowflake , models . Message ] attachments : dict [ models . base . Snowflake , files . Attachment ] channels : dict [ models . base . Snowflake , models . ChannelLike ]","title":"ApplicationCommandInteractionResolvedData"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.AutocompleteInteraction","text":"Bases: Interaction Represents an autocomplete interaction. Source code in wyvern/interactions/applications.py 137 138 139 140 class AutocompleteInteraction ( Interaction ): \"\"\"Represents an autocomplete interaction.\"\"\" ...","title":"AutocompleteInteraction"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption","text":"Represents a interaction option for slash commands. (From the api.) Note This class is not the same as commands.slash_commands.CommandOption class. Source code in wyvern/interactions/applications.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @typing . final @attrs . define ( kw_only = True , slots = True ) class InteractionOption : \"\"\"Represents a interaction option for slash commands. (From the api.) !!! note This class is not the same as [commands.slash_commands.CommandOption][] class. \"\"\" name : str \"\"\"Name of the option.\"\"\" type : InteractionCommandOptionType \"\"\"Type of the option.\"\"\" value : int | str | None \"\"\"Value of the option.\"\"\" options : list [ InteractionOption ] \"\"\"List of options in the options, if any.\"\"\" required : bool = True \"\"\"True if the option is required.\"\"\" is_focused : bool \"\"\"If the current option focused in an autocomplete interaction.\"\"\" autocomplete : bool = False \"\"\"Weather to enable autocomplete for this option or not.\"\"\" choices : list [ CommandOption ] = [] \"\"\"List of choices to add to the option.\"\"\" channel_types : list [ models . ChannelType ] = [] \"\"\"List of channel types for channel options.\"\"\" min_value : int | None = None \"\"\"Minimum value for the option\"\"\" max_value : int | None = None \"\"\"Maximum value for the option\"\"\" min_length : int | None = None \"\"\"Minimum length acceptable for the option\"\"\" max_length : int | None = None \"\"\"Maximum length acceptable for the option\"\"\" name_locales : Localizations | None = None \"\"\"Name locales for the option description\"\"\" description_locales : Localizations | None = None \"\"\"Name locales for the option description\"\"\" def __str__ ( self ) -> str : return self . name","title":"InteractionOption"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.autocomplete","text":"Weather to enable autocomplete for this option or not.","title":"autocomplete"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.channel_types","text":"List of channel types for channel options.","title":"channel_types"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.choices","text":"List of choices to add to the option.","title":"choices"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.description_locales","text":"Name locales for the option description","title":"description_locales"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.is_focused","text":"If the current option focused in an autocomplete interaction.","title":"is_focused"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.max_length","text":"Maximum length acceptable for the option","title":"max_length"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.max_value","text":"Maximum value for the option","title":"max_value"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.min_length","text":"Minimum length acceptable for the option","title":"min_length"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.min_value","text":"Minimum value for the option","title":"min_value"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.name","text":"Name of the option.","title":"name"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.name_locales","text":"Name locales for the option description","title":"name_locales"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.options","text":"List of options in the options, if any.","title":"options"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.required","text":"True if the option is required.","title":"required"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.type","text":"Type of the option.","title":"type"},{"location":"api_reference/interactions/applications/#wyvern.interactions.applications.InteractionOption.value","text":"Value of the option.","title":"value"},{"location":"api_reference/interactions/base/","text":"Interaction Bases: _ListenerArg Represents a discord interaction. Source code in wyvern/interactions/base.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @attrs . define ( kw_only = True , slots = True , repr = True , init = True ) class Interaction ( _ListenerArg ): \"\"\"Represents a discord interaction.\"\"\" client : \"GatewayClient\" id : int \"\"\"ID of the interaction.\"\"\" application_id : models . base . Snowflake \"\"\"ID of the application that recieved the interaction.\"\"\" type : InteractionType \"\"\"Type of the interaction.\"\"\" data : typing . Any \"\"\"Interaction data.\"\"\" guild_id : int | None \"\"\"ID of the guild where interaction was created.\"\"\" channel_id : int | None \"\"\"ID of channel where interaction was created.\"\"\" user : models . users . User | None \"\"\"User who invoked the interaction.\"\"\" token : str \"\"\"The interaction token.\"\"\" version : int = 1 message : \"models.messages.Message\" | None \"\"\"The message related to this interaction.\"\"\" guild_locale : str | None \"\"\"Locale of the guild.\"\"\" async def create_message_response ( self , content : str | None = None , * , embed : \"EmbedConstructor\" | None = None , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ \"ActionRowContainer\" ] = (), allowed_mentions : \"models.AllowedMentions\" | None = None , ) -> None : if all ([ embed , embeds ]): raise ValueError ( \"You cannot use both embed and embeds kwarg.\" ) embeds = [ embed ] if embed else embeds await self . client . rest . create_interaction_response ( self , InteractionResponseType . CHANNEL_MESSAGE_WITH_SOURCE , content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , ) async def create_defered_response ( self ) -> None : await self . client . rest . create_interaction_response ( self , InteractionResponseType . DEFERRED_UPDATE_MESSAGE if self . type is InteractionType . MESSAGE_COMPONENT else InteractionResponseType . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE , ) async def create_modal_response ( self , modal : \"Modal\" ) -> None : await self . client . rest . create_interaction_response ( self , InteractionResponseType . MODAL , modal = modal ) application_id : models . base . Snowflake class-attribute ID of the application that recieved the interaction. channel_id : int | None class-attribute ID of channel where interaction was created. data : typing . Any class-attribute Interaction data. guild_id : int | None class-attribute ID of the guild where interaction was created. guild_locale : str | None class-attribute Locale of the guild. id : int class-attribute ID of the interaction. message : models . messages . Message | None class-attribute The message related to this interaction. token : str class-attribute The interaction token. type : InteractionType class-attribute Type of the interaction. user : models . users . User | None class-attribute User who invoked the interaction. InteractionType Bases: enum . IntEnum Type of the interaction. Source code in wyvern/interactions/base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @typing . final class InteractionType ( enum . IntEnum ): \"\"\"Type of the interaction.\"\"\" PING = 1 \"\"\"A ping-pong interaction.\"\"\" APPLICATION_COMMAND = 2 \"\"\"Interaction recieved on application command invocation\"\"\" MESSAGE_COMPONENT = 3 \"\"\"Interaction recieved when a message component is used.\"\"\" APPLICATION_COMMAND_AUTOCOMPLETE = 4 \"\"\"Interaction for autocompletes.\"\"\" MODAL_SUBMIT = 5 \"\"\"Interaction when a modal form is submitted.\"\"\" APPLICATION_COMMAND = 2 class-attribute Interaction recieved on application command invocation APPLICATION_COMMAND_AUTOCOMPLETE = 4 class-attribute Interaction for autocompletes. MESSAGE_COMPONENT = 3 class-attribute Interaction recieved when a message component is used. MODAL_SUBMIT = 5 class-attribute Interaction when a modal form is submitted. PING = 1 class-attribute A ping-pong interaction.","title":"base"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction","text":"Bases: _ListenerArg Represents a discord interaction. Source code in wyvern/interactions/base.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 @attrs . define ( kw_only = True , slots = True , repr = True , init = True ) class Interaction ( _ListenerArg ): \"\"\"Represents a discord interaction.\"\"\" client : \"GatewayClient\" id : int \"\"\"ID of the interaction.\"\"\" application_id : models . base . Snowflake \"\"\"ID of the application that recieved the interaction.\"\"\" type : InteractionType \"\"\"Type of the interaction.\"\"\" data : typing . Any \"\"\"Interaction data.\"\"\" guild_id : int | None \"\"\"ID of the guild where interaction was created.\"\"\" channel_id : int | None \"\"\"ID of channel where interaction was created.\"\"\" user : models . users . User | None \"\"\"User who invoked the interaction.\"\"\" token : str \"\"\"The interaction token.\"\"\" version : int = 1 message : \"models.messages.Message\" | None \"\"\"The message related to this interaction.\"\"\" guild_locale : str | None \"\"\"Locale of the guild.\"\"\" async def create_message_response ( self , content : str | None = None , * , embed : \"EmbedConstructor\" | None = None , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ \"ActionRowContainer\" ] = (), allowed_mentions : \"models.AllowedMentions\" | None = None , ) -> None : if all ([ embed , embeds ]): raise ValueError ( \"You cannot use both embed and embeds kwarg.\" ) embeds = [ embed ] if embed else embeds await self . client . rest . create_interaction_response ( self , InteractionResponseType . CHANNEL_MESSAGE_WITH_SOURCE , content = content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , ) async def create_defered_response ( self ) -> None : await self . client . rest . create_interaction_response ( self , InteractionResponseType . DEFERRED_UPDATE_MESSAGE if self . type is InteractionType . MESSAGE_COMPONENT else InteractionResponseType . DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE , ) async def create_modal_response ( self , modal : \"Modal\" ) -> None : await self . client . rest . create_interaction_response ( self , InteractionResponseType . MODAL , modal = modal )","title":"Interaction"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.application_id","text":"ID of the application that recieved the interaction.","title":"application_id"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.channel_id","text":"ID of channel where interaction was created.","title":"channel_id"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.data","text":"Interaction data.","title":"data"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.guild_id","text":"ID of the guild where interaction was created.","title":"guild_id"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.guild_locale","text":"Locale of the guild.","title":"guild_locale"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.id","text":"ID of the interaction.","title":"id"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.message","text":"The message related to this interaction.","title":"message"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.token","text":"The interaction token.","title":"token"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.type","text":"Type of the interaction.","title":"type"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.Interaction.user","text":"User who invoked the interaction.","title":"user"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.InteractionType","text":"Bases: enum . IntEnum Type of the interaction. Source code in wyvern/interactions/base.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @typing . final class InteractionType ( enum . IntEnum ): \"\"\"Type of the interaction.\"\"\" PING = 1 \"\"\"A ping-pong interaction.\"\"\" APPLICATION_COMMAND = 2 \"\"\"Interaction recieved on application command invocation\"\"\" MESSAGE_COMPONENT = 3 \"\"\"Interaction recieved when a message component is used.\"\"\" APPLICATION_COMMAND_AUTOCOMPLETE = 4 \"\"\"Interaction for autocompletes.\"\"\" MODAL_SUBMIT = 5 \"\"\"Interaction when a modal form is submitted.\"\"\"","title":"InteractionType"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.InteractionType.APPLICATION_COMMAND","text":"Interaction recieved on application command invocation","title":"APPLICATION_COMMAND"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.InteractionType.APPLICATION_COMMAND_AUTOCOMPLETE","text":"Interaction for autocompletes.","title":"APPLICATION_COMMAND_AUTOCOMPLETE"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.InteractionType.MESSAGE_COMPONENT","text":"Interaction recieved when a message component is used.","title":"MESSAGE_COMPONENT"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.InteractionType.MODAL_SUBMIT","text":"Interaction when a modal form is submitted.","title":"MODAL_SUBMIT"},{"location":"api_reference/interactions/base/#wyvern.interactions.base.InteractionType.PING","text":"A ping-pong interaction.","title":"PING"},{"location":"api_reference/interactions/components/","text":"","title":"components"},{"location":"api_reference/interactions/localizations/","text":"","title":"localizations"},{"location":"api_reference/models/base/","text":"DiscordObject Bases: _ListenerArg Represents a discord object. Parameters: Name Type Description Default _id int ID of the entity. required Attributes: Name Type Description id int ID of the entity. Source code in wyvern/models/base.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class DiscordObject ( _ListenerArg ): \"\"\" Represents a discord object. Parameters ---------- _id: int ID of the entity. Attributes ---------- id: int ID of the entity. \"\"\" def __init__ ( self , _id : int ) -> None : self . id = Snowflake . create ( _id ) def __eq__ ( self , obj : object ) -> bool : if not isinstance ( obj , DiscordObject ): return NotImplemented return self . id == obj . id @property def created_at ( self ) -> datetime . datetime : \"\"\" The datetime at which this entity was created. Returns ------- datetime.datetime \"\"\" return self . get_created_at ( self . id ) @classmethod def get_created_at ( cls , _id : int ) -> datetime . datetime : \"\"\" Get creation time of an entity using it's ID. \"\"\" timestamp = (( _id >> 22 ) + 1420070400000 ) / 1000 return datetime . datetime . fromtimestamp ( timestamp , datetime . timezone . utc ) created_at () property The datetime at which this entity was created. Returns: Type Description datetime . datetime Source code in wyvern/models/base.py 69 70 71 72 73 74 75 76 77 78 79 @property def created_at ( self ) -> datetime . datetime : \"\"\" The datetime at which this entity was created. Returns ------- datetime.datetime \"\"\" return self . get_created_at ( self . id ) get_created_at ( _id ) classmethod Get creation time of an entity using it's ID. Source code in wyvern/models/base.py 81 82 83 84 85 86 87 @classmethod def get_created_at ( cls , _id : int ) -> datetime . datetime : \"\"\" Get creation time of an entity using it's ID. \"\"\" timestamp = (( _id >> 22 ) + 1420070400000 ) / 1000 return datetime . datetime . fromtimestamp ( timestamp , datetime . timezone . utc )","title":"base"},{"location":"api_reference/models/base/#wyvern.models.base.DiscordObject","text":"Bases: _ListenerArg Represents a discord object. Parameters: Name Type Description Default _id int ID of the entity. required Attributes: Name Type Description id int ID of the entity. Source code in wyvern/models/base.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class DiscordObject ( _ListenerArg ): \"\"\" Represents a discord object. Parameters ---------- _id: int ID of the entity. Attributes ---------- id: int ID of the entity. \"\"\" def __init__ ( self , _id : int ) -> None : self . id = Snowflake . create ( _id ) def __eq__ ( self , obj : object ) -> bool : if not isinstance ( obj , DiscordObject ): return NotImplemented return self . id == obj . id @property def created_at ( self ) -> datetime . datetime : \"\"\" The datetime at which this entity was created. Returns ------- datetime.datetime \"\"\" return self . get_created_at ( self . id ) @classmethod def get_created_at ( cls , _id : int ) -> datetime . datetime : \"\"\" Get creation time of an entity using it's ID. \"\"\" timestamp = (( _id >> 22 ) + 1420070400000 ) / 1000 return datetime . datetime . fromtimestamp ( timestamp , datetime . timezone . utc )","title":"DiscordObject"},{"location":"api_reference/models/base/#wyvern.models.base.DiscordObject.created_at","text":"The datetime at which this entity was created. Returns: Type Description datetime . datetime Source code in wyvern/models/base.py 69 70 71 72 73 74 75 76 77 78 79 @property def created_at ( self ) -> datetime . datetime : \"\"\" The datetime at which this entity was created. Returns ------- datetime.datetime \"\"\" return self . get_created_at ( self . id )","title":"created_at()"},{"location":"api_reference/models/base/#wyvern.models.base.DiscordObject.get_created_at","text":"Get creation time of an entity using it's ID. Source code in wyvern/models/base.py 81 82 83 84 85 86 87 @classmethod def get_created_at ( cls , _id : int ) -> datetime . datetime : \"\"\" Get creation time of an entity using it's ID. \"\"\" timestamp = (( _id >> 22 ) + 1420070400000 ) / 1000 return datetime . datetime . fromtimestamp ( timestamp , datetime . timezone . utc )","title":"get_created_at()"},{"location":"api_reference/models/members/","text":"Member Bases: User Source code in wyvern/models/members.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @attrs . define ( kw_only = True , slots = True , repr = True ) class Member ( User ): user : User \"\"\"User of the member.\"\"\" guild_id : Snowflake \"\"\"ID of the guild this member belongs to.\"\"\" nickname : str | None \"\"\"Nickname of the member, if any.\"\"\" role_ids : list [ Snowflake ] \"\"\"List of role ids.\"\"\" joined_at : datetime . datetime \"\"\"Datetime on which the member joined the guild.\"\"\" premium_since : datetime . datetime | None \"\"\"Datetime since member has been boosting the guild.\"\"\" deaf : bool | None \"\"\"True if member is deafened.\"\"\" mute : bool | None \"\"\"True if member is muted.\"\"\" pending : bool \"\"\"True if member is in pending state.\"\"\" communication_disabled_until : datetime . datetime | None \"\"\"Timeout for the member.\"\"\" guild_avatar_hash : str | None \"\"\"Avatar hash for the guild.\"\"\" def update_state ( self ) -> \"Member\" | None : return member if ( member := self . client . members . get ( self . guild_id , self . id )) else None @property def display_avatar ( self ) -> Avatar : \"\"\" Returns ------- str Member's visible avatar. \"\"\" return self . guild_avatar or self . avatar or self . default_avatar @property def display_name ( self ) -> str : \"\"\" Returns ------- str Member's visible name. \"\"\" return self . nickname or self . username @property def guild_avatar ( self ) -> Avatar | None : \"\"\" Returns ------- None | wyvern.Avatar The user's guild avatar. \"\"\" return ( Avatar ( client = self . client , type = AvatarType . GUILD , hash = self . guild_avatar_hash ) if self . guild_avatar_hash else None ) communication_disabled_until : datetime . datetime | None class-attribute Timeout for the member. deaf : bool | None class-attribute True if member is deafened. guild_avatar_hash : str | None class-attribute Avatar hash for the guild. guild_id : Snowflake class-attribute ID of the guild this member belongs to. joined_at : datetime . datetime class-attribute Datetime on which the member joined the guild. mute : bool | None class-attribute True if member is muted. nickname : str | None class-attribute Nickname of the member, if any. pending : bool class-attribute True if member is in pending state. premium_since : datetime . datetime | None class-attribute Datetime since member has been boosting the guild. role_ids : list [ Snowflake ] class-attribute List of role ids. user : User class-attribute User of the member. display_avatar () property Returns: Type Description str Member's visible avatar. Source code in wyvern/models/members.py 41 42 43 44 45 46 47 48 49 @property def display_avatar ( self ) -> Avatar : \"\"\" Returns ------- str Member's visible avatar. \"\"\" return self . guild_avatar or self . avatar or self . default_avatar display_name () property Returns: Type Description str Member's visible name. Source code in wyvern/models/members.py 51 52 53 54 55 56 57 58 59 @property def display_name ( self ) -> str : \"\"\" Returns ------- str Member's visible name. \"\"\" return self . nickname or self . username guild_avatar () property Returns: Type Description None | wyvern . Avatar The user's guild avatar. Source code in wyvern/models/members.py 61 62 63 64 65 66 67 68 69 70 71 72 73 @property def guild_avatar ( self ) -> Avatar | None : \"\"\" Returns ------- None | wyvern.Avatar The user's guild avatar. \"\"\" return ( Avatar ( client = self . client , type = AvatarType . GUILD , hash = self . guild_avatar_hash ) if self . guild_avatar_hash else None )","title":"members"},{"location":"api_reference/models/members/#wyvern.models.members.Member","text":"Bases: User Source code in wyvern/models/members.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 @attrs . define ( kw_only = True , slots = True , repr = True ) class Member ( User ): user : User \"\"\"User of the member.\"\"\" guild_id : Snowflake \"\"\"ID of the guild this member belongs to.\"\"\" nickname : str | None \"\"\"Nickname of the member, if any.\"\"\" role_ids : list [ Snowflake ] \"\"\"List of role ids.\"\"\" joined_at : datetime . datetime \"\"\"Datetime on which the member joined the guild.\"\"\" premium_since : datetime . datetime | None \"\"\"Datetime since member has been boosting the guild.\"\"\" deaf : bool | None \"\"\"True if member is deafened.\"\"\" mute : bool | None \"\"\"True if member is muted.\"\"\" pending : bool \"\"\"True if member is in pending state.\"\"\" communication_disabled_until : datetime . datetime | None \"\"\"Timeout for the member.\"\"\" guild_avatar_hash : str | None \"\"\"Avatar hash for the guild.\"\"\" def update_state ( self ) -> \"Member\" | None : return member if ( member := self . client . members . get ( self . guild_id , self . id )) else None @property def display_avatar ( self ) -> Avatar : \"\"\" Returns ------- str Member's visible avatar. \"\"\" return self . guild_avatar or self . avatar or self . default_avatar @property def display_name ( self ) -> str : \"\"\" Returns ------- str Member's visible name. \"\"\" return self . nickname or self . username @property def guild_avatar ( self ) -> Avatar | None : \"\"\" Returns ------- None | wyvern.Avatar The user's guild avatar. \"\"\" return ( Avatar ( client = self . client , type = AvatarType . GUILD , hash = self . guild_avatar_hash ) if self . guild_avatar_hash else None )","title":"Member"},{"location":"api_reference/models/members/#wyvern.models.members.Member.communication_disabled_until","text":"Timeout for the member.","title":"communication_disabled_until"},{"location":"api_reference/models/members/#wyvern.models.members.Member.deaf","text":"True if member is deafened.","title":"deaf"},{"location":"api_reference/models/members/#wyvern.models.members.Member.guild_avatar_hash","text":"Avatar hash for the guild.","title":"guild_avatar_hash"},{"location":"api_reference/models/members/#wyvern.models.members.Member.guild_id","text":"ID of the guild this member belongs to.","title":"guild_id"},{"location":"api_reference/models/members/#wyvern.models.members.Member.joined_at","text":"Datetime on which the member joined the guild.","title":"joined_at"},{"location":"api_reference/models/members/#wyvern.models.members.Member.mute","text":"True if member is muted.","title":"mute"},{"location":"api_reference/models/members/#wyvern.models.members.Member.nickname","text":"Nickname of the member, if any.","title":"nickname"},{"location":"api_reference/models/members/#wyvern.models.members.Member.pending","text":"True if member is in pending state.","title":"pending"},{"location":"api_reference/models/members/#wyvern.models.members.Member.premium_since","text":"Datetime since member has been boosting the guild.","title":"premium_since"},{"location":"api_reference/models/members/#wyvern.models.members.Member.role_ids","text":"List of role ids.","title":"role_ids"},{"location":"api_reference/models/members/#wyvern.models.members.Member.user","text":"User of the member.","title":"user"},{"location":"api_reference/models/members/#wyvern.models.members.Member.display_avatar","text":"Returns: Type Description str Member's visible avatar. Source code in wyvern/models/members.py 41 42 43 44 45 46 47 48 49 @property def display_avatar ( self ) -> Avatar : \"\"\" Returns ------- str Member's visible avatar. \"\"\" return self . guild_avatar or self . avatar or self . default_avatar","title":"display_avatar()"},{"location":"api_reference/models/members/#wyvern.models.members.Member.display_name","text":"Returns: Type Description str Member's visible name. Source code in wyvern/models/members.py 51 52 53 54 55 56 57 58 59 @property def display_name ( self ) -> str : \"\"\" Returns ------- str Member's visible name. \"\"\" return self . nickname or self . username","title":"display_name()"},{"location":"api_reference/models/members/#wyvern.models.members.Member.guild_avatar","text":"Returns: Type Description None | wyvern . Avatar The user's guild avatar. Source code in wyvern/models/members.py 61 62 63 64 65 66 67 68 69 70 71 72 73 @property def guild_avatar ( self ) -> Avatar | None : \"\"\" Returns ------- None | wyvern.Avatar The user's guild avatar. \"\"\" return ( Avatar ( client = self . client , type = AvatarType . GUILD , hash = self . guild_avatar_hash ) if self . guild_avatar_hash else None )","title":"guild_avatar()"},{"location":"api_reference/models/messages/","text":"AllowedMentions Represents an allowed mentions payload for discord. Source code in wyvern/models/messages.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @attrs . define ( kw_only = True , slots = True ) class AllowedMentions : \"\"\"Represents an allowed mentions payload for discord.\"\"\" roles : bool = False \"\"\"Set to True if role mentions are allowed.\"\"\" users : bool = False \"\"\"Set to True if user mentions are allowed.\"\"\" everyone : bool = False \"\"\"Set to True if `@everyone` mentions are allowed.\"\"\" replied_user : bool = False \"\"\"Set to True if bot should ping message authors on replies.\"\"\" def to_payload ( self ) -> dict [ str , list [ str ] | bool ]: payload : dict [ str , list [ str ] | bool ] = { \"parse\" : [], \"replied_user\" : self . replied_user } assert isinstance ( payload [ \"parse\" ], list ) if self . roles is True : payload [ \"parse\" ] . append ( \"roles\" ) if self . users is True : payload [ \"parse\" ] . append ( \"users\" ) if self . everyone is True : payload [ \"parse\" ] . append ( \"everyone\" ) return payload everyone : bool = False class-attribute Set to True if @everyone mentions are allowed. replied_user : bool = False class-attribute Set to True if bot should ping message authors on replies. roles : bool = False class-attribute Set to True if role mentions are allowed. users : bool = False class-attribute Set to True if user mentions are allowed. Message Bases: DiscordObject Represents a discord message. Source code in wyvern/models/messages.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @attrs . define ( kw_only = True , slots = True , repr = True , eq = True ) class Message ( DiscordObject ): \"\"\" Represents a discord message. \"\"\" client : \"GatewayClient\" raw : dict [ str , typing . Any ] id : Snowflake \"\"\"ID of the message.\"\"\" tts : bool \"\"\"True if the message was a TTS message.\"\"\" pinned : bool \"\"\"Is the message is pinned.\"\"\" mentions : list [ \"User\" ] \"\"\"List of users mentioned in the message.\"\"\" mention_roles : list [ int ] \"\"\"List of ids for roles mentioned in the message.\"\"\" flags_value : int \"\"\"Value of message flags\"\"\" embeds : list [ \"Embed\" ] \"\"\"List of embeds attached to the message.\"\"\" edited_at : datetime . datetime | None \"\"\"When was the message last edited.\"\"\" content : str | None \"\"\"The message content. Needs [wyvern.intents.Intents.MESSAGE_CONTENT] to be access this in a guild context.\"\"\" channel_id : int \"\"\"ID of the channel where this message was sent.\"\"\" author : \"User\" \"\"\"The message author.\"\"\" message_reference : MessageReference | None \"\"\"The message reference, if any.\"\"\" attachments : list [ Attachment ] \"\"\"File attachments in this message.\"\"\" async def respond ( self , content : str | None = None , * , embed : \"EmbedConstructor\" | None = None , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ \"ActionRowContainer\" ] = (), allowed_mentions : AllowedMentions | None = None , flags : MessageFlags | None = None , delete_after : int | None = None , reply : bool = False , ) -> \"Message\" : \"\"\" Parameters ---------- content : str | None The text content of the message. embed : wyvern.constructors.embeds.EmbedConstructor An single embed object to send, for multiple use `embeds` kwarg instead. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. reply : bool True if you the response should be created a reply. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" if all ([ embed , embeds ]): raise ValueError ( \"You cannot use both embed and embeds kwarg.\" ) embeds = [ embed ] if embed else embeds return await self . client . rest . create_message ( self . channel_id , content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , reference = self . id if reply is True else None , delete_after = delete_after , flags = flags , ) attachments : list [ Attachment ] class-attribute File attachments in this message. author : User class-attribute The message author. channel_id : int class-attribute ID of the channel where this message was sent. content : str | None class-attribute The message content. Needs [wyvern.intents.Intents.MESSAGE_CONTENT] to be access this in a guild context. edited_at : datetime . datetime | None class-attribute When was the message last edited. embeds : list [ Embed ] class-attribute List of embeds attached to the message. flags_value : int class-attribute Value of message flags id : Snowflake class-attribute ID of the message. mention_roles : list [ int ] class-attribute List of ids for roles mentioned in the message. mentions : list [ User ] class-attribute List of users mentioned in the message. message_reference : MessageReference | None class-attribute The message reference, if any. pinned : bool class-attribute Is the message is pinned. tts : bool class-attribute True if the message was a TTS message. respond ( content = None , * , embed = None , embeds = (), components = (), allowed_mentions = None , flags = None , delete_after = None , reply = False ) async Parameters: Name Type Description Default content str | None The text content of the message. None embed wyvern . constructors . embeds . EmbedConstructor An single embed object to send, for multiple use embeds kwarg instead. None embeds typing . Sequence [ wyvern . constructors . embeds . EmbedConstructor ] Sequence of embeds to send. () components typing . Sequence [ wyvern . components . container . ActionRowContainer ] Sequence of action rows to send. () allowed_mentions wyvern . models . messages . AllowedMentions | None Allowed mentions configs. None reply bool True if you the response should be created a reply. False Returns: Type Description wyvern . models . messages . Message The message object that got created. Source code in wyvern/models/messages.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 async def respond ( self , content : str | None = None , * , embed : \"EmbedConstructor\" | None = None , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ \"ActionRowContainer\" ] = (), allowed_mentions : AllowedMentions | None = None , flags : MessageFlags | None = None , delete_after : int | None = None , reply : bool = False , ) -> \"Message\" : \"\"\" Parameters ---------- content : str | None The text content of the message. embed : wyvern.constructors.embeds.EmbedConstructor An single embed object to send, for multiple use `embeds` kwarg instead. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. reply : bool True if you the response should be created a reply. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" if all ([ embed , embeds ]): raise ValueError ( \"You cannot use both embed and embeds kwarg.\" ) embeds = [ embed ] if embed else embeds return await self . client . rest . create_message ( self . channel_id , content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , reference = self . id if reply is True else None , delete_after = delete_after , flags = flags , ) MessageReference Source code in wyvern/models/messages.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @attrs . define ( kw_only = True , slots = True , repr = True ) class MessageReference : channel_id : int | None = None \"\"\"ID of the channel.\"\"\" message_id : int | None = None \"\"\"ID of the message.\"\"\" guild_id : int | None = None \"\"\"ID of the guild, if any.\"\"\" fail_if_not_exists : bool = True \"\"\"Weather to raise error if message does not exist.\"\"\" def to_payload ( self ) -> dict [ str , int | bool | None ]: \"\"\"Converts the object to a sendable payload. Returns ------- dict[str, int| bool] \"\"\" return { \"channel_id\" : self . channel_id , \"message_id\" : self . message_id , \"guild_id\" : self . guild_id , \"fail_if_not_exists\" : self . fail_if_not_exists , } channel_id : int | None = None class-attribute ID of the channel. fail_if_not_exists : bool = True class-attribute Weather to raise error if message does not exist. guild_id : int | None = None class-attribute ID of the guild, if any. message_id : int | None = None class-attribute ID of the message. to_payload () Converts the object to a sendable payload. Returns: Type Description dict [ str , int | bool ] Source code in wyvern/models/messages.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def to_payload ( self ) -> dict [ str , int | bool | None ]: \"\"\"Converts the object to a sendable payload. Returns ------- dict[str, int| bool] \"\"\" return { \"channel_id\" : self . channel_id , \"message_id\" : self . message_id , \"guild_id\" : self . guild_id , \"fail_if_not_exists\" : self . fail_if_not_exists , }","title":"messages"},{"location":"api_reference/models/messages/#wyvern.models.messages.AllowedMentions","text":"Represents an allowed mentions payload for discord. Source code in wyvern/models/messages.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 @attrs . define ( kw_only = True , slots = True ) class AllowedMentions : \"\"\"Represents an allowed mentions payload for discord.\"\"\" roles : bool = False \"\"\"Set to True if role mentions are allowed.\"\"\" users : bool = False \"\"\"Set to True if user mentions are allowed.\"\"\" everyone : bool = False \"\"\"Set to True if `@everyone` mentions are allowed.\"\"\" replied_user : bool = False \"\"\"Set to True if bot should ping message authors on replies.\"\"\" def to_payload ( self ) -> dict [ str , list [ str ] | bool ]: payload : dict [ str , list [ str ] | bool ] = { \"parse\" : [], \"replied_user\" : self . replied_user } assert isinstance ( payload [ \"parse\" ], list ) if self . roles is True : payload [ \"parse\" ] . append ( \"roles\" ) if self . users is True : payload [ \"parse\" ] . append ( \"users\" ) if self . everyone is True : payload [ \"parse\" ] . append ( \"everyone\" ) return payload","title":"AllowedMentions"},{"location":"api_reference/models/messages/#wyvern.models.messages.AllowedMentions.everyone","text":"Set to True if @everyone mentions are allowed.","title":"everyone"},{"location":"api_reference/models/messages/#wyvern.models.messages.AllowedMentions.replied_user","text":"Set to True if bot should ping message authors on replies.","title":"replied_user"},{"location":"api_reference/models/messages/#wyvern.models.messages.AllowedMentions.roles","text":"Set to True if role mentions are allowed.","title":"roles"},{"location":"api_reference/models/messages/#wyvern.models.messages.AllowedMentions.users","text":"Set to True if user mentions are allowed.","title":"users"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message","text":"Bases: DiscordObject Represents a discord message. Source code in wyvern/models/messages.py 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 @attrs . define ( kw_only = True , slots = True , repr = True , eq = True ) class Message ( DiscordObject ): \"\"\" Represents a discord message. \"\"\" client : \"GatewayClient\" raw : dict [ str , typing . Any ] id : Snowflake \"\"\"ID of the message.\"\"\" tts : bool \"\"\"True if the message was a TTS message.\"\"\" pinned : bool \"\"\"Is the message is pinned.\"\"\" mentions : list [ \"User\" ] \"\"\"List of users mentioned in the message.\"\"\" mention_roles : list [ int ] \"\"\"List of ids for roles mentioned in the message.\"\"\" flags_value : int \"\"\"Value of message flags\"\"\" embeds : list [ \"Embed\" ] \"\"\"List of embeds attached to the message.\"\"\" edited_at : datetime . datetime | None \"\"\"When was the message last edited.\"\"\" content : str | None \"\"\"The message content. Needs [wyvern.intents.Intents.MESSAGE_CONTENT] to be access this in a guild context.\"\"\" channel_id : int \"\"\"ID of the channel where this message was sent.\"\"\" author : \"User\" \"\"\"The message author.\"\"\" message_reference : MessageReference | None \"\"\"The message reference, if any.\"\"\" attachments : list [ Attachment ] \"\"\"File attachments in this message.\"\"\" async def respond ( self , content : str | None = None , * , embed : \"EmbedConstructor\" | None = None , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ \"ActionRowContainer\" ] = (), allowed_mentions : AllowedMentions | None = None , flags : MessageFlags | None = None , delete_after : int | None = None , reply : bool = False , ) -> \"Message\" : \"\"\" Parameters ---------- content : str | None The text content of the message. embed : wyvern.constructors.embeds.EmbedConstructor An single embed object to send, for multiple use `embeds` kwarg instead. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. reply : bool True if you the response should be created a reply. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" if all ([ embed , embeds ]): raise ValueError ( \"You cannot use both embed and embeds kwarg.\" ) embeds = [ embed ] if embed else embeds return await self . client . rest . create_message ( self . channel_id , content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , reference = self . id if reply is True else None , delete_after = delete_after , flags = flags , )","title":"Message"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.attachments","text":"File attachments in this message.","title":"attachments"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.author","text":"The message author.","title":"author"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.channel_id","text":"ID of the channel where this message was sent.","title":"channel_id"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.content","text":"The message content. Needs [wyvern.intents.Intents.MESSAGE_CONTENT] to be access this in a guild context.","title":"content"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.edited_at","text":"When was the message last edited.","title":"edited_at"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.embeds","text":"List of embeds attached to the message.","title":"embeds"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.flags_value","text":"Value of message flags","title":"flags_value"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.id","text":"ID of the message.","title":"id"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.mention_roles","text":"List of ids for roles mentioned in the message.","title":"mention_roles"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.mentions","text":"List of users mentioned in the message.","title":"mentions"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.message_reference","text":"The message reference, if any.","title":"message_reference"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.pinned","text":"Is the message is pinned.","title":"pinned"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.tts","text":"True if the message was a TTS message.","title":"tts"},{"location":"api_reference/models/messages/#wyvern.models.messages.Message.respond","text":"Parameters: Name Type Description Default content str | None The text content of the message. None embed wyvern . constructors . embeds . EmbedConstructor An single embed object to send, for multiple use embeds kwarg instead. None embeds typing . Sequence [ wyvern . constructors . embeds . EmbedConstructor ] Sequence of embeds to send. () components typing . Sequence [ wyvern . components . container . ActionRowContainer ] Sequence of action rows to send. () allowed_mentions wyvern . models . messages . AllowedMentions | None Allowed mentions configs. None reply bool True if you the response should be created a reply. False Returns: Type Description wyvern . models . messages . Message The message object that got created. Source code in wyvern/models/messages.py 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 async def respond ( self , content : str | None = None , * , embed : \"EmbedConstructor\" | None = None , embeds : typing . Sequence [ \"EmbedConstructor\" ] = (), components : typing . Sequence [ \"ActionRowContainer\" ] = (), allowed_mentions : AllowedMentions | None = None , flags : MessageFlags | None = None , delete_after : int | None = None , reply : bool = False , ) -> \"Message\" : \"\"\" Parameters ---------- content : str | None The text content of the message. embed : wyvern.constructors.embeds.EmbedConstructor An single embed object to send, for multiple use `embeds` kwarg instead. embeds : typing.Sequence[wyvern.constructors.embeds.EmbedConstructor] Sequence of embeds to send. components : typing.Sequence[wyvern.components.container.ActionRowContainer] Sequence of action rows to send. allowed_mentions : wyvern.models.messages.AllowedMentions | None Allowed mentions configs. reply : bool True if you the response should be created a reply. Returns ------- wyvern.models.messages.Message The message object that got created. \"\"\" if all ([ embed , embeds ]): raise ValueError ( \"You cannot use both embed and embeds kwarg.\" ) embeds = [ embed ] if embed else embeds return await self . client . rest . create_message ( self . channel_id , content , embeds = embeds , components = components , allowed_mentions = allowed_mentions , reference = self . id if reply is True else None , delete_after = delete_after , flags = flags , )","title":"respond()"},{"location":"api_reference/models/messages/#wyvern.models.messages.MessageReference","text":"Source code in wyvern/models/messages.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @attrs . define ( kw_only = True , slots = True , repr = True ) class MessageReference : channel_id : int | None = None \"\"\"ID of the channel.\"\"\" message_id : int | None = None \"\"\"ID of the message.\"\"\" guild_id : int | None = None \"\"\"ID of the guild, if any.\"\"\" fail_if_not_exists : bool = True \"\"\"Weather to raise error if message does not exist.\"\"\" def to_payload ( self ) -> dict [ str , int | bool | None ]: \"\"\"Converts the object to a sendable payload. Returns ------- dict[str, int| bool] \"\"\" return { \"channel_id\" : self . channel_id , \"message_id\" : self . message_id , \"guild_id\" : self . guild_id , \"fail_if_not_exists\" : self . fail_if_not_exists , }","title":"MessageReference"},{"location":"api_reference/models/messages/#wyvern.models.messages.MessageReference.channel_id","text":"ID of the channel.","title":"channel_id"},{"location":"api_reference/models/messages/#wyvern.models.messages.MessageReference.fail_if_not_exists","text":"Weather to raise error if message does not exist.","title":"fail_if_not_exists"},{"location":"api_reference/models/messages/#wyvern.models.messages.MessageReference.guild_id","text":"ID of the guild, if any.","title":"guild_id"},{"location":"api_reference/models/messages/#wyvern.models.messages.MessageReference.message_id","text":"ID of the message.","title":"message_id"},{"location":"api_reference/models/messages/#wyvern.models.messages.MessageReference.to_payload","text":"Converts the object to a sendable payload. Returns: Type Description dict [ str , int | bool ] Source code in wyvern/models/messages.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def to_payload ( self ) -> dict [ str , int | bool | None ]: \"\"\"Converts the object to a sendable payload. Returns ------- dict[str, int| bool] \"\"\" return { \"channel_id\" : self . channel_id , \"message_id\" : self . message_id , \"guild_id\" : self . guild_id , \"fail_if_not_exists\" : self . fail_if_not_exists , }","title":"to_payload()"},{"location":"api_reference/models/users/","text":"BotUser Bases: User Represents the bot user on discord. Source code in wyvern/models/users.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @typing . final class BotUser ( User ): \"\"\"Represents the bot user on discord.\"\"\" async def edit ( self , username : str | None = None , avatar : bytes | None = None ) -> \"BotUser\" : \"\"\"Edits the bot's user. Arguments --------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" return await self . client . rest . edit_client_user ( username , avatar ) edit ( username = None , avatar = None ) async Edits the bot's user. Arguments username : str The new username. avatar : bytes The new avatar bytes. Returns: Type Description wyvern . models . users . BotUser The updated user of bot. Source code in wyvern/models/users.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 async def edit ( self , username : str | None = None , avatar : bytes | None = None ) -> \"BotUser\" : \"\"\"Edits the bot's user. Arguments --------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" return await self . client . rest . edit_client_user ( username , avatar ) User Bases: DiscordObject Represents a discord user. Source code in wyvern/models/users.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @attrs . define ( kw_only = True , slots = True , repr = True ) class User ( DiscordObject ): \"\"\"Represents a discord user.\"\"\" client : \"GatewayClient\" raw : dict [ str , typing . Any ] id : Snowflake \"\"\"ID of the user.\"\"\" username : str \"\"\"Username of the user.\"\"\" discriminator : str \"\"\"User's discriminator.\"\"\" avatar_hash : str | None \"\"\"Hash of the user's avatar\"\"\" is_bot : bool \"\"\"True if the user is a bot.\"\"\" is_system : bool \"\"\"True if the user is a system user.\"\"\" is_mfa_enabled : bool \"\"\"True if the user has mfa enabled ( can be false even if it's enabled )\"\"\" banner_hash : str | None \"\"\"User's banner hash.\"\"\" accent_color : int | None \"\"\"User's accent color.\"\"\" locale : str | None \"\"\"User's locale.\"\"\" flags_value : int | None \"\"\"Integer value for user flags\"\"\" premium_type_value : int | None \"\"\"Premium type integer.\"\"\" public_flags_value : int | None \"\"\"Integer value for user's public flags\"\"\" def __str__ ( self ) -> str : return f \" { self . username } # { self . discriminator } \" @property def created_at ( self ) -> datetime . datetime : \"\"\"Datetime at which user was created.\"\"\" return self . get_created_at ( self . id ) @property def avatar ( self ) -> Avatar | None : return Avatar ( client = self . client , type = AvatarType . CUSTOM , hash = self . avatar_hash ) if self . avatar_hash else None @property def default_avatar ( self ) -> Avatar : return Avatar ( client = self . client , type = AvatarType . DEFAULT , hash = f \"embed/avatars/ { int ( self . discriminator ) % 5 } \" ) @property def display_avatar ( self ) -> Avatar : return self . avatar or self . default_avatar accent_color : int | None class-attribute User's accent color. avatar_hash : str | None class-attribute Hash of the user's avatar banner_hash : str | None class-attribute User's banner hash. discriminator : str class-attribute User's discriminator. flags_value : int | None class-attribute Integer value for user flags id : Snowflake class-attribute ID of the user. is_bot : bool class-attribute True if the user is a bot. is_mfa_enabled : bool class-attribute True if the user has mfa enabled ( can be false even if it's enabled ) is_system : bool class-attribute True if the user is a system user. locale : str | None class-attribute User's locale. premium_type_value : int | None class-attribute Premium type integer. public_flags_value : int | None class-attribute Integer value for user's public flags username : str class-attribute Username of the user. created_at () property Datetime at which user was created. Source code in wyvern/models/users.py 77 78 79 80 @property def created_at ( self ) -> datetime . datetime : \"\"\"Datetime at which user was created.\"\"\" return self . get_created_at ( self . id )","title":"users"},{"location":"api_reference/models/users/#wyvern.models.users.BotUser","text":"Bases: User Represents the bot user on discord. Source code in wyvern/models/users.py 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 @typing . final class BotUser ( User ): \"\"\"Represents the bot user on discord.\"\"\" async def edit ( self , username : str | None = None , avatar : bytes | None = None ) -> \"BotUser\" : \"\"\"Edits the bot's user. Arguments --------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" return await self . client . rest . edit_client_user ( username , avatar )","title":"BotUser"},{"location":"api_reference/models/users/#wyvern.models.users.BotUser.edit","text":"Edits the bot's user.","title":"edit()"},{"location":"api_reference/models/users/#wyvern.models.users.BotUser.edit--arguments","text":"username : str The new username. avatar : bytes The new avatar bytes. Returns: Type Description wyvern . models . users . BotUser The updated user of bot. Source code in wyvern/models/users.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 async def edit ( self , username : str | None = None , avatar : bytes | None = None ) -> \"BotUser\" : \"\"\"Edits the bot's user. Arguments --------- username : str The new username. avatar : bytes The new avatar bytes. Returns ------- wyvern.models.users.BotUser The updated user of bot. \"\"\" return await self . client . rest . edit_client_user ( username , avatar )","title":"Arguments"},{"location":"api_reference/models/users/#wyvern.models.users.User","text":"Bases: DiscordObject Represents a discord user. Source code in wyvern/models/users.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 @attrs . define ( kw_only = True , slots = True , repr = True ) class User ( DiscordObject ): \"\"\"Represents a discord user.\"\"\" client : \"GatewayClient\" raw : dict [ str , typing . Any ] id : Snowflake \"\"\"ID of the user.\"\"\" username : str \"\"\"Username of the user.\"\"\" discriminator : str \"\"\"User's discriminator.\"\"\" avatar_hash : str | None \"\"\"Hash of the user's avatar\"\"\" is_bot : bool \"\"\"True if the user is a bot.\"\"\" is_system : bool \"\"\"True if the user is a system user.\"\"\" is_mfa_enabled : bool \"\"\"True if the user has mfa enabled ( can be false even if it's enabled )\"\"\" banner_hash : str | None \"\"\"User's banner hash.\"\"\" accent_color : int | None \"\"\"User's accent color.\"\"\" locale : str | None \"\"\"User's locale.\"\"\" flags_value : int | None \"\"\"Integer value for user flags\"\"\" premium_type_value : int | None \"\"\"Premium type integer.\"\"\" public_flags_value : int | None \"\"\"Integer value for user's public flags\"\"\" def __str__ ( self ) -> str : return f \" { self . username } # { self . discriminator } \" @property def created_at ( self ) -> datetime . datetime : \"\"\"Datetime at which user was created.\"\"\" return self . get_created_at ( self . id ) @property def avatar ( self ) -> Avatar | None : return Avatar ( client = self . client , type = AvatarType . CUSTOM , hash = self . avatar_hash ) if self . avatar_hash else None @property def default_avatar ( self ) -> Avatar : return Avatar ( client = self . client , type = AvatarType . DEFAULT , hash = f \"embed/avatars/ { int ( self . discriminator ) % 5 } \" ) @property def display_avatar ( self ) -> Avatar : return self . avatar or self . default_avatar","title":"User"},{"location":"api_reference/models/users/#wyvern.models.users.User.accent_color","text":"User's accent color.","title":"accent_color"},{"location":"api_reference/models/users/#wyvern.models.users.User.avatar_hash","text":"Hash of the user's avatar","title":"avatar_hash"},{"location":"api_reference/models/users/#wyvern.models.users.User.banner_hash","text":"User's banner hash.","title":"banner_hash"},{"location":"api_reference/models/users/#wyvern.models.users.User.discriminator","text":"User's discriminator.","title":"discriminator"},{"location":"api_reference/models/users/#wyvern.models.users.User.flags_value","text":"Integer value for user flags","title":"flags_value"},{"location":"api_reference/models/users/#wyvern.models.users.User.id","text":"ID of the user.","title":"id"},{"location":"api_reference/models/users/#wyvern.models.users.User.is_bot","text":"True if the user is a bot.","title":"is_bot"},{"location":"api_reference/models/users/#wyvern.models.users.User.is_mfa_enabled","text":"True if the user has mfa enabled ( can be false even if it's enabled )","title":"is_mfa_enabled"},{"location":"api_reference/models/users/#wyvern.models.users.User.is_system","text":"True if the user is a system user.","title":"is_system"},{"location":"api_reference/models/users/#wyvern.models.users.User.locale","text":"User's locale.","title":"locale"},{"location":"api_reference/models/users/#wyvern.models.users.User.premium_type_value","text":"Premium type integer.","title":"premium_type_value"},{"location":"api_reference/models/users/#wyvern.models.users.User.public_flags_value","text":"Integer value for user's public flags","title":"public_flags_value"},{"location":"api_reference/models/users/#wyvern.models.users.User.username","text":"Username of the user.","title":"username"},{"location":"api_reference/models/users/#wyvern.models.users.User.created_at","text":"Datetime at which user was created. Source code in wyvern/models/users.py 77 78 79 80 @property def created_at ( self ) -> datetime . datetime : \"\"\"Datetime at which user was created.\"\"\" return self . get_created_at ( self . id )","title":"created_at()"},{"location":"api_reference/state_handlers/users/","text":"UsersState A handler for user cache and rest connection with the client. This interface can be used to get/fetch users with convinience. Source code in wyvern/state_handlers/users.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class UsersState : \"\"\"A handler for user cache and rest connection with the client. This interface can be used to get/fetch users with convinience. \"\"\" _client : \"GatewayClient\" cached_users : dict [ int , \"User\" ] = {} \"\"\"Mapping of cached users with their ID : Object\"\"\" def __init__ ( self , client : \"GatewayClient\" ) -> None : self . _client = client def get ( self , user_id : int ) -> \"User\" | None : \"\"\"Fetchs a user using the state cache.. Parameters ---------- user_id : int ID of the user that is to be to get. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" return self . cached_users . get ( user_id ) async def fetch ( self , user_id : int ) -> \"User\" : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.UserNotFound The targetted user was not found. \"\"\" return await self . _client . rest . fetch_user ( user_id ) def get_user_named ( self , name : str ) -> \"User\" | None : \"\"\"Gets a member named the provided argument from cache Parameters ---------- name : str Name to lookup for. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" users = [ user for user in self . cached_users . values () if user . username == name ] return users [ 0 ] if users != [] else None def parse_from_string ( self , string : str ) -> \"User\" | None : \"\"\" Parses a user object from a string The order for parsing: * Lookup for mentions. * Lookup for username#discriminator. * Lookup for username only. Parameters ---------- string : str The string to parse from. Returns ------- wyvern.models.users.User | None The user object that was parsed, if any. \"\"\" if string . startswith ( \"<@\" ) and string . endswith ( \">\" ): return self . get ( int ( string . strip ( \"<@!>\" ))) elif \"#\" in string : username , discriminator = string . split ( \"#\" ) users = [ user for user in self . cached_users . values () if user . username == username and int ( user . discriminator ) == int ( discriminator ) ] if users != []: return users [ 0 ] else : pass elif user := self . get_user_named ( string ): return user return None def _add_to_state ( self , * users : \"User\" ) -> None : for user in users : self . cached_users [ user . id ] = user cached_users : dict [ int , User ] = {} class-attribute Mapping of cached users with their ID : Object fetch ( user_id ) async Fetchs a user using the REST api. Parameters: Name Type Description Default user_id int ID of the user that is to be fetched. required Returns: Type Description wyvern . models . users . User The user object that was fetched. Raises: Type Description wyvern . exceptions . UserNotFound The targetted user was not found. Source code in wyvern/state_handlers/users.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 async def fetch ( self , user_id : int ) -> \"User\" : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.UserNotFound The targetted user was not found. \"\"\" return await self . _client . rest . fetch_user ( user_id ) get ( user_id ) Fetchs a user using the state cache.. Parameters: Name Type Description Default user_id int ID of the user that is to be to get. required Returns: Type Description wyvern . models . users . User | None The user object that was fetched. Source code in wyvern/state_handlers/users.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def get ( self , user_id : int ) -> \"User\" | None : \"\"\"Fetchs a user using the state cache.. Parameters ---------- user_id : int ID of the user that is to be to get. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" return self . cached_users . get ( user_id ) get_user_named ( name ) Gets a member named the provided argument from cache Parameters: Name Type Description Default name str Name to lookup for. required Returns: Type Description wyvern . models . users . User | None The user object that was fetched. Source code in wyvern/state_handlers/users.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_user_named ( self , name : str ) -> \"User\" | None : \"\"\"Gets a member named the provided argument from cache Parameters ---------- name : str Name to lookup for. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" users = [ user for user in self . cached_users . values () if user . username == name ] return users [ 0 ] if users != [] else None parse_from_string ( string ) Parses a user object from a string The order for parsing: Lookup for mentions. Lookup for username#discriminator. Lookup for username only. Parameters: Name Type Description Default string str The string to parse from. required Returns: Type Description wyvern . models . users . User | None The user object that was parsed, if any. Source code in wyvern/state_handlers/users.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def parse_from_string ( self , string : str ) -> \"User\" | None : \"\"\" Parses a user object from a string The order for parsing: * Lookup for mentions. * Lookup for username#discriminator. * Lookup for username only. Parameters ---------- string : str The string to parse from. Returns ------- wyvern.models.users.User | None The user object that was parsed, if any. \"\"\" if string . startswith ( \"<@\" ) and string . endswith ( \">\" ): return self . get ( int ( string . strip ( \"<@!>\" ))) elif \"#\" in string : username , discriminator = string . split ( \"#\" ) users = [ user for user in self . cached_users . values () if user . username == username and int ( user . discriminator ) == int ( discriminator ) ] if users != []: return users [ 0 ] else : pass elif user := self . get_user_named ( string ): return user return None","title":"users"},{"location":"api_reference/state_handlers/users/#wyvern.state_handlers.users.UsersState","text":"A handler for user cache and rest connection with the client. This interface can be used to get/fetch users with convinience. Source code in wyvern/state_handlers/users.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 class UsersState : \"\"\"A handler for user cache and rest connection with the client. This interface can be used to get/fetch users with convinience. \"\"\" _client : \"GatewayClient\" cached_users : dict [ int , \"User\" ] = {} \"\"\"Mapping of cached users with their ID : Object\"\"\" def __init__ ( self , client : \"GatewayClient\" ) -> None : self . _client = client def get ( self , user_id : int ) -> \"User\" | None : \"\"\"Fetchs a user using the state cache.. Parameters ---------- user_id : int ID of the user that is to be to get. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" return self . cached_users . get ( user_id ) async def fetch ( self , user_id : int ) -> \"User\" : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.UserNotFound The targetted user was not found. \"\"\" return await self . _client . rest . fetch_user ( user_id ) def get_user_named ( self , name : str ) -> \"User\" | None : \"\"\"Gets a member named the provided argument from cache Parameters ---------- name : str Name to lookup for. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" users = [ user for user in self . cached_users . values () if user . username == name ] return users [ 0 ] if users != [] else None def parse_from_string ( self , string : str ) -> \"User\" | None : \"\"\" Parses a user object from a string The order for parsing: * Lookup for mentions. * Lookup for username#discriminator. * Lookup for username only. Parameters ---------- string : str The string to parse from. Returns ------- wyvern.models.users.User | None The user object that was parsed, if any. \"\"\" if string . startswith ( \"<@\" ) and string . endswith ( \">\" ): return self . get ( int ( string . strip ( \"<@!>\" ))) elif \"#\" in string : username , discriminator = string . split ( \"#\" ) users = [ user for user in self . cached_users . values () if user . username == username and int ( user . discriminator ) == int ( discriminator ) ] if users != []: return users [ 0 ] else : pass elif user := self . get_user_named ( string ): return user return None def _add_to_state ( self , * users : \"User\" ) -> None : for user in users : self . cached_users [ user . id ] = user","title":"UsersState"},{"location":"api_reference/state_handlers/users/#wyvern.state_handlers.users.UsersState.cached_users","text":"Mapping of cached users with their ID : Object","title":"cached_users"},{"location":"api_reference/state_handlers/users/#wyvern.state_handlers.users.UsersState.fetch","text":"Fetchs a user using the REST api. Parameters: Name Type Description Default user_id int ID of the user that is to be fetched. required Returns: Type Description wyvern . models . users . User The user object that was fetched. Raises: Type Description wyvern . exceptions . UserNotFound The targetted user was not found. Source code in wyvern/state_handlers/users.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 async def fetch ( self , user_id : int ) -> \"User\" : \"\"\"Fetchs a user using the REST api. Parameters ---------- user_id : int ID of the user that is to be fetched. Returns ------- wyvern.models.users.User The user object that was fetched. Raises ------ wyvern.exceptions.UserNotFound The targetted user was not found. \"\"\" return await self . _client . rest . fetch_user ( user_id )","title":"fetch()"},{"location":"api_reference/state_handlers/users/#wyvern.state_handlers.users.UsersState.get","text":"Fetchs a user using the state cache.. Parameters: Name Type Description Default user_id int ID of the user that is to be to get. required Returns: Type Description wyvern . models . users . User | None The user object that was fetched. Source code in wyvern/state_handlers/users.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def get ( self , user_id : int ) -> \"User\" | None : \"\"\"Fetchs a user using the state cache.. Parameters ---------- user_id : int ID of the user that is to be to get. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" return self . cached_users . get ( user_id )","title":"get()"},{"location":"api_reference/state_handlers/users/#wyvern.state_handlers.users.UsersState.get_user_named","text":"Gets a member named the provided argument from cache Parameters: Name Type Description Default name str Name to lookup for. required Returns: Type Description wyvern . models . users . User | None The user object that was fetched. Source code in wyvern/state_handlers/users.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def get_user_named ( self , name : str ) -> \"User\" | None : \"\"\"Gets a member named the provided argument from cache Parameters ---------- name : str Name to lookup for. Returns ------- wyvern.models.users.User | None The user object that was fetched. \"\"\" users = [ user for user in self . cached_users . values () if user . username == name ] return users [ 0 ] if users != [] else None","title":"get_user_named()"},{"location":"api_reference/state_handlers/users/#wyvern.state_handlers.users.UsersState.parse_from_string","text":"Parses a user object from a string The order for parsing: Lookup for mentions. Lookup for username#discriminator. Lookup for username only. Parameters: Name Type Description Default string str The string to parse from. required Returns: Type Description wyvern . models . users . User | None The user object that was parsed, if any. Source code in wyvern/state_handlers/users.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 def parse_from_string ( self , string : str ) -> \"User\" | None : \"\"\" Parses a user object from a string The order for parsing: * Lookup for mentions. * Lookup for username#discriminator. * Lookup for username only. Parameters ---------- string : str The string to parse from. Returns ------- wyvern.models.users.User | None The user object that was parsed, if any. \"\"\" if string . startswith ( \"<@\" ) and string . endswith ( \">\" ): return self . get ( int ( string . strip ( \"<@!>\" ))) elif \"#\" in string : username , discriminator = string . split ( \"#\" ) users = [ user for user in self . cached_users . values () if user . username == username and int ( user . discriminator ) == int ( discriminator ) ] if users != []: return users [ 0 ] else : pass elif user := self . get_user_named ( string ): return user return None","title":"parse_from_string()"},{"location":"commands/client/","text":"The commands extension works with CommandsClient which is a subclass of GatewayClient . Bases: GatewayClient , commands . CommandHandler Implementation of the wyvern.GatewayClient class with a command handler. Source code in wyvern/clients.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 class CommandsClient ( GatewayClient , commands . CommandHandler ): \"\"\"Implementation of the [wyvern.GatewayClient][] class with a command handler.\"\"\" slash_commands : dict [ str , \"commands.slash_commands.SlashCommand\" ] = {} \"\"\"List of slash commands attached to the client in code.\"\"\" slash_groups : dict [ str , \"commands.slash_commands.SlashGroup\" ] = {} \"\"\"List of slash command groups attached to the client in code.\"\"\" @events . as_listener ( events . Event . INTERACTION_CREATE ) async def _handle_inters ( self , inter : interactions . Interaction ) -> None : if isinstance ( inter , interactions . ApplicationCommandInteraction ): await self . process_application_commands ( inter ) def add_slash_command ( self , command : commands . slash_commands . SlashCommand ) -> None : if ( name := command . name ) in self . slash_commands . keys (): raise exceptions . CommandAlreadyExists ( f \"A slash command named { name } already exists.\" ) _LOGGER . debug ( f \"Adding slash command { name } to bot.\" ) self . slash_commands [ name ] = command def add_slash_group ( self , group : commands . slash_commands . SlashGroup ) -> None : if ( name := group . name ) in self . slash_groups . keys (): raise exceptions . CommandAlreadyExists ( f \"A slash command named { name } already exists.\" ) _LOGGER . debug ( f \"Adding slash group { name } to bot.\" ) self . slash_groups [ name ] = group @typing . overload def add_item ( self , listener_or_command : events . EventListener ) -> events . EventListener : ... @typing . overload def add_item ( self , listener_or_command : commands . slash_commands . SlashCommand ) -> commands . slash_commands . SlashCommand : ... def add_item ( self , listener_or_command : events . EventListener | commands . slash_commands . SlashCommand | typing . Any ) -> events . EventListener | commands . slash_commands . SlashCommand : def inner () -> None : nonlocal listener_or_command if isinstance ( listener_or_command , events . EventListener ): self . event_handler . add_listener ( listener_or_command ) elif isinstance ( listener_or_command , commands . slash_commands . SlashCommand ): self . add_slash_command ( listener_or_command ) inner () return listener_or_command def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner slash_commands : dict [ str , commands . slash_commands . SlashCommand ] = {} class-attribute List of slash commands attached to the client in code. slash_groups : dict [ str , commands . slash_commands . SlashGroup ] = {} class-attribute List of slash command groups attached to the client in code. set_prefix ( prefix_or_function ) Set a prefix to parse message commands. Allowed prefix data strings : str iterables : list / set / tuple callables : builtins.function or a asyncio.coroutine . Source code in wyvern/clients.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self with_slash_command ( * , name , description ) Creates a slash command. Parameters: Name Type Description Default name str Name of the command. required description str Description of the command. required Returns: Type Description typing . Callable [..., commands . slash_commands . SlashCommand ] A wyvern.commands.slash_commands.SlashCommand when called. Source code in wyvern/clients.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner","title":"client"},{"location":"commands/client/#wyvern.clients.CommandsClient.slash_commands","text":"List of slash commands attached to the client in code.","title":"slash_commands"},{"location":"commands/client/#wyvern.clients.CommandsClient.slash_groups","text":"List of slash command groups attached to the client in code.","title":"slash_groups"},{"location":"commands/client/#wyvern.clients.CommandsClient.set_prefix","text":"Set a prefix to parse message commands. Allowed prefix data strings : str iterables : list / set / tuple callables : builtins.function or a asyncio.coroutine . Source code in wyvern/clients.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 def set_prefix ( self , prefix_or_function : str | typing . Sequence [ str ] | builtins . function ) -> \"CommandsClient\" : \"\"\" Set a prefix to parse message commands. Allowed prefix data ------------------- * strings : [str][] * iterables : [list][] / [set][] / [tuple][] * callables : [builtins.function][] or a [asyncio.coroutine][]. \"\"\" if isinstance ( prefix_or_function , str ): self . prefix_type = str elif ( isinstance ( prefix_or_function , list ) or isinstance ( prefix_or_function , tuple ) or isinstance ( prefix_or_function , set ) ): self . prefix_type = type ( prefix_or_function ) elif isinstance ( prefix_or_function , builtins . function ): self . prefix_type = builtins . function return self","title":"set_prefix()"},{"location":"commands/client/#wyvern.clients.CommandsClient.with_slash_command","text":"Creates a slash command. Parameters: Name Type Description Default name str Name of the command. required description str Description of the command. required Returns: Type Description typing . Callable [..., commands . slash_commands . SlashCommand ] A wyvern.commands.slash_commands.SlashCommand when called. Source code in wyvern/clients.py 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 def with_slash_command ( self , * , name : str , description : str , ) -> typing . Callable [[ AppCommandCallbackT ], commands . slash_commands . SlashCommand ]: \"\"\"Creates a slash command. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[..., commands.slash_commands.SlashCommand] A [wyvern.commands.slash_commands.SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> commands . slash_commands . SlashCommand : cmd = commands . as_slash_command ( name = name , description = description )( callback ) self . add_slash_command ( cmd . _set_client ( self )) return cmd return inner","title":"with_slash_command()"},{"location":"commands/command_handler/","text":"CommandHandler Command Handler for interacting with interaction and prefix commands. Note This class is purely created to be implemented with the GatewayClient subclass for the wyvern.CommandsClient class. Source code in wyvern/commands/command_handler.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class CommandHandler : \"\"\"Command Handler for interacting with interaction and prefix commands. !!! note This class is purely created to be implemented with the GatewayClient subclass for the [wyvern.CommandsClient][] class. \"\"\" prefix_getter : typing . Any = None prefix_type : type | None = None slash_commands : dict [ str , SlashCommand ] async def get_prefixes ( self , message : Message ) -> typing . Any : \"\"\"Get's a list of prefix with respect to the message. Parameters ---------- message : wyvern.Message The message to get prefixes for. Returns ------- typing.Any \"\"\" if self . prefix_type is str : return [ self . prefix_getter ] elif type ( self . prefix_getter ) in [ set , list , tuple ]: return self . prefix_getter else : if inspect . iscoroutinefunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := await self . prefix_getter ( self , message )), str ) else prefix elif inspect . isfunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := self . prefix_getter ( self , message )), str ) else prefix async def process_application_commands ( self , interaction : ApplicationCommandInteraction ) -> None : \"\"\"Processes application command interactions for app commands. Parameters ---------- interaction : wyvern.ApplicationCommandInteraction The interaction to process. \"\"\" command = self . slash_commands . get ( interaction . data . command_name ) if command is not None : await command ( interaction , ) get_prefixes ( message ) async Get's a list of prefix with respect to the message. Parameters: Name Type Description Default message wyvern . Message The message to get prefixes for. required Returns: Type Description typing . Any Source code in wyvern/commands/command_handler.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 async def get_prefixes ( self , message : Message ) -> typing . Any : \"\"\"Get's a list of prefix with respect to the message. Parameters ---------- message : wyvern.Message The message to get prefixes for. Returns ------- typing.Any \"\"\" if self . prefix_type is str : return [ self . prefix_getter ] elif type ( self . prefix_getter ) in [ set , list , tuple ]: return self . prefix_getter else : if inspect . iscoroutinefunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := await self . prefix_getter ( self , message )), str ) else prefix elif inspect . isfunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := self . prefix_getter ( self , message )), str ) else prefix process_application_commands ( interaction ) async Processes application command interactions for app commands. Parameters: Name Type Description Default interaction wyvern . ApplicationCommandInteraction The interaction to process. required Source code in wyvern/commands/command_handler.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 async def process_application_commands ( self , interaction : ApplicationCommandInteraction ) -> None : \"\"\"Processes application command interactions for app commands. Parameters ---------- interaction : wyvern.ApplicationCommandInteraction The interaction to process. \"\"\" command = self . slash_commands . get ( interaction . data . command_name ) if command is not None : await command ( interaction , )","title":"command_handler"},{"location":"commands/command_handler/#wyvern.commands.command_handler.CommandHandler","text":"Command Handler for interacting with interaction and prefix commands. Note This class is purely created to be implemented with the GatewayClient subclass for the wyvern.CommandsClient class. Source code in wyvern/commands/command_handler.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 class CommandHandler : \"\"\"Command Handler for interacting with interaction and prefix commands. !!! note This class is purely created to be implemented with the GatewayClient subclass for the [wyvern.CommandsClient][] class. \"\"\" prefix_getter : typing . Any = None prefix_type : type | None = None slash_commands : dict [ str , SlashCommand ] async def get_prefixes ( self , message : Message ) -> typing . Any : \"\"\"Get's a list of prefix with respect to the message. Parameters ---------- message : wyvern.Message The message to get prefixes for. Returns ------- typing.Any \"\"\" if self . prefix_type is str : return [ self . prefix_getter ] elif type ( self . prefix_getter ) in [ set , list , tuple ]: return self . prefix_getter else : if inspect . iscoroutinefunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := await self . prefix_getter ( self , message )), str ) else prefix elif inspect . isfunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := self . prefix_getter ( self , message )), str ) else prefix async def process_application_commands ( self , interaction : ApplicationCommandInteraction ) -> None : \"\"\"Processes application command interactions for app commands. Parameters ---------- interaction : wyvern.ApplicationCommandInteraction The interaction to process. \"\"\" command = self . slash_commands . get ( interaction . data . command_name ) if command is not None : await command ( interaction , )","title":"CommandHandler"},{"location":"commands/command_handler/#wyvern.commands.command_handler.CommandHandler.get_prefixes","text":"Get's a list of prefix with respect to the message. Parameters: Name Type Description Default message wyvern . Message The message to get prefixes for. required Returns: Type Description typing . Any Source code in wyvern/commands/command_handler.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 async def get_prefixes ( self , message : Message ) -> typing . Any : \"\"\"Get's a list of prefix with respect to the message. Parameters ---------- message : wyvern.Message The message to get prefixes for. Returns ------- typing.Any \"\"\" if self . prefix_type is str : return [ self . prefix_getter ] elif type ( self . prefix_getter ) in [ set , list , tuple ]: return self . prefix_getter else : if inspect . iscoroutinefunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := await self . prefix_getter ( self , message )), str ) else prefix elif inspect . isfunction ( self . prefix_getter ): return [ prefix ] if isinstance (( prefix := self . prefix_getter ( self , message )), str ) else prefix","title":"get_prefixes()"},{"location":"commands/command_handler/#wyvern.commands.command_handler.CommandHandler.process_application_commands","text":"Processes application command interactions for app commands. Parameters: Name Type Description Default interaction wyvern . ApplicationCommandInteraction The interaction to process. required Source code in wyvern/commands/command_handler.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 async def process_application_commands ( self , interaction : ApplicationCommandInteraction ) -> None : \"\"\"Processes application command interactions for app commands. Parameters ---------- interaction : wyvern.ApplicationCommandInteraction The interaction to process. \"\"\" command = self . slash_commands . get ( interaction . data . command_name ) if command is not None : await command ( interaction , )","title":"process_application_commands()"},{"location":"commands/slash_commands/","text":"Slash commands support. CommandChoice Represents a slash command choice. Parameters: Name Type Description Default name str Name to show on discord. required value str | int Value of the choice. required Source code in wyvern/commands/slash_commands.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @attrs . define ( kw_only = True ) class CommandChoice : \"\"\"Represents a slash command choice. Parameters ---------- name : str Name to show on discord. value : str | int Value of the choice. \"\"\" name : str value : str | int name_locales : dict [ str , Localizations ] | utils . Empty = utils . EMPTY def to_payload ( self ) -> dict [ str , str | int | dict [ str , dict [ str , str ]]]: return { \"name\" : self . name , \"value\" : self . value or self . name , \"name_localizations\" : { name : local . final_data for name , local in _locale . items ()} if not isinstance (( _locale := self . name_locales ), utils . Empty ) else {}, } CommandOption Represents a slash command option. (In the constructor) Source code in wyvern/commands/slash_commands.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @attrs . define ( kw_only = True ) class CommandOption : \"\"\"Represents a slash command option. (In the constructor)\"\"\" name : str \"\"\"Name of the option.\"\"\" name_locales : Localizations | utils . Empty = utils . EMPTY \"\"\"Name locales for the option.\"\"\" description : str \"\"\"Description of the option.\"\"\" description_locales : Localizations | utils . Empty = utils . EMPTY \"\"\"Description locales for the option.\"\"\" default : typing . Any = utils . EMPTY \"\"\"Default value for the option\"\"\" type : OptionType \"\"\"Type of the option.\"\"\" converter : SlashOptionConverter | None = None \"\"\"A custom converter for the option, if any.\"\"\" autocomplete : bool = False \"\"\"Weather to enable autocomplete for this option or not.\"\"\" choices : list [ CommandChoice | str | int ] = [] \"\"\"List of choices to add to the option.\"\"\" channel_types : list [ ChannelType ] = [] \"\"\"List of channel types for channel options.\"\"\" min_value : int | None = None \"\"\"Minimum value for the option\"\"\" max_value : int | None = None \"\"\"Maximum value for the option\"\"\" min_length : int | None = None \"\"\"Minimum length acceptable for the option\"\"\" max_length : int | None = None \"\"\"Maximum length acceptable for the option\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"name\" : self . name , \"description\" : self . description , \"required\" : False if self . default is utils . EMPTY else True , \"type\" : self . type , \"autocomplete\" : self . autocomplete , \"choices\" : [ ( choice . to_payload () if isinstance ( choice , CommandChoice ) else { \"name\" : choice , \"value\" : choice }) for choice in self . choices ], \"channel_types\" : self . channel_types , \"min_value\" : self . min_value , \"min_length\" : self . min_length , \"max_length\" : self . max_length , \"max_value\" : self . max_value , \"name_localizations\" : _locale . final_data if not isinstance (( _locale := self . name_locales ), utils . Empty ) else {}, \"description_localizations\" : _locale . final_data if not isinstance (( _locale := self . description_locales ), utils . Empty ) else {}, } autocomplete : bool = False class-attribute Weather to enable autocomplete for this option or not. channel_types : list [ ChannelType ] = [] class-attribute List of channel types for channel options. choices : list [ CommandChoice | str | int ] = [] class-attribute List of choices to add to the option. converter : SlashOptionConverter | None = None class-attribute A custom converter for the option, if any. default : typing . Any = utils . EMPTY class-attribute Default value for the option description : str class-attribute Description of the option. description_locales : Localizations | utils . Empty = utils . EMPTY class-attribute Description locales for the option. max_length : int | None = None class-attribute Maximum length acceptable for the option max_value : int | None = None class-attribute Maximum value for the option min_length : int | None = None class-attribute Minimum length acceptable for the option min_value : int | None = None class-attribute Minimum value for the option name : str class-attribute Name of the option. name_locales : Localizations | utils . Empty = utils . EMPTY class-attribute Name locales for the option. type : OptionType class-attribute Type of the option. SlashCommand Bases: BaseCallable , HasAutoComplete Represents a slash command constructor. Source code in wyvern/commands/slash_commands.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @attrs . define ( kw_only = True , slots = True , repr = True ) class SlashCommand ( BaseCallable , HasAutoComplete ): \"\"\"Represents a slash command constructor.\"\"\" name : str \"\"\"Name of the command.\"\"\" description : str \"\"\"Description of the command.\"\"\" options : list [ CommandOption ] = attrs . field ( init = False , default = []) \"\"\"List of command options.\"\"\" guild_only : bool = False \"\"\"Set to True for command to appear in guilds only.\"\"\" client : CommandsClient | None = attrs . field ( init = False , default = None ) callback : AppCommandCallbackT guild_ids : list [ int ] = [] \"\"\"\"\"\" def __str__ ( self ) -> str : return self . name async def __call__ ( self , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : await self . callback ( * args , ** kwargs ) def _set_client ( self , client : CommandsClient ) -> \"SlashCommand\" : self . client = client return self def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"name\" : self . name , \"description\" : self . description , \"options\" : [ option . to_payload () for option in self . options ], \"dm_permissions\" : not self . guild_only , \"type\" : interactions . base . InteractionCommandType . MESSAGE , } async def with_autocomplete ( self , opt_name : str | None = None , * , opt_names : typing . Sequence [ str ] = () ) -> typing . Callable [ ... , typing . Callable [ ... , typing . Awaitable [ typing . Sequence [ CommandChoice | str ]]]]: \"\"\"Interface for creating autocomplete callabcks. Parameters ---------- opt_name : str Name of the option this autocomplete is for. opt_names : typing.Sequence[str] Sequence of options this autocomplete is for. !!! note opt_names overrides opt_name ??? example ```py from __future__ import annotations import wyvern from wyvern import commands client = wyvern.CommandsClient(\"TOKEN\") @commands.with_option( name=\"color\", description=\"name of color to show hex of.\", type=commands.OptionType.INTEGER, autocomplete=True ) @client.slash_command(name=\"color_hex\", description=\"gives you color hexs\") async def colors(inter: wyvern.ApplicationCommandInteraction, color: int) -> None: await inter.create_message_response(f\"Hex for the color was {hex}\") @colors.with_autocomplete(opt_name=\"color\") async def autocomplete_inter( inter: wyvern.AutocompleteInteraction, option: wyvern.InteractionOption ) -> list[commands.CommandChoice]: colors = [commands.CommandChoice(name=\"blue\", value=0x4F62A3), commands.CommandChoice(name=\"red\", value=0xD11417)] return [color for color in colors if color.name in inter.data.value] client.run() ``` \"\"\" # noqa: E501 return await super () . with_autocomplete ( opt_name , opt_names = opt_names ) async def create_command ( self ) -> SlashCommand : \"\"\"Creates the command on discord ( if already doesnt exist ). Returns ------- wyvern.commands.SlashCommand This same object \"\"\" assert self . client await self . client . rest . _create_app_command_from_payload ( payload = self . to_payload ()) return self description : str class-attribute Description of the command. guild_only : bool = False class-attribute Set to True for command to appear in guilds only. name : str class-attribute Name of the command. options : list [ CommandOption ] = attrs . field ( init = False , default = []) class-attribute List of command options. create_command () async Creates the command on discord ( if already doesnt exist ). Returns: Type Description wyvern . commands . SlashCommand This same object Source code in wyvern/commands/slash_commands.py 224 225 226 227 228 229 230 231 232 233 234 235 async def create_command ( self ) -> SlashCommand : \"\"\"Creates the command on discord ( if already doesnt exist ). Returns ------- wyvern.commands.SlashCommand This same object \"\"\" assert self . client await self . client . rest . _create_app_command_from_payload ( payload = self . to_payload ()) return self with_autocomplete ( opt_name = None , * , opt_names = ()) async Interface for creating autocomplete callabcks. Parameters: Name Type Description Default opt_name str Name of the option this autocomplete is for. None opt_names typing . Sequence [ str ] Sequence of options this autocomplete is for. () Note opt_names overrides opt_name Example from __future__ import annotations import wyvern from wyvern import commands client = wyvern . CommandsClient ( \"TOKEN\" ) @commands . with_option ( name = \"color\" , description = \"name of color to show hex of.\" , type = commands . OptionType . INTEGER , autocomplete = True ) @client . slash_command ( name = \"color_hex\" , description = \"gives you color hexs\" ) async def colors ( inter : wyvern . ApplicationCommandInteraction , color : int ) -> None : await inter . create_message_response ( f \"Hex for the color was { hex } \" ) @colors . with_autocomplete ( opt_name = \"color\" ) async def autocomplete_inter ( inter : wyvern . AutocompleteInteraction , option : wyvern . InteractionOption ) -> list [ commands . CommandChoice ]: colors = [ commands . CommandChoice ( name = \"blue\" , value = 0x4F62A3 ), commands . CommandChoice ( name = \"red\" , value = 0xD11417 )] return [ color for color in colors if color . name in inter . data . value ] client . run () Source code in wyvern/commands/slash_commands.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 async def with_autocomplete ( self , opt_name : str | None = None , * , opt_names : typing . Sequence [ str ] = () ) -> typing . Callable [ ... , typing . Callable [ ... , typing . Awaitable [ typing . Sequence [ CommandChoice | str ]]]]: \"\"\"Interface for creating autocomplete callabcks. Parameters ---------- opt_name : str Name of the option this autocomplete is for. opt_names : typing.Sequence[str] Sequence of options this autocomplete is for. !!! note opt_names overrides opt_name ??? example ```py from __future__ import annotations import wyvern from wyvern import commands client = wyvern.CommandsClient(\"TOKEN\") @commands.with_option( name=\"color\", description=\"name of color to show hex of.\", type=commands.OptionType.INTEGER, autocomplete=True ) @client.slash_command(name=\"color_hex\", description=\"gives you color hexs\") async def colors(inter: wyvern.ApplicationCommandInteraction, color: int) -> None: await inter.create_message_response(f\"Hex for the color was {hex}\") @colors.with_autocomplete(opt_name=\"color\") async def autocomplete_inter( inter: wyvern.AutocompleteInteraction, option: wyvern.InteractionOption ) -> list[commands.CommandChoice]: colors = [commands.CommandChoice(name=\"blue\", value=0x4F62A3), commands.CommandChoice(name=\"red\", value=0xD11417)] return [color for color in colors if color.name in inter.data.value] client.run() ``` \"\"\" # noqa: E501 return await super () . with_autocomplete ( opt_name , opt_names = opt_names ) as_slash_command ( * , name , description , guild_ids = (), guild_only = False ) Creates a slash command object. Parameters: Name Type Description Default name str Name of the command. required description str Description of the command. required Returns: Type Description typing . Callable [[ AppCommandCallbackT ], SlashCommand ] A SlashCommand when called. Source code in wyvern/commands/slash_commands.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def as_slash_command ( * , name : str , description : str , guild_ids : typing . Sequence [ int ] = (), guild_only : bool = False , ) -> typing . Callable [[ AppCommandCallbackT ], SlashCommand ]: \"\"\"Creates a slash command object. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[[AppCommandCallbackT], SlashCommand] A [SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> SlashCommand : return SlashCommand ( name = name , description = description , callback = callback , guild_ids = list ( guild_ids ), guild_only = guild_only ) return inner with_option ( * , name , description , type = OptionType . STRING , default = utils . EMPTY , converter = None , autocomplete = False , choices = [], channel_types = [], min_value = None , max_value = None , min_length = None , max_length = None , name_locales = utils . EMPTY , description_locales = utils . EMPTY ) Adds an option to a slash command. Parameters: Name Type Description Default name str Name of the option. required description str Description of the option. required type OptionType Type of the option. OptionType.STRING default typing . Any Default value for the option. utils.EMPTY convertor SlashOptionConvertor | None A custom convertor if any. required autcomplete bool Is autcomplete enabled for this option ( defaults to False ) required Returns: Type Description typing . Callable [[ SlashCommand ], SlashCommand ] The command this option was added to. Source code in wyvern/commands/slash_commands.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def with_option ( * , name : str , description : str , type : OptionType = OptionType . STRING , default : typing . Any = utils . EMPTY , converter : SlashOptionConverter | None = None , autocomplete : bool = False , choices : typing . Sequence [ CommandChoice | str | int ] = [], channel_types : typing . Sequence [ \"ChannelType\" ] = [], min_value : int | None = None , max_value : int | None = None , min_length : int | None = None , max_length : int | None = None , name_locales : Localizations | utils . Empty = utils . EMPTY , description_locales : Localizations | utils . Empty = utils . EMPTY , ) -> typing . Callable [[ SlashCommand ], SlashCommand ]: \"\"\"Adds an option to a slash command. Parameters ---------- name : str Name of the option. description : str Description of the option. type : OptionType Type of the option. default : typing.Any Default value for the option. convertor : SlashOptionConvertor | None A custom convertor if any. autcomplete : bool Is autcomplete enabled for this option ( defaults to False ) Returns ------- typing.Callable[[SlashCommand], SlashCommand] The command this option was added to. \"\"\" def inner ( command : SlashCommand ) -> SlashCommand : command . options . append ( CommandOption ( name = name , description = description , default = default , type = type , converter = converter , autocomplete = autocomplete , choices = list ( choices ), channel_types = list ( channel_types ), min_length = min_length , min_value = min_value , max_length = max_length , max_value = max_value , name_locales = name_locales , description_locales = description_locales , ) ) return command return inner","title":"slash_commands"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandChoice","text":"Represents a slash command choice. Parameters: Name Type Description Default name str Name to show on discord. required value str | int Value of the choice. required Source code in wyvern/commands/slash_commands.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 @attrs . define ( kw_only = True ) class CommandChoice : \"\"\"Represents a slash command choice. Parameters ---------- name : str Name to show on discord. value : str | int Value of the choice. \"\"\" name : str value : str | int name_locales : dict [ str , Localizations ] | utils . Empty = utils . EMPTY def to_payload ( self ) -> dict [ str , str | int | dict [ str , dict [ str , str ]]]: return { \"name\" : self . name , \"value\" : self . value or self . name , \"name_localizations\" : { name : local . final_data for name , local in _locale . items ()} if not isinstance (( _locale := self . name_locales ), utils . Empty ) else {}, }","title":"CommandChoice"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption","text":"Represents a slash command option. (In the constructor) Source code in wyvern/commands/slash_commands.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @attrs . define ( kw_only = True ) class CommandOption : \"\"\"Represents a slash command option. (In the constructor)\"\"\" name : str \"\"\"Name of the option.\"\"\" name_locales : Localizations | utils . Empty = utils . EMPTY \"\"\"Name locales for the option.\"\"\" description : str \"\"\"Description of the option.\"\"\" description_locales : Localizations | utils . Empty = utils . EMPTY \"\"\"Description locales for the option.\"\"\" default : typing . Any = utils . EMPTY \"\"\"Default value for the option\"\"\" type : OptionType \"\"\"Type of the option.\"\"\" converter : SlashOptionConverter | None = None \"\"\"A custom converter for the option, if any.\"\"\" autocomplete : bool = False \"\"\"Weather to enable autocomplete for this option or not.\"\"\" choices : list [ CommandChoice | str | int ] = [] \"\"\"List of choices to add to the option.\"\"\" channel_types : list [ ChannelType ] = [] \"\"\"List of channel types for channel options.\"\"\" min_value : int | None = None \"\"\"Minimum value for the option\"\"\" max_value : int | None = None \"\"\"Maximum value for the option\"\"\" min_length : int | None = None \"\"\"Minimum length acceptable for the option\"\"\" max_length : int | None = None \"\"\"Maximum length acceptable for the option\"\"\" def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"name\" : self . name , \"description\" : self . description , \"required\" : False if self . default is utils . EMPTY else True , \"type\" : self . type , \"autocomplete\" : self . autocomplete , \"choices\" : [ ( choice . to_payload () if isinstance ( choice , CommandChoice ) else { \"name\" : choice , \"value\" : choice }) for choice in self . choices ], \"channel_types\" : self . channel_types , \"min_value\" : self . min_value , \"min_length\" : self . min_length , \"max_length\" : self . max_length , \"max_value\" : self . max_value , \"name_localizations\" : _locale . final_data if not isinstance (( _locale := self . name_locales ), utils . Empty ) else {}, \"description_localizations\" : _locale . final_data if not isinstance (( _locale := self . description_locales ), utils . Empty ) else {}, }","title":"CommandOption"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.autocomplete","text":"Weather to enable autocomplete for this option or not.","title":"autocomplete"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.channel_types","text":"List of channel types for channel options.","title":"channel_types"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.choices","text":"List of choices to add to the option.","title":"choices"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.converter","text":"A custom converter for the option, if any.","title":"converter"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.default","text":"Default value for the option","title":"default"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.description","text":"Description of the option.","title":"description"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.description_locales","text":"Description locales for the option.","title":"description_locales"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.max_length","text":"Maximum length acceptable for the option","title":"max_length"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.max_value","text":"Maximum value for the option","title":"max_value"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.min_length","text":"Minimum length acceptable for the option","title":"min_length"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.min_value","text":"Minimum value for the option","title":"min_value"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.name","text":"Name of the option.","title":"name"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.name_locales","text":"Name locales for the option.","title":"name_locales"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.CommandOption.type","text":"Type of the option.","title":"type"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand","text":"Bases: BaseCallable , HasAutoComplete Represents a slash command constructor. Source code in wyvern/commands/slash_commands.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 @attrs . define ( kw_only = True , slots = True , repr = True ) class SlashCommand ( BaseCallable , HasAutoComplete ): \"\"\"Represents a slash command constructor.\"\"\" name : str \"\"\"Name of the command.\"\"\" description : str \"\"\"Description of the command.\"\"\" options : list [ CommandOption ] = attrs . field ( init = False , default = []) \"\"\"List of command options.\"\"\" guild_only : bool = False \"\"\"Set to True for command to appear in guilds only.\"\"\" client : CommandsClient | None = attrs . field ( init = False , default = None ) callback : AppCommandCallbackT guild_ids : list [ int ] = [] \"\"\"\"\"\" def __str__ ( self ) -> str : return self . name async def __call__ ( self , * args : typing . Any , ** kwargs : typing . Any ) -> typing . Any : await self . callback ( * args , ** kwargs ) def _set_client ( self , client : CommandsClient ) -> \"SlashCommand\" : self . client = client return self def to_payload ( self ) -> dict [ str , typing . Any ]: return { \"name\" : self . name , \"description\" : self . description , \"options\" : [ option . to_payload () for option in self . options ], \"dm_permissions\" : not self . guild_only , \"type\" : interactions . base . InteractionCommandType . MESSAGE , } async def with_autocomplete ( self , opt_name : str | None = None , * , opt_names : typing . Sequence [ str ] = () ) -> typing . Callable [ ... , typing . Callable [ ... , typing . Awaitable [ typing . Sequence [ CommandChoice | str ]]]]: \"\"\"Interface for creating autocomplete callabcks. Parameters ---------- opt_name : str Name of the option this autocomplete is for. opt_names : typing.Sequence[str] Sequence of options this autocomplete is for. !!! note opt_names overrides opt_name ??? example ```py from __future__ import annotations import wyvern from wyvern import commands client = wyvern.CommandsClient(\"TOKEN\") @commands.with_option( name=\"color\", description=\"name of color to show hex of.\", type=commands.OptionType.INTEGER, autocomplete=True ) @client.slash_command(name=\"color_hex\", description=\"gives you color hexs\") async def colors(inter: wyvern.ApplicationCommandInteraction, color: int) -> None: await inter.create_message_response(f\"Hex for the color was {hex}\") @colors.with_autocomplete(opt_name=\"color\") async def autocomplete_inter( inter: wyvern.AutocompleteInteraction, option: wyvern.InteractionOption ) -> list[commands.CommandChoice]: colors = [commands.CommandChoice(name=\"blue\", value=0x4F62A3), commands.CommandChoice(name=\"red\", value=0xD11417)] return [color for color in colors if color.name in inter.data.value] client.run() ``` \"\"\" # noqa: E501 return await super () . with_autocomplete ( opt_name , opt_names = opt_names ) async def create_command ( self ) -> SlashCommand : \"\"\"Creates the command on discord ( if already doesnt exist ). Returns ------- wyvern.commands.SlashCommand This same object \"\"\" assert self . client await self . client . rest . _create_app_command_from_payload ( payload = self . to_payload ()) return self","title":"SlashCommand"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand.description","text":"Description of the command.","title":"description"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand.guild_only","text":"Set to True for command to appear in guilds only.","title":"guild_only"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand.name","text":"Name of the command.","title":"name"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand.options","text":"List of command options.","title":"options"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand.create_command","text":"Creates the command on discord ( if already doesnt exist ). Returns: Type Description wyvern . commands . SlashCommand This same object Source code in wyvern/commands/slash_commands.py 224 225 226 227 228 229 230 231 232 233 234 235 async def create_command ( self ) -> SlashCommand : \"\"\"Creates the command on discord ( if already doesnt exist ). Returns ------- wyvern.commands.SlashCommand This same object \"\"\" assert self . client await self . client . rest . _create_app_command_from_payload ( payload = self . to_payload ()) return self","title":"create_command()"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.SlashCommand.with_autocomplete","text":"Interface for creating autocomplete callabcks. Parameters: Name Type Description Default opt_name str Name of the option this autocomplete is for. None opt_names typing . Sequence [ str ] Sequence of options this autocomplete is for. () Note opt_names overrides opt_name Example from __future__ import annotations import wyvern from wyvern import commands client = wyvern . CommandsClient ( \"TOKEN\" ) @commands . with_option ( name = \"color\" , description = \"name of color to show hex of.\" , type = commands . OptionType . INTEGER , autocomplete = True ) @client . slash_command ( name = \"color_hex\" , description = \"gives you color hexs\" ) async def colors ( inter : wyvern . ApplicationCommandInteraction , color : int ) -> None : await inter . create_message_response ( f \"Hex for the color was { hex } \" ) @colors . with_autocomplete ( opt_name = \"color\" ) async def autocomplete_inter ( inter : wyvern . AutocompleteInteraction , option : wyvern . InteractionOption ) -> list [ commands . CommandChoice ]: colors = [ commands . CommandChoice ( name = \"blue\" , value = 0x4F62A3 ), commands . CommandChoice ( name = \"red\" , value = 0xD11417 )] return [ color for color in colors if color . name in inter . data . value ] client . run () Source code in wyvern/commands/slash_commands.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 async def with_autocomplete ( self , opt_name : str | None = None , * , opt_names : typing . Sequence [ str ] = () ) -> typing . Callable [ ... , typing . Callable [ ... , typing . Awaitable [ typing . Sequence [ CommandChoice | str ]]]]: \"\"\"Interface for creating autocomplete callabcks. Parameters ---------- opt_name : str Name of the option this autocomplete is for. opt_names : typing.Sequence[str] Sequence of options this autocomplete is for. !!! note opt_names overrides opt_name ??? example ```py from __future__ import annotations import wyvern from wyvern import commands client = wyvern.CommandsClient(\"TOKEN\") @commands.with_option( name=\"color\", description=\"name of color to show hex of.\", type=commands.OptionType.INTEGER, autocomplete=True ) @client.slash_command(name=\"color_hex\", description=\"gives you color hexs\") async def colors(inter: wyvern.ApplicationCommandInteraction, color: int) -> None: await inter.create_message_response(f\"Hex for the color was {hex}\") @colors.with_autocomplete(opt_name=\"color\") async def autocomplete_inter( inter: wyvern.AutocompleteInteraction, option: wyvern.InteractionOption ) -> list[commands.CommandChoice]: colors = [commands.CommandChoice(name=\"blue\", value=0x4F62A3), commands.CommandChoice(name=\"red\", value=0xD11417)] return [color for color in colors if color.name in inter.data.value] client.run() ``` \"\"\" # noqa: E501 return await super () . with_autocomplete ( opt_name , opt_names = opt_names )","title":"with_autocomplete()"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.as_slash_command","text":"Creates a slash command object. Parameters: Name Type Description Default name str Name of the command. required description str Description of the command. required Returns: Type Description typing . Callable [[ AppCommandCallbackT ], SlashCommand ] A SlashCommand when called. Source code in wyvern/commands/slash_commands.py 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 def as_slash_command ( * , name : str , description : str , guild_ids : typing . Sequence [ int ] = (), guild_only : bool = False , ) -> typing . Callable [[ AppCommandCallbackT ], SlashCommand ]: \"\"\"Creates a slash command object. Parameters ---------- name : str Name of the command. description : str Description of the command. Returns ------- typing.Callable[[AppCommandCallbackT], SlashCommand] A [SlashCommand][] when called. \"\"\" def inner ( callback : AppCommandCallbackT ) -> SlashCommand : return SlashCommand ( name = name , description = description , callback = callback , guild_ids = list ( guild_ids ), guild_only = guild_only ) return inner","title":"as_slash_command()"},{"location":"commands/slash_commands/#wyvern.commands.slash_commands.with_option","text":"Adds an option to a slash command. Parameters: Name Type Description Default name str Name of the option. required description str Description of the option. required type OptionType Type of the option. OptionType.STRING default typing . Any Default value for the option. utils.EMPTY convertor SlashOptionConvertor | None A custom convertor if any. required autcomplete bool Is autcomplete enabled for this option ( defaults to False ) required Returns: Type Description typing . Callable [[ SlashCommand ], SlashCommand ] The command this option was added to. Source code in wyvern/commands/slash_commands.py 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 def with_option ( * , name : str , description : str , type : OptionType = OptionType . STRING , default : typing . Any = utils . EMPTY , converter : SlashOptionConverter | None = None , autocomplete : bool = False , choices : typing . Sequence [ CommandChoice | str | int ] = [], channel_types : typing . Sequence [ \"ChannelType\" ] = [], min_value : int | None = None , max_value : int | None = None , min_length : int | None = None , max_length : int | None = None , name_locales : Localizations | utils . Empty = utils . EMPTY , description_locales : Localizations | utils . Empty = utils . EMPTY , ) -> typing . Callable [[ SlashCommand ], SlashCommand ]: \"\"\"Adds an option to a slash command. Parameters ---------- name : str Name of the option. description : str Description of the option. type : OptionType Type of the option. default : typing.Any Default value for the option. convertor : SlashOptionConvertor | None A custom convertor if any. autcomplete : bool Is autcomplete enabled for this option ( defaults to False ) Returns ------- typing.Callable[[SlashCommand], SlashCommand] The command this option was added to. \"\"\" def inner ( command : SlashCommand ) -> SlashCommand : command . options . append ( CommandOption ( name = name , description = description , default = default , type = type , converter = converter , autocomplete = autocomplete , choices = list ( choices ), channel_types = list ( channel_types ), min_length = min_length , min_value = min_value , max_length = max_length , max_value = max_value , name_locales = name_locales , description_locales = description_locales , ) ) return command return inner","title":"with_option()"},{"location":"guide/basic_bot/","text":"Creating a basic bot. wyvern/examples/basic_client.py import wyvern # creating a GatewayClient instance and storing it into the client variable. # this acts as the interface between your bot and the code. client = wyvern . GatewayClient ( \"TOKEN\" , intents = wyvern . Intents . UNPRIVILEGED | wyvern . Intents . MESSAGE_CONTENT ) # creating an EventListener object and adding it to the client's event handler using the # @client.with_listener decorator. You can set the maximum amount of time this listener will get triggered using # the `max_trigger kwarg in the listener decorator.` @client . with_listener ( wyvern . Event . MESSAGE_CREATE ) async def message_create ( message : wyvern . Message ) -> None : \"\"\"This coroutine is triggerd whenever the MESSAGE_CREATE event gets dispatched.\"\"\" if message . content and message . content . lower () == \"!ping\" : await message . respond ( \"pong!\" ) # runs the bot. client . run ()","title":"Basic Bot"},{"location":"guide/basic_bot/#creating-a-basic-bot","text":"wyvern/examples/basic_client.py import wyvern # creating a GatewayClient instance and storing it into the client variable. # this acts as the interface between your bot and the code. client = wyvern . GatewayClient ( \"TOKEN\" , intents = wyvern . Intents . UNPRIVILEGED | wyvern . Intents . MESSAGE_CONTENT ) # creating an EventListener object and adding it to the client's event handler using the # @client.with_listener decorator. You can set the maximum amount of time this listener will get triggered using # the `max_trigger kwarg in the listener decorator.` @client . with_listener ( wyvern . Event . MESSAGE_CREATE ) async def message_create ( message : wyvern . Message ) -> None : \"\"\"This coroutine is triggerd whenever the MESSAGE_CREATE event gets dispatched.\"\"\" if message . content and message . content . lower () == \"!ping\" : await message . respond ( \"pong!\" ) # runs the bot. client . run ()","title":"Creating a basic bot."}]}